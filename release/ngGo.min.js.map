{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","ngGo.min.js"],"names":["window","angular","undefined","module","constant","name","version","error","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","POSITION_IS_SUICIDE","POSITION_IS_REPEATING","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","E","EMPTY","B","BLACK","W","WHITE","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","SAD","HAPPY","PLAY","REPLAY","EDIT","SOLVE","NONE","MOVE","SCORE","SETUP","MARKUP","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","PAGEUP","PAGEDOWN","directive","$window","Board","createLayerCanvas","canvas","document","createElement","context","getContext","pixelRatio","scale","className","width","this","clientWidth","height","clientHeight","appendChild","determineDrawSize","scope","availableWidth","availableHeight","drawWidth","drawHeight","cellSize","Math","min","floor","lastDrawWidth","lastDrawHeight","$broadcast","devicePixelRatio","restrict","instance","link","element","attrs","i","layer","playerElement","parent","sizingElement","existingInstance","linkElement","tagName","$on","event","find","length","forceSize","css","setDrawSize","on","board","resized","addClass","makeStatic","call","layerOrder","layers","setContext","$observe","size","toLowerCase","indexOf","split","setSize","attr","toggleCoordinates","isDefined","setCutoff","swapColors","$parent","Player","setBoard","redraw","provider","defaultConfig","cutoff","section","top","right","bottom","left","coordinates","colorMultiplier","setConfig","config","extend","$get","$rootScope","$injector","BoardTheme","init","parseConfig","prototype","removeAll","theme","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","l","layerClass","toUpperCase","substr","LayerClass","get","margin","grid","setCoordinates","setSection","setMargin","isArray","changes","side","hasOwnProperty","parseInt","isNaN","show","multiplier","getTheme","setTheme","add","x","y","value","remove","has","setAll","updatePosition","position","pathChanged","stones","markup","getState","getAll","state","isEmpty","restoreState","clear","draw","xLeft","xRight","yTop","yBot","noCellsHor","noCellsVer","getCellSize","getAbsX","gridX","offset","round","getAbsY","gridY","getGridX","absX","getGridY","absY","isOnBoard","factory","obj","s","r","clearRect","BoardGridChanges","toObject","valueKey","BoardGrid","emptyValue","set","isOnGrid","unset","is","all","objects","push","populate","empty","clone","newGrid","copy","isSameAs","compare","console","warn","whenEmpty","getSize","setSubtract","a","b","q","n","j","concat","newChanges","BoardLayer","clearCell","drawCell","redrawCell","DefaultClearHandler","BoardObject","drawheight","shellLine","ctx","radius","startAngle","endAngle","strokeStyle","shadowBlur","lineWidth","thickness","beginPath","max","m","angle","x1","cos","PI","y1","sin","x2","y2","atan","c","factor","dx","dy","bx1","by1","bx2","by2","moveTo","bezierCurveTo","stroke","lines","StoneColor","MarkupTypes","defaultTheme","stone","style","shadow","shell","color","stoneColor","types","mono","lineColor","mini","alpha","faded","blur","offsetX","ceil","offsetY","triangle","square","circle","mark","lineCap","last","smiley","label","font","variation","type","text","String","fromCharCode","solution","valid","invalid","star","points","vertical","inverse","ch","horizontal","merge","instanceTheme","reset","property","path","prop","args","arguments","apply","canvasTranslate","defaultSize","defaultKomi","defaultHandicap","rememberPath","checkRepeat","allowSuicide","ngGo","GamePath","GameNode","GamePosition","KifuParser","KifuBlank","InvalidDataError","InvalidPositionError","validateInfo","info","game","komi","handicap","nextNode","node","children","rememberedPath","advance","previousNode","retreat","firstNode","root","setTurn","initializeHistory","history","pushPosition","newPosition","popPosition","pop","replacePosition","executeNode","isMove","move","pass","validateMove","turn","setup","Game","data","Object","defineProperty","load","jgf","fromData","errorCode","first","reload","isLoaded","props","getOwnPropertyNames","p","charAt","fromSgf","fromJgf","fromGib","gib","gib2jgf","sgf","sgf2jgf","fromJson","tree","toSgf","jgf2sgf","toJgf","stringify","toJson","getNode","getNodes","nodes","getChild","getMoveNode","getMoveNodes","fromMove","toMove","filter","getMoveNumber","getMove","getMoveCount","moveNodes","getMoveVariation","getPosition","getPath","clonePath","getPathToNode","nodeName","findNode","getKomi","parseFloat","setKomi","getName","getResult","getTurn","getCaptureCount","captures","defaultValue","key","isMoveVariation","isRepeatingPosition","checkPosition","stop","isValidMove","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","captureAdjacent","hasLiberties","POSTITION_IS_SUICIDE","captureGroup","POSTITION_IS_REPEATING","validatePlacement","addStone","tempPosition","appendTo","addMarkup","removeStone","foundInSetup","splice","removeMarkup","hasStone","hasMarkup","getStone","getMarkup","play","next","previous","target","setMove","nodeAt","nextFork","previousFork","nextComment","hasComments","previousComment","convertCoordinates","coords","charCodeAt","aChar","coordinatesObject","baseObject","toStringColor","toColorConstant","convertMoveToJgf","jgfMove","convertMoveFromJgf","convertSetupToJgf","jgfSetup","convertSetupFromJgf","gameSetup","convertMarkupToJgf","jgfMarkup","convertMarkupFromJgf","gameMarkup","convertTurnToJgf","convertTurnFromJgf","properties","conversionMap","getChildren","hasChildren","getParent","hasMoveVariations","moveVariations","getMoveVariations","comments","moveUp","temp","moveDown","insertNode","gameNode","variationNode","container","variationsContainer","variationContainer","findNodeName","branches","no","otherPath","newPath","rootNode","setStone","setMarkup","groupColor","tested","friendlyColor","captured","canCapture","enemyColor","doCapture","captureStone","setCaptures","getCaptures","switchTurn","calcTotal","territory","GameScore","self","black","white","total","winner","w","territorySet","candidateColor","boundaryColor","posColor","origColor","territoryReset","determineScoreState","curState","newState","adjacent","change","scoreState","UNKNOWN","BLACK_CANDIDATE","WHITE_CANDIDATE","BLACK_STONE","WHITE_STONE","NEUTRAL","GameScorer","score","getScore","getPoints","calculate","code","message","Error","constructor","blankJgf","record","application","charset","players","blankSgf","AP","CA","FF","GM","SZ","PB","PW","base","blank","CP","SO","US","AN","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","ON","GC","BT","WT","BR","WR","N","C","CR","TR","SQ","MA","SL","LB","1","2","3","4","6","7","8","Gib2Jgf","Sgf2Jgf","Jgf2Sgf","stringified","parse","controller","$scope","mode","switchMode","tool","switchTool","setVariationMarkup","toggleSolutionPaths","setLastMoveMarker","PlayerModes","PlayerTools","arrowKeysNavigation","scrollWheelNavigation","lastMoveMarker","variationMarkup","variationChildren","variationSiblings","$document","processMouseEvent","broadcastEvent","mouseEvent","originalEvent","layerX","layerY","drag","modes","tools","restrictNodeStart","restrictNodeEnd","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","arrowKeys","broadcast","scrollWheel","registerMode","PlayerMode","setTools","hasMode","hasTool","force","saveState","playerState","saveGameState","restoreGameState","allowPlayerConfig","processPosition","gameState","goto","restrictNode","end","updateBoard","showMoveNumbers","forEach","newGame","scoreGame","getBoard","off","bind","listener","querySelector","preventClickEvent","t","$$phase","$apply","Coordinates","drawStarPoint","starRadius","starColor","fillStyle","arc","fill","GridLayer","tx","ty","starPoints","translate","lineTo","Markup","StoneFaded","HoverLayer","restore","hover","object","objectClass","MarkupLayer","StoneMini","ScoreLayer","StoneShadow","ShadowLayer","shadowSize","setTransform","Stone","StonesLayer","kanji","aCharLc","numbers","letters","xl","xr","yt","yb","textBaseline","textAlign","fillText","drawTriangle","cosPi6","closePath","drawSquare","rcos","cosPi4","rect","drawCircle","drawMark","drawSelect","drawLast","drawHappySmiley","drawSadSmiley","drawLabel","toString","clearLabel","ShellPattern","drawMono","globalAlpha","drawGlass","createRadialGradient","addColorStop","drawSlateShell","shellSeed","random","shellTypes","z","handler","shadowColor","run","PlayerModeCommon","keyDown","mouseWheel","mouseMove","mouseOut","mouseDown","mouseUp","KeyCodes","dragObject","start","mouse","dragStart","normalizeMousewheelEvent","deltaX","deltaY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","mouseWheelX","mouseWheelY","lastX","lastY","keyboardEvent","keyCode","preventDefault","delta","CLEAR","TEXT","NUMBER","PlayerModeEdit","pathChange","toolSwitch","modeEnter","mouseDrag","click","SetupTools","MarkupTools","updateHoverMark","isDrag","setupTool","setupToolColor","markupTool","markupLabel","markupLabels","determineMarkupLabel","findAllMarkupLabels","switchSetupTool","switchMarkupTool","setMarkupLabel","statePreScoring","PlayerModeReplay","settingChange","boardUpdate","modeExit","autoPlayDelay","$interval","showMoveVariations","variations","hideMoveVariations","drawMoveVariations","autoPlaying","autoPlayPromise","setAutoPlayDelay","delay","cancel","setting","PlayerModeSolve","playerColor","solutionPaths","solveAutoPlay","solveAutoPlayDelay","$timeout","canMakeMove","problemSolved","problemOffPath","showSolutionPaths","hideSolutionPaths","drawSolutionPaths","problemStartPath","solveNavigationBlocked","setSolveAutoPlay","autoPlay","setSolveAutoPlayDelay","setPlayerColor","getPlayerColor","asOnBoard","autoPlayNext","immediately","solve","restartProblem","parsePlayer","match","player","rank","parseKomi","parseDate","dates","parseResult","result","parseMove","regMove","regPlayer","regKomi","regDate","regResultMargin","regResultOther","Parser","exec","sgfAliases","sgfGames","escapeSgf","replace","writeGroup","values","output","escape","parseSetup","parseScore","parseMarkup","jgfAliases","parseTurn","parseComments","flatComments","comment","parseNodeName","parseGame","parseApplication","parts","rootProperties","st","ST","parseBoard","parsePlayers","team","writeTree","parsingMap","extractRootProperties","subKey","jgfKey","sgfProp","record.application","game.type","game.players","parseApp","app","parseSgfFormat","parseComment","parseLabel","parseSize","d","parseVariations","setInfo","regSequence","regNode","regProperty","regValues","AB","AW","AE","PL","TW","TB","needsNode","stack","sequence","k","substring"],"mappings":"CAOA,SAAAA,EAAAC,EAAAC,GAAA,YA8BAD,GAAAE,OAAA,WAKAC,SAAA,QACAC,KAAA,OACAC,QAAA,QACAC,OAGAC,uBAAA,EACAC,2BAAA,EACAC,oBAAA,EACAC,sBAAA,EAGAC,QAAA,EACAC,aAAA,EACAC,YAAA,EACAC,YAAA,EACAC,iBAAA,EACAC,sBAAA,MAOAb,SAAA,cACAc,EAAA,EACAC,MAAA,EACAC,EAAA,EACAC,MAAA,EACAC,KACAC,WAMAnB,SAAA,eACAoB,SAAA,WACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,OAAA,SACAC,MAAA,QACAC,KAAA,OACAC,IAAA,MACAC,MAAA,UAMA5B,SAAA,eACA6B,KAAA,OACAC,OAAA,SACAC,KAAA,OACAC,MAAA,UAMAhC,SAAA,eACAiC,KAAA,OACAC,KAAA,OACAC,MAAA,QACAC,MAAA,QACAC,OAAA,WAMArC,SAAA,YACAsC,KAAA,GACAC,MAAA,GACAC,GAAA,GACAC,KAAA,GACAC,IAAA,GACAC,MAAA,GACAC,MAAA,GACAC,IAAA,EACAC,MAAA,GACAC,KAAA,GACAC,IAAA,GACAC,KAAA,GC9HAC,IAAA,GACAC,OAAA,GACAC,SAAA,MAGAxD,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAIAD,GAAAE,OAAA,wBACA,uBAMAsD,UAAA,SAAA,UAAA,QAAA,SAAAC,EAAAC,GAQA,QAAAC,GAAAvD,GAGA,GAAAwD,GAAAC,SAAAC,cAAA,UACAC,EAAAH,EAAAI,WAAA,KAgBA,OAbAC,GAAA,GACAF,EAAAG,MAAAD,EAAAA,GAIAL,EAAAO,UAAA/D,EAGAwD,EAAAQ,MAAAC,KAAAC,YAAAL,EACAL,EAAAW,OAAAF,KAAAG,aAAAP,EAGAI,KAAAI,YAAAb,GACAG,EAMA,QAAAW,GAAAC,EAAAC,EAAAC,GAGA,GAAAC,GAAAC,EAAAC,CAwBA,OArBA,KAAAH,GAAAD,EAAA,IACAC,EAAAD,GAIAD,EAAAjB,MAAAU,OAAAO,EAAAjB,MAAAa,QAGAS,EAAAC,KAAAC,IAAAN,EAAAD,EAAAjB,MAAAU,MAAAS,EAAAF,EAAAjB,MAAAa,QAGAO,EAAAG,KAAAE,MAAAH,EAAAL,EAAAjB,MAAAU,OACAW,EAAAE,KAAAE,MAAAH,EAAAL,EAAAjB,MAAAa,SAKAO,EAAAC,EAAAE,KAAAC,IAAAN,EAAAC,IAIAF,EAAAS,gBAAAN,GAAAH,EAAAU,iBAAAN,KACAJ,EAAAS,cAAAN,EACAH,EAAAU,eAAAN,EACAJ,EAAAW,WAAA,6BAAAR,EAAAC,IACA,GA9DA,GAAAd,GAAAlE,EAAAwF,kBAAA,CAwEA,QACAC,SAAA,IACAb,OACAc,SAAA,KAMAC,KAAA,SAAAf,EAAAgB,EAAAC,GAGA,GAAAC,GAAA9B,EAAA+B,EAAAC,EACAC,EAAAL,EAAAK,SACAC,EAAAN,EAAA,GACAO,GAAA,CA+EA,IA5EAvB,EAAAS,cAAA,EACAT,EAAAU,eAAA,EAGAV,EAAAjB,MAAAiB,EAAAc,WAGA,kBAAAd,GAAAjB,QACAiB,EAAAjB,MAAAiB,EAAAjB,SAIAiB,EAAAjB,QACAwC,GAAA,EACAvB,EAAAjB,MAAA,GAAAA,IAIAiB,EAAAjB,MAAAyC,YAAAR,GAGA,WAAAK,EAAA,GAAAI,UACAL,EAAAC,EACAC,EAAAD,EAAAA,SAAA,IAIArB,EAAA0B,IAAA,6BAAA,SAAAC,EAAAlC,EAAAG,GAGA,GAAAX,GAAA+B,EAAAY,KAAA,SACA,KAAAV,EAAA,EAAAA,EAAAjC,EAAA4C,OAAAX,IACAjC,EAAAiC,GAAAzB,MAAAA,EAAAH,EACAL,EAAAiC,GAAAtB,OAAAA,EAAAN,GAIA8B,GAAA,SAAAH,EAAAa,YACAd,EAAAe,KAAAtC,MAAAA,EAAA,KAAAG,OAAAA,EAAA,OAIAI,EAAAjB,MAAAiD,YAAAvC,EAAAH,EAAAM,EAAAN,KAIAS,EAAAC,EAAAsB,EAAA3B,YAAA2B,EAAAzB,cAGAxE,EAAA2F,QAAAlC,GAAAmD,GAAA,SAAA,WACAlC,EAAAC,EAAAsB,EAAA3B,YAAA2B,EAAAzB,gBAIAG,EAAA0B,IAAA,+BAAA,WACA3B,EAAAC,EAAAsB,EAAA3B,YAAA2B,EAAAzB,gBAIAG,EAAA0B,IAAA,oBAAA,SAAAC,EAAAO,GAGAA,IAAAlC,EAAAjB,QAQAgB,EAAAC,EAAAsB,EAAA3B,YAAA2B,EAAAzB,eACAG,EAAAjB,MAAAoD,aAKAlB,EAAAA,WAAA,SAAAA,EAAAA,UAQA,IALAD,EAAAoB,SAAA,UACApC,EAAAjB,MAAAsD,aAGAjD,EAAAJ,EAAAsD,KAAAtB,EAAA,GAAA,UACAE,EAAA,EAAAA,EAAAlB,EAAAjB,MAAAwD,WAAAV,OAAAX,IACAC,EAAAnB,EAAAjB,MAAAwD,WAAArB,GACAlB,EAAAjB,MAAAyD,OAAArB,GAAAsB,WAAArD,OAQA,KAAA8B,EAAA,EAAAA,EAAAlB,EAAAjB,MAAAwD,WAAAV,OAAAX,IACAC,EAAAnB,EAAAjB,MAAAwD,WAAArB,GACA9B,EAAAJ,EAAAsD,KAAAtB,EAAA,GAAAG,GACAnB,EAAAjB,MAAAyD,OAAArB,GAAAsB,WAAArD,EAKA6B,GAAAyB,SAAA,OAAA,SAAAC,GACA,gBAAAA,IAAAA,EAAAC,cAAAC,QAAA,WACAF,EAAAA,EAAAG,MAAA,KACA9C,EAAAjB,MAAAgE,QAAAJ,EAAA,GAAAA,EAAA,KAGA3C,EAAAjB,MAAAgE,QAAAJ,EAAAA,KAKA1B,EAAAyB,SAAA,cAAA,SAAAM,GACAhD,EAAAjB,MAAAkE,kBAAA,SAAAD,KAIA/B,EAAAyB,SAAA,SAAA,SAAAM,GACA3H,EAAA6H,UAAAF,IACAhD,EAAAjB,MAAAoE,UAAAH,EAAAF,MAAA,QAKA7B,EAAAyB,SAAA,kBAAA,SAAAM,GACA3H,EAAA6H,UAAAF,IACAhD,EAAAjB,MAAAqE,WAAAJ,KAKAhD,EAAAqD,QAAAC,QACAtD,EAAAqD,QAAAC,OAAAC,SAAAvD,EAAAjB,OAIAwC,GACAvB,EAAAjB,MAAAyE,eCpPApI,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,sBACA,OACA,uBACA,2BACA,qCACA,uCACA,uCACA,uCACA,sCACA,sCACA,mCACA,kCACA,sCACA,yCAMAkI,SAAA,QAAA,WAKA,GAAAC,IAGAjE,MAAA,EACAG,OAAA,EAGA+D,UAGAC,SAAAC,IAAA,EAAAC,MAAA,EAAAC,OAAA,EAAAC,KAAA,GAGAC,aAAA,EAGAC,gBAAA,EAMAxE,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,aAAA,YAAA,aAAA,SAAAC,EAAAC,EAAAC,GAKA,QAAA1F,GAAAqF,GAGA1E,KAAAgF,OAGAhF,KAAAiF,YAAAP,OClFA,MDwFArF,GAAA6F,UAAAF,KAAA,WAGAhF,KAAAmF,YAGAnF,KAAAoF,MAAA,GAAAL,GAGA/E,KAAAW,SAAA,EACAX,KAAAS,UAAA,EACAT,KAAAU,WAAA,EACAV,KAAAqF,cAAA,EACArF,KAAAsF,cAAA,EACAtF,KAAAuF,cAAA,EACAvF,KAAAwF,eAAA,EAGAxF,KAAA6C,YAAA,OAAA,SAAA,SAAA,QAAA,SAAA,SAGA7C,KAAA8C,SACA,KAAA,GAAA2C,GAAA,EAAAA,EAAAzF,KAAA6C,WAAAV,OAAAsD,IAAA,CACA,GAAAhE,GAAAzB,KAAA6C,WAAA4C,GACAC,EAAAjE,EAAA,GAAAkE,cAAAlE,EAAAmE,OAAA,GAAA,QACAC,EAAAf,EAAAgB,IAAAJ,EACA1F,MAAA8C,OAAArB,GAAA,GAAAoE,GAAA7F,MAIAA,KAAAA,WAAA,EAGAA,KAAA+F,OAAA/F,KAAAoF,MAAAU,IAAA,gBAGA9F,KAAAwE,gBAAA,EAGAxE,KAAAuE,aAAA,EACAvE,KAAA8C,OAAAkD,KAAAC,gBAAA,GAGAjG,KAAAD,MAAA,EACAC,KAAAE,OAAA,EAGAF,KAAAiE,QACAE,KAAA,EACAG,MAAA,EACAF,OAAA,EACAC,QAAA,GAIArE,KAAAkE,SACAC,IAAA,EACAG,KAAA,EACAF,MAAA,EACAC,OAAA,IAOAhF,EAAA6F,UAAApD,YAAA,SAAAR,GACAtB,KAAAsB,QAAAA,GAMAjC,EAAA6F,UAAAvC,WAAA,WACA3C,KAAAA,WAAA,EACAA,KAAA6C,YAAA,OAAA,SAAA,WAUAxD,EAAA6F,UAAAD,YAAA,SAAAP,GAGA,gBAAAA,KAKAA,EAAA/I,EAAAgJ,UAAAX,EAAAU,GAGA1E,KAAAuD,kBAAAmB,EAAAH,aACAvE,KAAA0D,WAAAgB,EAAAF,iBACAxE,KAAAyD,UAAAiB,EAAAT,QACAjE,KAAAkG,WAAAxB,EAAAR,SACAlE,KAAAqD,QAAAqB,EAAA3E,MAAA2E,EAAAxE,UAMAb,EAAA6F,UAAAiB,UAAA,SAAAJ,GAcA,MAXA,mBAAAA,KACAA,EAAA/F,KAAAoF,MAAAU,IAAA,iBAIA9F,KAAA+F,SAAAA,IACA/F,KAAA+F,OAAAA,EACA/F,KAAAyC,WAIAzC,MAMAX,EAAA6F,UAAAzB,UAAA,SAAAQ,GAGAA,GAAAtI,EAAAyK,QAAAnC,KACAA,KAIA,IAAAoC,IAAA,CAGA,KAAA,GAAAC,KAAAtG,MAAAiE,OACAjE,KAAAiE,OAAAsC,eAAAD,KACArC,EAAAd,QAAAmD,QACAtG,KAAAiE,OAAAqC,KACAtG,KAAAiE,OAAAqC,IAAA,EACAD,GAAA,GAIArG,KAAAiE,OAAAqC,KACAtG,KAAAiE,OAAAqC,IAAA,EACAD,GAAA,GAYA,OALAA,IACArG,KAAAyC,UAIAzC,MAMAX,EAAA6F,UAAAgB,WAAA,SAAAhC,GAGA,MAAAA,IAAA,gBAAAA,IAKAA,EAAAvI,EAAAgJ,QACAR,IAAA,EACAG,KAAA,EACAF,MAAA,EACAC,OAAA,GACAH,GAIAlE,KAAAkE,QAAAC,MAAAD,EAAAC,KAAAnE,KAAAkE,QAAAG,SAAAH,EAAAG,QACArE,KAAAkE,QAAAI,OAAAJ,EAAAI,MAAAtE,KAAAkE,QAAAE,QAAAF,EAAAE,MAEApE,MAIAA,KAAAkE,QAAAA,EACAlE,KAAAyC,UAGAzC,OAxBAA,MA8BAX,EAAA6F,UAAA7B,QAAA,SAAAtD,EAAAG,GAOA,GAJAH,EAAAyG,SAAAzG,GAAAG,GAAA,GACAA,EAAAsG,SAAAtG,GAAAH,GAAA,IAGA0G,MAAA1G,KAAA0G,MAAAvG,GAAA,CAKA,GAAAH,IAAAC,KAAAD,OAAAG,IAAAF,KAAAE,OAAA,CAGAF,KAAAD,MAAAA,EACAC,KAAAE,OAAAA,CAGA,KAAA,GAAAuB,KAAAzB,MAAA8C,OACA9C,KAAA8C,OAAAyD,eAAA9E,IACAzB,KAAA8C,OAAArB,GAAA4B,QAAAtD,EAAAG,EAKA2E,GAAA5D,WAAA,oBAAAjB,KAAAD,EAAAG,GAIA,MAAAF,QAMAX,EAAA6F,UAAA5C,YAAA,SAAAvC,EAAAG,GACAH,IAAAC,KAAAS,WAAAP,IAAAF,KAAAU,aACAV,KAAAS,UAAAV,EACAC,KAAAU,WAAAR,EACAF,KAAAyC,YAOApD,EAAA6F,UAAA3B,kBAAA,SAAAmD,GAGA,mBAAAA,GACA1G,KAAAuE,YAAAmC,EAGA1G,KAAAuE,aAAAvE,KAAAuE,YAIAvE,KAAA8C,OAAAkD,KAAAC,eAAAjG,KAAAuE,aAGAvE,KAAAuE,YACAvE,KAAAmG,UAAAnG,KAAAoF,MAAAU,IAAA,uBAGA9F,KAAAmG,UAAAnG,KAAAoF,MAAAU,IAAA,kBAOAzG,EAAA6F,UAAAxB,WAAA,SAAAiD,GAGA,GAAA,mBAAAA,GACAA,GAAA3G,KAAAwE,oBAIA,IADAmC,EAAAH,SAAAG,GACAF,MAAAE,GACA,MAKAA,KAAA3G,KAAAwE,kBAKAxE,KAAAwE,gBAAAmC,EAGA3G,KAAAA,UACAA,KAAA8D,UAKA9D,KAAA8D,OAAA,UACA9D,KAAA8D,OAAA,aAWAzE,EAAA6F,UAAA0B,SAAA,WACA,MAAA5G,MAAAoF,OAMA/F,EAAA6F,UAAA2B,SAAA,SAAAzB,GAEA,MADApF,MAAAoF,MAAAA,EACApF,MAUAX,EAAA6F,UAAA4B,IAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GACA,mBAAAjH,MAAA8C,OAAArB,IACAzB,KAAA8C,OAAArB,GAAAqF,IAAAC,EAAAC,EAAAC,IAOA5H,EAAA6F,UAAAgC,OAAA,SAAAzF,EAAAsF,EAAAC,GACA,mBAAAhH,MAAA8C,OAAArB,IACAzB,KAAA8C,OAAArB,GAAAyF,OAAAH,EAAAC,IAOA3H,EAAA6F,UAAAY,IAAA,SAAArE,EAAAsF,EAAAC,GACA,MAAAhH,MAAA8C,OAAArB,IAAAzB,KAAA8C,OAAArB,GAAAqE,IAAAiB,EAAAC,IAMA3H,EAAA6F,UAAAiC,IAAA,SAAA1F,EAAAsF,EAAAC,GACA,MAAAhH,MAAA8C,OAAArB,IAAAzB,KAAA8C,OAAArB,GAAA0F,IAAAJ,EAAAC,IAMA3H,EAAA6F,UAAAkC,OAAA,SAAA3F,EAAAuE,GACA,mBAAAhG,MAAA8C,OAAArB,IACAzB,KAAA8C,OAAArB,GAAA2F,OAAApB,IAOA3G,EAAA6F,UAAAC,UAAA,SAAA1D,GACA,GAAAA,EACA,mBAAAzB,MAAA8C,OAAArB,IACAzB,KAAA8C,OAAArB,GAAA0D,gBAIA,KAAA1D,IAAAzB,MAAA8C,OACA9C,KAAA8C,OAAAyD,eAAA9E,IACAzB,KAAA8C,OAAArB,GAAA0D,aAaA9F,EAAA6F,UAAAmC,eAAA,SAAAC,EAAAC,GAGAvH,KAAAD,OAAAC,KAAAE,QACAF,KAAAqD,QAAAiE,EAAAvH,MAAAuH,EAAApH,QAIAqH,GACAvH,KAAAmF,UAAA,UAIAnF,KAAAoH,OAAA,SAAAE,EAAAE,QACAxH,KAAAoH,OAAA,SAAAE,EAAAG,SAUApI,EAAA6F,UAAAwC,SAAA,SAAAjG,GAGA,GAAAA,EACA,MAAAzB,MAAA8C,OAAArB,GACAzB,KAAA8C,OAAArB,GAAAkG,SAEA,IAIA,IAAAC,KACA,KAAAnG,IAAAzB,MAAA8C,OACA,GAAA9C,KAAA8C,OAAAyD,eAAA9E,GAAA,CACA,GAAAuE,GAAAhG,KAAA8C,OAAArB,GAAAkG,QACA3B,KAAAA,EAAA6B,YACAD,EAAAnG,GAAAuE,GAIA,MAAA4B,IAMAvI,EAAA6F,UAAA4C,aAAA,SAAAF,EAAAnG,GAGA,GAAAA,EAIA,YAHAzB,KAAA8C,OAAArB,IACAzB,KAAA8C,OAAArB,GAAA2F,OAAAQ,GAMA,KAAAnG,IAAAzB,MAAA8C,OACA9C,KAAA8C,OAAAyD,eAAA9E,KACAzB,KAAA8C,OAAArB,GAAA0D,YACAyC,EAAAnG,IACAzB,KAAA8C,OAAArB,GAAA2F,OAAAQ,EAAAnG,MAaApC,EAAA6F,UAAA6C,MAAA,SAAAtG,GAGA,GAAAA,EAAA,CAGA,GAAAzB,KAAAA,YAAAA,KAAA8C,OAAArB,GACA,MAKA,YADAzB,MAAA8C,OAAArB,GAAAsG,QAKA,GAAA/H,KAAAA,UAEA,WADAA,MAAA8C,OAAA0E,OAAAO,OAKA,KAAAtG,IAAAzB,MAAA8C,OACA9C,KAAA8C,OAAAyD,eAAA9E,IACAzB,KAAA8C,OAAArB,GAAAsG,SAQA1I,EAAA6F,UAAApB,OAAA,SAAArC,GAGA,GAAAzB,KAAAD,OAAAC,KAAAE,QAAAF,KAAAS,WAAAT,KAAAU,WAAA,CAKA,GAAAe,EAAA,CAGA,GAAAzB,KAAAA,YAAAA,KAAA8C,OAAArB,GACA,MAKA,YADAzB,MAAA8C,OAAArB,GAAAqC,SAKA9D,KAAA+H,OAGA,KAAA,GAAAvG,GAAA,EAAAA,EAAAxB,KAAA6C,WAAAV,OAAAX,IACAC,EAAAzB,KAAA6C,WAAArB,GACAxB,KAAA8C,OAAArB,GAAAuG,SAWA3I,EAAA6F,UAAAzC,QAAA,WAWA,GARAzC,KAAAgG,MACAiC,MAAA,EAAAjI,KAAAkE,QAAAI,KACA4D,OAAAlI,KAAAD,MAAA,EAAAC,KAAAkE,QAAAE,MACA+D,KAAA,EAAAnI,KAAAkE,QAAAC,IACAiE,KAAApI,KAAAE,OAAA,EAAAF,KAAAkE,QAAAG,QAIArE,KAAAD,OAAAC,KAAAE,QAAAF,KAAAS,WAAAT,KAAAU,WAAA,CAMA,GAAA2H,GAAArI,KAAAD,MAAAC,KAAA+F,OACAuC,EAAAtI,KAAAE,OAAAF,KAAA+F,MAGA,KAAA,GAAAO,KAAAtG,MAAAiE,OACAjE,KAAAiE,OAAAqC,KACA,QAAAA,GAAA,WAAAA,EACAgC,GAAA,GAGAD,GAAA,GAMArI,MAAAW,SAAAC,KAAAE,MAAAF,KAAAC,IACAb,KAAAS,UAAA4H,EACArI,KAAAU,WAAA4H,IAIAtI,KAAAuF,cAAAvF,KAAAW,UAAA0H,EAAArI,KAAA+F,OAAA,GACA/F,KAAAwF,eAAAxF,KAAAW,UAAA2H,EAAAtI,KAAA+F,OAAA,GAGA/F,KAAAqF,cAAAzE,KAAAE,OAAAd,KAAAS,UAAAT,KAAAuF,eAAA,GACAvF,KAAAsF,cAAA1E,KAAAE,OAAAd,KAAAU,WAAAV,KAAAwF,gBAAA,GAGAxF,KAAA8D,WAMAzE,EAAA6F,UAAAqD,YAAA,WACA,MAAAvI,MAAAW,UAMAtB,EAAA6F,UAAAsD,QAAA,SAAAC,GACA,GAAAC,GAAA1I,KAAAiE,OAAAK,KAAA,GAAA,CACA,OAAAtE,MAAAqF,cAAAzE,KAAA+H,OAAAF,EAAAC,GAAA1I,KAAAW,WAMAtB,EAAA6F,UAAA0D,QAAA,SAAAC,GACA,GAAAH,GAAA1I,KAAAiE,OAAAE,IAAA,GAAA,CACA,OAAAnE,MAAAsF,cAAA1E,KAAA+H,OAAAE,EAAAH,GAAA1I,KAAAW,WAMAtB,EAAA6F,UAAA4D,SAAA,SAAAC,GACA,GAAAL,GAAA1I,KAAAiE,OAAAK,KAAA,GAAA,CACA,OAAA1D,MAAA+H,OAAAI,EAAA/I,KAAAqF,eAAArF,KAAAW,SAAA+H,IAMArJ,EAAA6F,UAAA8D,SAAA,SAAAC,GACA,GAAAP,GAAA1I,KAAAiE,OAAAE,IAAA,GAAA,CACA,OAAAvD,MAAA+H,OAAAM,EAAAjJ,KAAAsF,eAAAtF,KAAAW,SAAA+H,IAMArJ,EAAA6F,UAAAgE,UAAA,SAAAT,EAAAI,GACA,MACAJ,IAAAzI,KAAAgG,KAAAiC,OAAAY,GAAA7I,KAAAgG,KAAAmC,MACAM,GAAAzI,KAAAgG,KAAAkC,QAAAW,GAAA7I,KAAAgG,KAAAoC,MCptBA/I,OAIA3D,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,0CACA,SAMAsN,QAAA,sBAAA,WAQA,MAAA,UAAAzJ,EAAA0J,GAGA,GAAA1J,EAAA,CAKA,GAAAqH,GAAA/G,KAAAwC,MAAAgG,QAAAY,EAAArC,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAQ,EAAApC,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EC3CA3J,GAAA6J,UAAAxC,EAAAuC,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAAA,QAIA5N,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,2BACA,OACA,mCAMAsN,QAAA,aAAA,mBAAA,SAAAK,GAKA,QAAAC,GAAA1C,EAAAC,EAAA0C,GAGA,GAAAN,IACArC,EAAAA,EACAC,EAAAA,EAIA,OAAA,gBAAAhH,MAAAgG,KAAAe,GAAAC,GACArL,EAAAgJ,OAAAyE,EAAApJ,KAAAgG,KAAAe,GAAAC,KAIAoC,EAAAM,GAAA1J,KAAAgG,KAAAe,GAAAC,GACAoC,GAMA,QAAAO,GAAA5J,EAAAG,EAAA0J,GAGA5J,KAAAD,MAAA,EACAC,KAAAE,OAAA,EACAF,KAAAgG,QACAhG,KAAA4J,WAAA,KAGA,mBAAAA,KACA5J,KAAA4J,WAAAA,IAIA7J,GAAAG,IACAF,KAAAqD,QAAAtD,EAAAG,GCjEA,MDwEAyJ,GAAAzE,UAAA2E,IAAA,SAAA9C,EAAAC,EAAAC,GACAjH,KAAA8J,SAAA/C,EAAAC,KACAhH,KAAAgG,KAAAe,GAAAC,GAAAC,IAOA0C,EAAAzE,UAAA6E,MAAA,SAAAhD,EAAAC,GACAhH,KAAA8J,SAAA/C,EAAAC,KACAhH,KAAAgG,KAAAe,GAAAC,GAAAhH,KAAA4J,aAOAD,EAAAzE,UAAAiC,IAAA,SAAAJ,EAAAC,GACA,MAAAhH,MAAA8J,SAAA/C,EAAAC,IAAAhH,KAAAgG,KAAAe,GAAAC,KAAAhH,KAAA4J,YAMAD,EAAAzE,UAAA8E,GAAA,SAAAjD,EAAAC,EAAAC,GACA,MAAAjH,MAAA8J,SAAA/C,EAAAC,IAAAhH,KAAAgG,KAAAe,GAAAC,KAAAC,GAMA0C,EAAAzE,UAAAY,IAAA,SAAAiB,EAAAC,EAAA0C,GAGA,MAAA1J,MAAA8J,SAAA/C,EAAAC,IAAAhH,KAAAgG,KAAAe,GAAAC,KAAAhH,KAAA4J,WAKAF,EAKAD,EAAA7G,KAAA5C,KAAA+G,EAAAC,EAAA0C,GAJA1J,KAAAgG,KAAAe,GAAAC,GALAhH,KAAA4J,YAoBAD,EAAAzE,UAAA+E,IAAA,SAAAP,GAGA,IAAAA,EACA,MAAA1J,MAAAgG,IAOA,KAAA,GAHAkE,MAGAnD,EAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACAhH,KAAAgG,KAAAe,GAAAC,KAAAhH,KAAA4J,YACAM,EAAAC,KAAAV,EAAA7G,KAAA5C,KAAA+G,EAAAC,EAAA0C,GAMA,OAAAQ,IAMAP,EAAAzE,UAAA2C,QAAA,WACA,IAAA,GAAAd,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACA,GAAAhH,KAAAgG,KAAAe,GAAAC,KAAAhH,KAAA4J,WACA,OAAA,CAIA,QAAA,GAMAD,EAAAzE,UAAAkF,SAAA,SAAAnD,GACA,IAAA,GAAAF,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACAhH,KAAAgG,KAAAe,GAAAC,GAAAC,GAQA0C,EAAAzE,UAAAmF,MAAA,WACA,IAAA,GAAAtD,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACAhH,KAAAgG,KAAAe,GAAAC,GAAAhH,KAAA4J,YAQAD,EAAAzE,UAAAoF,MAAA,WAGA,GAAAC,GAAA,GAAAZ,EASA,OANAY,GAAAvE,KAAArK,EAAA6O,KAAAxK,KAAAgG,MACAuE,EAAAX,WAAA5J,KAAA4J,WACAW,EAAAxK,MAAAC,KAAAD,MACAwK,EAAArK,OAAAF,KAAAE,OAGAqK,GAUAZ,EAAAzE,UAAAuF,SAAA,SAAAzE,GAGA,GAAAhG,KAAAD,QAAAiG,EAAAjG,OAAAC,KAAAE,SAAA8F,EAAA9F,OACA,OAAA,CAIA,KAAA,GAAA6G,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACA,GAAAhH,KAAAgG,KAAAe,GAAAC,KAAAhB,EAAAe,GAAAC,GACA,OAAA,CAMA,QAAA,GAMA2C,EAAAzE,UAAAwF,QAAA,SAAAH,EAAAb,GAGA,GAAArD,GAAA,GAAAmD,EAGA,IAAAxJ,KAAAD,QAAAwK,EAAAxK,OAAAC,KAAAE,SAAAqK,EAAArK,OAEA,MADAyK,SAAAC,KAAA,+CACAvE,CAIA,KAAA,GAAAU,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IAGAuD,EAAAvE,KAAAe,GAAAC,KAAAhH,KAAA4J,YAAAW,EAAAvE,KAAAe,GAAAC,KAAAhH,KAAAgG,KAAAe,GAAAC,IACAX,EAAAS,IAAAqD,KAAAV,EAAA7G,KAAA2H,EAAAxD,EAAAC,EAAA0C,IAIA1J,KAAAgG,KAAAe,GAAAC,KAAAhH,KAAA4J,YAAAW,EAAAvE,KAAAe,GAAAC,KAAAhH,KAAAgG,KAAAe,GAAAC,IACAX,EAAAa,OAAAiD,KAAAV,EAAA7G,KAAA5C,KAAA+G,EAAAC,EAAA0C,GAMA,OAAArD,IAUAsD,EAAAzE,UAAA4E,SAAA,SAAA/C,EAAAC,GACA,MAAAD,IAAA,GAAAC,GAAA,GAAAD,EAAA/G,KAAAD,OAAAiH,EAAAhH,KAAAE,QAMAyJ,EAAAzE,UAAA2F,UAAA,SAAAjB,GACA5J,KAAA4J,WAAAA,GAMAD,EAAAzE,UAAA7B,QAAA,SAAAtD,EAAAG,GAGAH,EAAAA,GAAAG,GAAA,EACAA,EAAAA,GAAAH,GAAA,EAGAC,KAAAD,MAAAyG,SAAAzG,GACAC,KAAAE,OAAAsG,SAAAtG,GAGAF,KAAAgG,OACA,KAAA,GAAAe,GAAA,EAAAA,EAAA/G,KAAAD,MAAAgH,IAAA,CACA/G,KAAAgG,KAAAe,KACA,KAAA,GAAAC,GAAA,EAAAA,EAAAhH,KAAAE,OAAA8G,IACAhH,KAAAgG,KAAAe,GAAAC,GAAAhH,KAAA4J,aAQAD,EAAAzE,UAAA4F,QAAA,WACA,OAAA/K,MAAAC,KAAAD,MAAAG,OAAAF,KAAAE,SCvTAyJ,MAGAjO,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,kCACA,SAMAsN,QAAA,mBAAA,WAKA,QAAA4B,GAAAC,EAAAC,GAGA,IAAA,GADAC,GADAC,KAEA3J,EAAA,EAAAA,EAAAwJ,EAAA7I,OAAAX,IAAA,CACA0J,GAAA,CACA,KAAA,GAAAE,KAAAH,GACA,GAAAD,EAAAxJ,GAAAuF,IAAAkE,EAAAG,GAAArE,GAAAiE,EAAAxJ,GAAAwF,IAAAiE,EAAAG,GAAApE,EAAA,CACAkE,GAAA,CACA,OAGAA,GACAC,EAAAhB,KAAAa,EAAAxJ,IAGA,MAAA2J,GAMA,MAAA,YAKAnL,KAAA8G,OACA9G,KAAAkH,UAKAlH,KAAAqL,OAAA,SAAAC,GACAtL,KAAA8G,IAAAiE,EAAA/K,KAAA8G,IAAAwE,EAAApE,QAAAmE,OAAAC,EAAAxE,KACA9G,KAAAkH,OAAA6D,EAAA/K,KAAAkH,OAAAoE,EAAAxE,KAAAuE,OAAAC,EAAApE,SAMAlH,KAAAmH,IAAA,WCrEA,SAAAnH,KAAA8G,IAAA3E,SAAAnC,KAAAkH,OAAA/E,aAKAzG,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,4BACA,OACA,4BAMAsN,QAAA,cAAA,YAAA,SAAAQ,GAKA,QAAA4B,GAAA/I,EAAA9C,GAGAM,KAAAwC,MAAAA,EACAxC,KAAAN,QAAAA,EAGAM,KAAAgG,KAAA,GAAA2D,GCpCA,MD8CA4B,GAAArG,UAAA7B,QAAA,SAAAtD,EAAAG,GAOAF,KAAAgG,KAAA3C,QAAAtD,EAAAG,IAMAqL,EAAArG,UAAAyC,OAAA,WACA,MAAA3H,MAAAgG,KAAAsE,SAMAiB,EAAArG,UAAAkC,OAAA,SAAApB,GACAhG,KAAAgG,KAAAA,EAAAsE,SAMAiB,EAAArG,UAAAC,UAAA,WACAnF,KAAA+H,QACA/H,KAAAgG,KAAAqE,SAMAkB,EAAArG,UAAA4B,IAAA,SAAAC,EAAAC,EAAAC,GACAjH,KAAAwL,UAAAzE,EAAAC,GACAhH,KAAAgG,KAAA6D,IAAA9C,EAAAC,EAAAC,GACAjH,KAAAyL,SAAA1E,EAAAC,IAMAuE,EAAArG,UAAAgC,OAAA,SAAAH,EAAAC,GACAhH,KAAAwL,UAAAzE,EAAAC,GACAhH,KAAAgG,KAAA+D,MAAAhD,EAAAC,IAMAuE,EAAArG,UAAAY,IAAA,SAAAiB,EAAAC,GACA,MAAAhH,MAAAgG,KAAAF,IAAAiB,EAAAC,IAMAuE,EAAArG,UAAAiC,IAAA,SAAAJ,EAAAC,GACA,MAAAhH,MAAAgG,KAAAmB,IAAAJ,EAAAC,IAUAuE,EAAArG,UAAA8C,KAAA,aAOAuD,EAAArG,UAAA6C,MAAA,WACA/H,KAAAN,SACAM,KAAAN,QAAA6J,UACA,EAAA,EAAAvJ,KAAAN,QAAAH,OAAAU,YAAAD,KAAAN,QAAAH,OAAAY,eAQAoL,EAAArG,UAAApB,OAAA,WACA9D,KAAA+H,QACA/H,KAAAgI,QAMAuD,EAAArG,UAAAuG,SAAA,aAOAF,EAAArG,UAAAsG,UAAA,aAOAD,EAAArG,UAAAwG,WAAA,SAAA3E,EAAAC,GACAhH,KAAAwL,UAAAzE,EAAAC,GACAhH,KAAAyL,SAAA1E,EAAAC,IAMAuE,EAAArG,UAAAnC,WAAA,SAAArD,GACAM,KAAAN,QAAAA,GAMA6L,EAAArG,UAAAvF,WAAA,WACA,MAAAK,MAAAN,SC5KA6L,MAGA7P,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,6BACA,OACA,2CAMAsN,QAAA,eAAA,sBAAA,SAAAwC,GAKA,GAAAC,IAKA5D,KAAA,WACA,IAAAhI,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,YAQA9D,MAAA,SAAAqB,GACAuC,EAAA/I,KAAA5C,KAAAA,KAAAN,QAAA0J,IC1CA,OAAAwC,OAGAlQ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,mCACA,SAMAsN,QAAA,eAAA,WAKA,QAAA2C,GAAAC,EAAAhF,EAAAC,EAAAgF,EAAAC,EAAAC,EAAAC,GAGAJ,EAAAK,WAAA,EACAL,EAAAI,YAAAA,EACAJ,EAAAM,UAAAL,EAAA,GAAAhM,KAAAsM,UACAP,EAAAQ,YAGAP,GAAApL,KAAA4L,IAAA,EAAAT,EAAAM,UAGA,IAMAI,GAAAC,EANAC,EAAA5F,EAAAiF,EAAApL,KAAAgM,IAAAX,EAAArL,KAAAiM,IACAC,EAAA9F,EAAAgF,EAAApL,KAAAmM,IAAAd,EAAArL,KAAAiM,IACAG,EAAAjG,EAAAiF,EAAApL,KAAAgM,IAAAV,EAAAtL,KAAAiM,IACAI,EAAAjG,EAAAgF,EAAApL,KAAAmM,IAAAb,EAAAtL,KAAAiM,GAIAG,GAAAL,GACAF,GAAAQ,EAAAH,IAAAE,EAAAL,GACAD,EAAA9L,KAAAsM,KAAAT,IAEAO,IAAAL,EACAD,EAAA9L,KAAAiM,GAAA,GAGAJ,GAAAQ,EAAAH,IAAAE,EAAAL,GACAD,EAAA9L,KAAAsM,KAAAT,GAAA7L,KAAAiM,GAIA,IAAAM,GAAAnN,KAAAoN,OAAApB,EACAqB,EAAAzM,KAAAmM,IAAAL,GAAAS,EACAG,EAAA1M,KAAAgM,IAAAF,GAAAS,EAGAI,EAAAZ,EAAAU,EACAG,EAAAV,EAAAQ,EACAG,EAAAT,EAAAK,EACAK,EAAAT,EAAAK,CAGAvB,GAAA4B,OAAAhB,EAAAG,GACAf,EAAA6B,cAAAL,EAAAC,EAAAC,EAAAC,EAAAV,EAAAC,GACAlB,EAAA8B,SAMA,MAAA,UAAA9B,EAAAhF,EAAAC,EAAAgF,EAAAU,EAAAP,GAOA,IAAA,GAJAF,GAAAS,EACAR,EAAAQ,EAGAlL,EAAA,EAAAA,EAAAxB,KAAA8N,MAAA3L,OAAAX,IACAyK,GAAAjM,KAAA8N,MAAAtM,GACA0K,GAAAlM,KAAA8N,MAAAtM,GCxFAsK,EAAAlJ,KAAA5C,KAAA+L,EAAAhF,EAAAC,EAAAgF,EAAAC,EAAAC,EAAAC,OAKAzQ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,4BACA,SAMAkI,SAAA,cAAA,aAAA,cAAA,SAAAgK,EAAAC,GAKA,GAAAC,IAGAzL,OAGAuD,OAAA,KAIAmI,OAGAC,MAAA,QACAC,QAAA,EACApC,OAAA,SAAArL,GACA,MAAAC,MAAAE,MAAAH,EAAA,IAIA0N,OACAC,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAjR,EACA,OAEA,WAEA+Q,OAAA,yBACAW,QAEAV,OAAA,GAAA,IAAA,IAAA,GAAA,IAAA,IAAA,IAAA,KACAV,OAAA,IACAd,UAAA,OAGAwB,OAAA,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,GACAd,UAAA,MAGAwB,OAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,IACAd,UAAA,OAGAwB,OAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,GACAd,UAAA,KAMAmC,MACApC,UAAA,EACAqC,UAAA,WACA,MAAA,QAEAJ,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAjR,EACA,OAEA,SAKA6R,MACA9O,MAAA,GACA+O,MAAA,GAIAC,OACAhP,MAAA,EACA+O,MAAA,SAAAL,GACA,MAAAA,KAAAR,EAAAjR,EACA,GAEA,MAMAsR,QAGAE,MAAA,qBAGArL,KAAA,SAAAtC,GACA,MAAAC,MAAAE,MAAAH,EAAA,KAIAmO,KAAA,SAAAnO,GACA,MAAAA,GAAA,IAIAoO,QAAA,SAAApO,GACA,MAAAC,MAAAoO,KAAArO,EAAA,KAEAsO,QAAA,SAAAtO,GACA,MAAAC,MAAAoO,KAAArO,EAAA,MAKA8G,QAGA6G,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAjR,EACA,wBAEA,mBAIAuP,UAAA,SAAA1L,GACA,MAAAC,MAAA4L,IAAA,EAAA5L,KAAAE,MAAAH,EAAA,MAIAuO,UACArP,MAAA,KAIAsP,QACAtP,MAAA,KAIAuP,QACAvP,MAAA,KAIAwP,MACAC,QAAA,SACAzP,MAAA,KAIA0P,MACA1P,MAAA,IAIA2P,QACAF,QAAA,QACAzP,MAAA,KAIA4P,OACAC,KAAA,SAIAC,WACAC,KAAA5B,EAAAzQ,MACAsS,KAAA,SAAArO,GACA,MAAAsO,QAAAC,aAAA,GAAAvO,IAEA8M,MAAA,uBAIA0B,UACAC,OACAL,KAAA5B,EAAA1Q,OACAuS,KAAA,KACAvB,MAAA,oBACAzO,MAAA,IAEAqQ,SACAN,KAAA5B,EAAA3Q,KACAwS,KAAA,KACAvB,MAAA,mBACAzO,MAAA,MAMAmG,MAGA0I,UAAA,mBACArC,UAAA,SAAA1L,GACA,MAAAA,GAAA,GACA,EAEAA,EAAA,GACA,IAEA,GAEA2O,QAAA,SAGAa,MAGA7B,MAAA,mBACAtC,OAAA,SAAArL,GACA,MAAAA,GAAA,GACAC,KAAAE,MAAAH,EAAA,GAAA,GAEAA,EAAA,GACA,EAEAA,EAAA,GACA,EAEAA,EAAA,EACA,IAEA,GAIAyP,OAAA,SAAArQ,EAAAG,GAGA,MAAAH,KAAAG,GAAA,KAAAH,IAEAgH,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,GAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,GAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,KAAAD,EAAA,EAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAKAjH,IAAAG,GAAA,KAAAH,IAEAgH,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAKAjH,IAAAG,GAAA,IAAAH,IAEAgH,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,UAWAzC,aAGA+J,MAAA,sBAGAvI,OAAA,KAGAsK,UACAX,KAAA,QACAvB,MAAA,UACAmC,SAAA,EACArN,KAAA,WACA,MAAA,UAAAsN,EAAA5P,GACA,MAAAC,MAAAE,MAAA,GAAAH,EAAA,GAAA,QAMA6P,YACAd,KAAA,QACAvB,MAAA,UACAmC,SAAA,EACArN,KAAA,WACA,MAAA,UAAAsN,EAAA5P,GACA,MAAAC,MAAAE,MAAA,GAAAH,EAAA,GAAA,SAUAX,MAAA6G,SAAA,SAAAzB,GACAA,IACA6I,EAAAtS,EAAA8U,MAAAxC,EAAA7I,KAOApF,KAAA4E,KAAA,WAKA,QAAAG,GAAAK,GAGApF,KAAA0Q,cAAAtL,EACApF,KAAA2Q,QC1VA,MDgWA5L,GAAAG,UAAAyL,MAAA,WAGA3Q,KAAAoF,MAAAzJ,EAAA6O,KAAAyD,GAGAjO,KAAA0Q,eACA/U,EAAA8U,MAAAzQ,KAAAoF,MAAApF,KAAA0Q,gBAOA3L,EAAAG,UAAAY,IAAA,SAAA8K,GAOA,IAAA,GAJAC,GAAAD,EAAAxN,MAAA,KACA0N,EAAA9Q,KAAAoF,MAGA5D,EAAA,EAAAA,EAAAqP,EAAA1O,OAAAX,IAAA,CAGA,GAAA,mBAAAsP,GAAAD,EAAArP,IAEA,MADAmJ,SAAAC,KAAA,gCAAAgG,GACA,IAIAE,GAAAA,EAAAD,EAAArP,IAIA,GAAA,kBAAAsP,GACA,MAAAA,EAIA,IAAAC,KACA,IAAAC,UAAA7O,OAAA,EACA,IAAA,GAAA6I,GAAA,EAAAA,EAAAgG,UAAA7O,OAAA6I,IACA+F,EAAA5G,KAAA6G,UAAAhG,GAKA,OAAA8F,GAAAG,MAAAjR,KAAA+Q,IAMAhM,EAAAG,UAAA2E,IAAA,SAAA+G,EAAA3J,GAOA,IAAA,GAJA4J,GAAAD,EAAAxN,MAAA,KACA0N,EAAA9Q,KAAAoF,MAGA5D,EAAA,EAAAA,EAAAqP,EAAA1O,OAAAX,IAAA,CAGA,GAAAA,EAAA,IAAAqP,EAAA1O,OAAA,CACA2O,EAAAD,EAAArP,IAAAyF,CACA,OAIA,mBAAA6J,GAAAD,EAAArP,MACAsP,EAAAD,EAAArP,QAIAsP,EAAAA,EAAAD,EAAArP,IAIA,MAAAxB,OAOA+E,EAAAG,UAAAgM,gBAAA,SAAA7E,GASA,MALA,mBAAAA,KACAA,EAAArM,KAAA8F,IAAA,mBAIAuG,EAAA,EAAA,IC9bAtH,OAIArJ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAaAD,GAAAE,OAAA,qBACA,OACA,yBACA,yBACA,6BACA,0BACA,2BACA,uCACA,6CAMAkI,SAAA,OAAA,WAKA,GAAAC,IAGAmN,YAAA,EAGAC,YAAA,EACAC,gBAAA,EAGAC,cAAA,EAGAC,YAAA,KAGAC,cAAA,EAMAxR,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,OAAA,aAAA,WAAA,WAAA,eAAA,aAAA,YAAA,mBAAA,uBAAA,SACA6M,EAAA1D,EAAA2D,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,GAUA,QAAAC,KAGAjS,KAAAkS,KAAA1P,QACAxC,KAAAkS,KAAA1P,UAIAxC,KAAAkS,KAAAC,OACAnS,KAAAkS,KAAAC,SAIA,mBAAAnS,MAAAkS,KAAA1P,MAAAzC,QACAC,KAAAkS,KAAA1P,MAAAzC,MAAAC,KAAA0E,OAAAyM,aAEA,mBAAAnR,MAAAkS,KAAA1P,MAAAtC,SACAF,KAAAkS,KAAA1P,MAAAtC,OAAAF,KAAA0E,OAAAyM,aAEA,mBAAAnR,MAAAkS,KAAAC,KAAAC,OACApS,KAAAkS,KAAAC,KAAAC,KAAApS,KAAA0E,OAAA0M,aAEA,mBAAApR,MAAAkS,KAAAC,KAAAE,WACArS,KAAAkS,KAAAC,KAAAE,SAAArS,KAAA0E,OAAA2M,iBAWA,QAAAiB,GAAA9Q,GAGA,MAAA,KAAAxB,KAAAuS,KAAAC,SAAArQ,SAKAX,IAAA5F,IACA4F,EAAAxB,KAAAuS,KAAAE,gBAIAjR,EAAAA,GAAA,EACAA,SACAA,EAAA,KAIAA,GAAAxB,KAAAuS,KAAAC,SAAArQ,SAAAnC,KAAAuS,KAAAC,SAAAhR,MAKAxB,KAAA6Q,KAAA6B,QAAAlR,GAGAxB,KAAAuS,KAAAvS,KAAAuS,KAAAC,SAAAhR,IACA,IAMA,QAAAmR,KAGA,QAAA3S,KAAAuS,KAAA5Q,SAKA3B,KAAA6Q,KAAA+B,UAGA5S,KAAAuS,KAAAvS,KAAAuS,KAAA5Q,QACA,GAMA,QAAAkR,KAGA7S,KAAA6Q,KAAAF,QAGA3Q,KAAAuS,KAAAvS,KAAA8S,KAIA9S,KAAA+S,QAAA/S,KAAAkS,KAAAC,KAAAE,SAAA,EAAAtE,EAAA/Q,EAAA+Q,EAAAjR,GAUA,QAAAkW,KAGA,IAAAhT,KAAAiT,QAAA9Q,SAKAnC,KAAAiT,WACAjT,KAAAiT,QAAA9I,KAAA,GAAAyH,IAGA5R,KAAAkS,KAAA1P,OACAxC,KAAAiT,QAAA,GAAA5P,QAAArD,KAAAkS,KAAA1P,MAAAzC,MAAAC,KAAAkS,KAAA1P,MAAAtC,SAQA,QAAAgT,GAAAC,GASA,MANAA,KACAA,EAAAnT,KAAAsH,SAAAgD,SAIAtK,KAAAiT,QAAA9I,KAAAgJ,GACAA,EAMA,QAAAC,KAGA,MAAA,KAAApT,KAAAiT,QAAA9Q,OACA,KAIAnC,KAAAiT,QAAAI,MAMA,QAAAC,GAAAH,GACAA,IACAnT,KAAAiT,QAAAI,MACArT,KAAAiT,QAAA9I,KAAAgJ,IAWA,QAAAI,KAGAvT,KAAAuS,KAAA5Q,SACA3B,KAAAuS,KAAA5Q,OAAA8Q,eAAAzS,KAAAuS,KAAA5Q,OAAA6Q,SAAArP,QAAAnD,KAAAuS,MAIA,IAAA/Q,GACA2R,EAAAnT,KAAAsH,SAAAgD,OAkBA,IAfAtK,KAAAuS,KAAAiB,WACAxT,KAAAuS,KAAAkB,KAAAC,KACAP,EAAAJ,SAAA/S,KAAAuS,KAAAkB,KAAAnF,OAGAtO,KAAA2T,aAAA3T,KAAAuS,KAAAkB,KAAA1M,EAAA/G,KAAAuS,KAAAkB,KAAAzM,EAAAhH,KAAAuS,KAAAkB,KAAAnF,MAAA6E,IAKAnT,KAAAuS,KAAAqB,MACAT,EAAAJ,QAAA/S,KAAAuS,KAAAqB,MAIA5T,KAAAuS,KAAAsB,MACA,IAAArS,IAAAxB,MAAAuS,KAAAsB,MACA7T,KAAAuS,KAAAsB,MAAAtN,eAAA/E,IACA2R,EAAA3L,OAAAqC,IACA7J,KAAAuS,KAAAsB,MAAArS,GAAAuF,EAAA/G,KAAAuS,KAAAsB,MAAArS,GAAAwF,EAAAhH,KAAAuS,KAAAsB,MAAArS,GAAA8M,MAOA,IAAAtO,KAAAuS,KAAA9K,OACA,IAAAjG,IAAAxB,MAAAuS,KAAA9K,OACAzH,KAAAuS,KAAA9K,OAAAlB,eAAA/E,IACA2R,EAAA1L,OAAAoC,IACA7J,KAAAuS,KAAA9K,OAAAjG,GAAAuF,EAAA/G,KAAAuS,KAAA9K,OAAAjG,GAAAwF,EAAAhH,KAAAuS,KAAA9K,OAAAjG,GAOA0R,GAAAtQ,KAAA5C,KAAAmT,GAUA,QAAAW,GAAAC,EAAArP,GAGA1E,KAAA0E,OAAA/I,EAAAgJ,UAAAX,EAAAU,OAGAsP,OAAAC,eAAAjU,KAAA,YAGA8F,IAAA,WACA,MAAA9F,MAAAiT,QAAAjT,KAAAiT,QAAA9Q,OAAA,IAIA0H,IAAA,SAAAsJ,GACAnT,KAAAiT,QAAAjT,KAAAiT,QAAA9Q,QAAAgR,KAKAY,EACA/T,KAAAkU,KAAAH,GAGA/T,KAAAgF,OC5UA,MDmVA8O,GAAA5O,UAAAF,KAAA,WAGAhF,KAAAkS,QAGAlS,KAAA8S,KAAA,KACA9S,KAAAuS,KAAA,KAGAvS,KAAA6Q,KAAA,GAAAa,GAGA1R,KAAAmU,IAAA,KAGAnU,KAAAiT,YAMAa,EAAA5O,UAAAgP,KAAA,SAAAH,GAGA/T,KAAAgF,MAGA,KACAhF,KAAAoU,SAAAL,GAEA,MAAAM,GAMA,KAHArB,GAAApQ,KAAA5C,MAGA,GAAA+R,GAAAsC,GAIArU,KAAAsU,SAMAR,EAAA5O,UAAAqP,OAAA,WACAvU,KAAAmU,KACAnU,KAAAkU,KAAAlU,KAAAmU,MAOAL,EAAA5O,UAAAsP,SAAA,WACA,MAAA,QAAAxU,KAAA8S,MAUAgB,EAAA5O,UAAAoF,MAAA,WAOA,IAAA,GAJAA,GAAA,GAAAwJ,GACAW,EAAAT,OAAAU,oBAAA1U,MAGA2U,EAAA,EAAAA,EAAAF,EAAAtS,OAAAwS,IACArK,EAAAqK,GAAAhZ,EAAA6O,KAAAxK,KAAA2U,GAIA,OAAArK,IAMAwJ,EAAA5O,UAAAkP,SAAA,SAAAL,GAGA,IAAAA,EACA,KAAAtC,GAAAxV,MAAAK,OAIA,IAAA,gBAAAyX,GAAA,CACA,GAAA5G,GAAA4G,EAAAa,OAAA,EACA,IAAA,MAAAzH,EACA,MAAAnN,MAAA6U,QAAAd,EAEA,IAAA,MAAA5G,GAAA,MAAAA,EACA,MAAAnN,MAAA8U,QAAAf,EAEA,IAAA,OAAA5G,EACA,MAAAnN,MAAA+U,QAAAhB,EAGA,MAAAtC,GAAAxV,MAAAM,aAKA,GAAA,gBAAAwX,GAMA,KAAAtC,GAAAxV,MAAAM,YALAyD,MAAA8U,QAAAf,IAYAD,EAAA5O,UAAA6P,QAAA,SAAAC,GAGA,GAAAb,GAAAtC,EAAAoD,QAAAD,EACA,KAAAb,EACA,KAAA1C,GAAAxV,MAAAQ,WAIAuD,MAAA8U,QAAAX,IAMAL,EAAA5O,UAAA2P,QAAA,SAAAK,GAGA,GAAAf,GAAAtC,EAAAsD,QAAAD,EACA,KAAAf,EACA,KAAA1C,GAAAxV,MAAAO,WAIAwD,MAAA8U,QAAAX,IAMAL,EAAA5O,UAAA4P,QAAA,SAAAX,GAGA,GAAA,gBAAAA,GACA,IACAA,EAAAxY,EAAAyZ,SAAAjB,GAEA,MAAAlY,GACA,KAAAwV,GAAAxV,MAAAS,iBAYA,GAPAf,EAAAyK,QAAA+N,KACAA,GACAkB,KAAAlB,IAKA,gBAAAA,GAAAkB,KACA,GAAA,MAAAlB,EAAAkB,KAAAT,OAAA,GACA,IACAT,EAAAkB,KAAA1Z,EAAAyZ,SAAAjB,EAAAkB,MAEA,MAAApZ,GACA,KAAAwV,GAAAxV,MAAAU,0BAIAwX,GAAAkB,OAKA,KAAA,GAAA7T,KAAA2S,GACAA,EAAA5N,eAAA/E,IAAA,SAAAA,IACAxB,KAAAkS,KAAA1Q,GAAA7F,EAAA6O,KAAA2J,EAAA3S,IAKAyQ,GAAArP,KAAA5C,MAGAA,KAAA8S,KAAA,GAAAnB,GAGAwC,EAAAkB,MACArV,KAAA8S,KAAAgC,QAAAX,EAAAkB,MAIArV,KAAAmU,IAAAA,GAMAL,EAAA5O,UAAAoQ,MAAA,WACA,MAAAzD,GAAA0D,QAAAvV,KAAAwV,UAMA1B,EAAA5O,UAAAsQ,MAAA,SAAAC,GAOA,IAAA,GAJAtB,GAAArC,EAAAqC,MACAM,EAAAT,OAAAU,oBAAA1U,MAGA2U,EAAA,EAAAA,EAAAF,EAAAtS,OAAAwS,IAGA,SAAAA,IAKAR,EAAAQ,GACAR,EAAAQ,GAAAhZ,EAAAgJ,OAAAwP,EAAAQ,GAAA3U,KAAA2U,IAKAR,EAAAQ,GAAAhZ,EAAA6O,KAAAxK,KAAA2U,IAQA,OAHAR,GAAAkB,KAAArV,KAAA8S,KAAA0C,QAGAC,EAAA9Z,EAAA+Z,OAAAvB,GAAAA,GAUAL,EAAA5O,UAAAyQ,QAAA,WACA,MAAA3V,MAAAuS,MAMAuB,EAAA5O,UAAA0Q,SAAA,WAOA,IAJA,GAAArD,GAAAvS,KAAA8S,KACA+C,GAAAtD,GAGAA,GACAA,EAAAA,EAAAuD,SAAAvD,EAAAE,gBACAF,GACAsD,EAAA1L,KAAAoI,EAKA,OAAAsD,IAMA/B,EAAA5O,UAAA6Q,YAAA,SAAAtC,GACA,GAAAoC,GAAA7V,KAAAgW,aAAAvC,EAAAA,EACA,OAAAoC,GAAA1T,OAAA0T,EAAA,GAAA,MAMA/B,EAAA5O,UAAA8Q,aAAA,SAAAC,EAAAC,GAGA,GAAAL,GAAA7V,KAAA4V,UAOA,OAJAK,GAAAA,GAAA,EACAC,EAAAA,GAAAL,EAAA1T,OAGA0T,EAAAM,OAAA,SAAA5D,GACA,GAAAA,EAAAiB,SAAA,CACA,GAAAC,GAAAlB,EAAA6D,eACA,OAAA3C,IAAAwC,GAAAxC,GAAAyC,EAEA,OAAA,KAOApC,EAAA5O,UAAAmR,QAAA,WACA,MAAArW,MAAAuS,KACAvS,KAAAuS,KAAA6D,gBAEA,GAMAtC,EAAA5O,UAAAoR,aAAA,WACA,GAAAC,GAAAvW,KAAAgW,cACA,OAAAO,GAAApU,QAMA2R,EAAA5O,UAAAsR,iBAAA,SAAAzP,EAAAC,GACA,MAAAhH,MAAAuS,KACAvS,KAAAuS,KAAAiE,iBAAAzP,EAAAC,OAQA8M,EAAA5O,UAAAuR,YAAA,WACA,MAAAzW,MAAAsH,UAMAwM,EAAA5O,UAAAwR,QAAA,SAAApM,GACA,MAAAA,GACAtK,KAAA6Q,KAAAvG,QAEAtK,KAAA6Q,MAMAiD,EAAA5O,UAAAyR,UAAA,WACA,MAAA3W,MAAA6Q,KAAAvG,SAMAwJ,EAAA5O,UAAA0R,cAAA,SAAAC,GACA,MAAAnF,GAAAoF,SAAAD,EAAA7W,KAAA8S,OAMAgB,EAAA5O,UAAA6R,QAAA,WACA,GAAA3E,GAAApS,KAAA8F,IAAA,YAAA,EACA,OAAAkR,YAAA5E,IAMA0B,EAAA5O,UAAA+R,QAAA,SAAA7E,GACA,mBAAAA,KACAA,EAAApS,KAAA0E,OAAA0M,aAEApR,KAAAkS,KAAAC,KAAAC,KAAA4E,WAAA5E,IAMA0B,EAAA5O,UAAAgS,QAAA,WACA,MAAAlX,MAAA8F,IAAA,YAAA,KAMAgO,EAAA5O,UAAAiS,UAAA,WACA,MAAAnX,MAAA8F,IAAA,cAAA,KAMAgO,EAAA5O,UAAAkS,QAAA,WAGA,MAAApX,MAAAiT,QAAA9Q,OAKAnC,KAAAsH,SAAA8P,UAJArJ,EAAAjR,GAUAgX,EAAA5O,UAAA6N,QAAA,SAAAzE,GAGAtO,KAAAiT,QAAA9Q,QAKAnC,KAAAsH,SAAAyL,QAAAzE,IAMAwF,EAAA5O,UAAAmS,gBAAA,WAGA,GAAAC,KACAA,GAAAvJ,EAAAjR,GAAA,EACAwa,EAAAvJ,EAAA/Q,GAAA,CAGA,KAAA,GAAAwE,GAAA,EAAAA,EAAAxB,KAAAiT,QAAA9Q,OAAAX,IACA8V,EAAAvJ,EAAAjR,IAAAkD,KAAAiT,QAAAzR,GAAA6V,gBAAAtJ,EAAAjR,GACAwa,EAAAvJ,EAAA/Q,IAAAgD,KAAAiT,QAAAzR,GAAA6V,gBAAAtJ,EAAA/Q,EAIA,OAAAsa,IAMAxD,EAAA5O,UAAAY,IAAA,SAAA8K,EAAA2G,GAGA,GAAA3G,EAAA,CAKA,gBAAAA,KACAA,EAAAA,EAAAxN,MAAA,KAQA,KAAA,GAHAoU,GADApO,EAAApJ,KAAAkS,KAIAyC,EAAA,EAAAA,EAAA/D,EAAAzO,OAAAwS,IAAA,CAMA,GAHA6C,EAAA5G,EAAA+D,GAGAA,EAAA,IAAA/D,EAAAzO,OACA,MAAA,mBAAAiH,GAAAoO,GACAD,EAEAnO,EAAAoO,EAIA,IAAA,gBAAApO,GAAAoO,GAEA,MADA7M,SAAAC,KAAA,qBAAA4M,EAAA,oBACAD,CAIAnO,GAAAA,EAAAoO,MAWA1D,EAAA5O,UAAAgE,UAAA,SAAAnC,EAAAC,GACA,MAAAD,IAAA,GAAAC,GAAA,GAAAD,EAAA/G,KAAAkS,KAAA1P,MAAAzC,OAAAiH,EAAAhH,KAAAkS,KAAA1P,MAAAtC,QAMA4T,EAAA5O,UAAAuS,gBAAA,SAAA1Q,EAAAC,GACA,QAAAhH,KAAAuS,MACAvS,KAAAuS,KAAAkF,gBAAA1Q,EAAAC,IAQA8M,EAAA5O,UAAAwS,oBAAA,SAAAC,GAGA,GAAAC,EAGA,IAAA,OAAA5X,KAAAuR,aAAAvR,KAAAiT,QAAA9Q,OAAA,GAAA,EACAyV,EAAA5X,KAAAiT,QAAA9Q,OAAA,MAIA,CAAA,GAAA,QAAAnC,KAAAuR,YAMA,OAAA,CALAqG,GAAA,EASA,IAAA,GAAApW,GAAAxB,KAAAiT,QAAA9Q,OAAA,EAAAX,GAAAoW,EAAApW,IACA,GAAAmW,EAAAlN,SAAAzK,KAAAiT,QAAAzR,IACA,OAAA,CAKA,QAAA,GAMAsS,EAAA5O,UAAA2S,YAAA,SAAA9Q,EAAAC,EAAAsH,GACA,IAEA,MADAtO,MAAA2T,aAAA5M,EAAAC,EAAAsH,IACA,EAEA,MAAArS,GACA,OAAA,IAQA6X,EAAA5O,UAAAyO,aAAA,SAAA5M,EAAAC,EAAAsH,EAAA6E,GAGA,IAAAnT,KAAAkJ,UAAAnC,EAAAC,GACA,KAAA,IAAAgL,GAAAP,EAAAxV,MAAA6b,wBAAA/Q,EAAAC,EAAAsH,EAIA,IAAAtO,KAAAsH,SAAAE,OAAA1B,IAAAiB,EAAAC,KAAA+G,EAAAlR,MACA,KAAA,IAAAmV,GAAAP,EAAAxV,MAAA8b,4BAAAhR,EAAAC,EAAAsH,EAIAA,GAAAA,GAAAtO,KAAAsH,SAAA8P,UAGAjE,EAAAA,GAAAnT,KAAAsH,SAAAgD,QAGA6I,EAAA3L,OAAAqC,IAAA9C,EAAAC,EAAAsH,EAGA,IAAAgJ,GAAAnE,EAAA6E,gBAAAjR,EAAAC,EAGA,KAAAsQ,IAGAnE,EAAA8E,aAAAlR,EAAAC,GAAA,CAGA,IAAAhH,KAAAwR,aAMA,KAAA,IAAAQ,GAAAP,EAAAxV,MAAAic,qBAAAnR,EAAAC,EAAAsH,EALA6E,GAAAgF,aAAApR,EAAAC,GAWA,GAAAhH,KAAAuR,aAAAvR,KAAA0X,oBAAAvE,GACA,KAAA,IAAAnB,GAAAP,EAAAxV,MAAAmc,uBAAArR,EAAAC,EAAAsH,EAOA,OAHA6E,GAAAJ,SAAAzE,GAGA6E,GAMAW,EAAA5O,UAAAmT,kBAAA,SAAAtR,EAAAC,EAAAsH,EAAAhH,GAGA,IAAAtH,KAAAkJ,UAAAnC,EAAAC,GACA,KAAA,IAAAgL,GAAAP,EAAAxV,MAAA6b,wBAAA/Q,EAAAC,EAAAsH,EAOA,IAHAhH,EAAAE,OAAAqC,IAAA9C,EAAAC,EAAAsH,GAGAA,IAAAP,EAAAlR,MAAA,CAKA,GAAAya,GAAAhQ,EAAA0Q,gBAAAjR,EAAAC,EAGAsQ,IAGAhQ,EAAA2Q,aAAAlR,EAAAC,IACAM,EAAA6Q,aAAApR,EAAAC,KAYA8M,EAAA5O,UAAAoT,SAAA,SAAAvR,EAAAC,EAAAsH,GAGA,IAAAtO,KAAAsH,SAAAE,OAAAwC,GAAAjD,EAAAC,EAAAsH,GAAA,CAKA,GAAAiK,GAAAvY,KAAAsH,SAAAgD,OAMA,IAHAtK,KAAAqY,kBAAAtR,EAAAC,EAAAsH,EAAAiK,GAGA,mBAAAvY,MAAAuS,KAAAsB,MAAA,CAGA,GAAA7T,KAAAuS,KAAAiB,SAAA,CAGAN,EAAAtQ,KAAA5C,KAGA,IAAAuS,GAAA,GAAAZ,GAGAnQ,EAAA+Q,EAAAiG,SAAAxY,KAAAuS,KACAvS,MAAAuS,KAAAA,EAGAvS,KAAA6Q,KAAA6B,QAAAlR,GAIAxB,KAAAuS,KAAAsB,SAIAP,EAAA1Q,KAAA5C,KAAAuY,GAGAvY,KAAAuS,KAAAsB,MAAA1J,KAAAnK,KAAAsH,SAAAE,OAAA1B,IAAAiB,EAAAC,EAAA,YAMA8M,EAAA5O,UAAAuT,UAAA,SAAA1R,EAAAC,EAAAS,GAGA,mBAAAzH,MAAAuS,KAAA9K,SACAzH,KAAAuS,KAAA9K,WAIAzH,KAAAsH,SAAAG,OAAAoC,IAAA9C,EAAAC,EAAAS,GAGAzH,KAAAuS,KAAA9K,OAAA0C,KAAAnK,KAAAsH,SAAAG,OAAA3B,IAAAiB,EAAAC,EAAA,UAMA8M,EAAA5O,UAAAwT,YAAA,SAAA3R,EAAAC,GAGA,GAAA2R,IAAA,CAGA,IAAA,mBAAA3Y,MAAAuS,KAAAsB,MACA,IAAA,GAAArS,GAAA,EAAAA,EAAAxB,KAAAuS,KAAAsB,MAAA1R,OAAAX,IACA,GAAAuF,IAAA/G,KAAAuS,KAAAsB,MAAArS,GAAAuF,GAAAC,IAAAhH,KAAAuS,KAAAsB,MAAArS,GAAAwF,EAAA,CAGAhH,KAAAuS,KAAAsB,MAAA+E,OAAApX,EAAA,GACAxB,KAAAsH,SAAAE,OAAAuC,MAAAhD,EAAAC,GAGA2R,GAAA,CACA,OAMAA,GACA3Y,KAAAsY,SAAAvR,EAAAC,EAAA+G,EAAAlR,QAOAiX,EAAA5O,UAAA2T,aAAA,SAAA9R,EAAAC,GAGA,GAAA,mBAAAhH,MAAAuS,KAAA9K,OACA,IAAA,GAAAjG,GAAA,EAAAA,EAAAxB,KAAAuS,KAAA9K,OAAAtF,OAAAX,IACA,GAAAuF,IAAA/G,KAAAuS,KAAA9K,OAAAjG,GAAAuF,GAAAC,IAAAhH,KAAAuS,KAAA9K,OAAAjG,GAAAwF,EAAA,CACAhH,KAAAuS,KAAA9K,OAAAmR,OAAApX,EAAA,GACAxB,KAAAsH,SAAAG,OAAAsC,MAAAhD,EAAAC,EACA,SASA8M,EAAA5O,UAAA4T,SAAA,SAAA/R,EAAAC,EAAAsH,GACA,MAAA,mBAAAA,GACAtO,KAAAsH,SAAAE,OAAAwC,GAAAjD,EAAAC,EAAAsH,GAEAtO,KAAAsH,SAAAE,OAAAL,IAAAJ,EAAAC,IAMA8M,EAAA5O,UAAA6T,UAAA,SAAAhS,EAAAC,EAAA4I,GACA,MAAA,mBAAAA,GACA5P,KAAAsH,SAAAG,OAAAuC,GAAAjD,EAAAC,EAAA4I,GAEA5P,KAAAsH,SAAAG,OAAAN,IAAAJ,EAAAC,IAMA8M,EAAA5O,UAAA8T,SAAA,SAAAjS,EAAAC,GACA,MAAAhH,MAAAsH,SAAAE,OAAA1B,IAAAiB,EAAAC,IAMA8M,EAAA5O,UAAA+T,UAAA,SAAAlS,EAAAC,GACA,MAAAhH,MAAAsH,SAAAG,OAAA3B,IAAAiB,EAAAC,IAUA8M,EAAA5O,UAAAgU,KAAA,SAAAnS,EAAAC,EAAAsH,GAGAA,EAAAA,GAAAtO,KAAAsH,SAAA8P,SAGA,IAAAjE,GAAAnT,KAAA2T,aAAA5M,EAAAC,EAAAsH,EAGA4E,GAAAtQ,KAAA5C,KAAAmT,EAGA,IAAAZ,GAAA,GAAAZ,IACA8B,MACA1M,EAAAA,EACAC,EAAAA,EACAsH,MAAAA,KAKA9M,EAAA+Q,EAAAiG,SAAAxY,KAAAuS,KAQA,OAPAvS,MAAAuS,KAAAE,eAAAjR,EACAxB,KAAAuS,KAAAA,EAGAvS,KAAA6Q,KAAA6B,QAAAlR,IAGA,GAMAsS,EAAA5O,UAAAwO,KAAA,SAAApF,GAGAA,EAAAA,GAAAtO,KAAAsH,SAAA8P,SAGA,IAAAjE,GAAAnT,KAAAsH,SAAAgD,OACA6I,GAAAJ,SAAAzE,GAGA4E,EAAAtQ,KAAA5C,KAAAmT,EAGA,IAAAZ,GAAA,GAAAZ,IACA8B,MACAC,MAAA,EACApF,MAAAA,KAKA9M,EAAA+Q,EAAAiG,SAAAxY,KAAAuS,KACAvS,MAAAuS,KAAAE,eAAAjR,EACAxB,KAAAuS,KAAAA,EAGAvS,KAAA6Q,KAAA6B,QAAAlR,IAUAsS,EAAA5O,UAAAiU,KAAA,SAAA3X,GAQA,GALA,gBAAAA,KACAA,EAAAxB,KAAAuS,KAAAC,SAAArP,QAAA3B,IAIA8Q,EAAA1P,KAAA5C,KAAAwB,GAGA,IAEA,MADA+R,GAAA3Q,KAAA5C,OACA,EAEA,MAAA/D,GAEA,KADA0W,GAAA/P,KAAA5C,MACA/D,EAKA,OAAA,GAMA6X,EAAA5O,UAAAkU,SAAA,WAGA,QAAAzG,EAAA/P,KAAA5C,QACAoT,EAAAxQ,KAAA5C,OACA,IAUA8T,EAAA5O,UAAAqK,KAAA,WAGA,KAAA+C,EAAA1P,KAAA5C,OAGA,IACAuT,EAAA3Q,KAAA5C,MAEA,MAAA/D,GAEA,KADA0W,GAAA/P,KAAA5C,MACA/D,IAQA6X,EAAA5O,UAAAoP,MAAA,WAGAzB,EAAAjQ,KAAA5C,MAGAgT,EAAApQ,KAAA5C,MACAuT,EAAA3Q,KAAA5C,OAMA8T,EAAA5O,UAAA4O,QAAA,SAAAuF,GAGA,GAAA,OAAArZ,KAAA8S,MAKA,mBAAAuG,GAAA,CAKA,kBAAAA,KACAA,EAAAA,EAAAzW,KAAA5C,MAIA,IAAA6Q,EAGA,IAAA,gBAAAwI,GACAxI,EAAA7Q,KAAA6Q,KAAAvG,QACAuG,EAAAyI,QAAAD,OAIA,IAAA,gBAAAA,GAAA,CAGA,GAAArZ,KAAAuS,KAAAxW,OAAAsd,EACA,MAKA,IADAxI,EAAA7Q,KAAA4W,cAAAyC,GACA,OAAAxI,EACA,WAMAA,GAAAwI,CAIA,KAAArZ,KAAA6Q,KAAAnG,QAAAmG,GAAA,CAKAgC,EAAAjQ,KAAA5C,MAGAgT,EAAApQ,KAAA5C,MACAkT,EAAAtQ,KAAA5C,MACAuT,EAAA3Q,KAAA5C,KAIA,KAAA,GADAmL,GAAA0F,EAAAwF,UACA7U,EAAA,EAAAA,EAAA2J,GAGAmH,EAAA1P,KAAA5C,KAAA6Q,EAAA0I,OAAA/X,IAHAA,IAQA,IACA+R,EAAA3Q,KAAA5C,MAEA,MAAA/D,GAEA,KADA0W,GAAA/P,KAAA5C,MACA/D,MAQA6X,EAAA5O,UAAAsU,SAAA,WAGA,KAAAlH,EAAA1P,KAAA5C,OAAA,CAGA,IACAuT,EAAA3Q,KAAA5C,MAEA,MAAA/D,GAEA,KADA0W,GAAA/P,KAAA5C,MACA/D,EAIA,GAAA+D,KAAAuS,KAAAC,SAAArQ,OAAA,EACA,QAQA2R,EAAA5O,UAAAuU,aAAA,WAGA,KAAA9G,EAAA/P,KAAA5C,QACAoT,EAAAxQ,KAAA5C,QACAA,KAAAuS,KAAAC,SAAArQ,OAAA,QASA2R,EAAA5O,UAAAwU,YAAA,WAGA,KAAApH,EAAA1P,KAAA5C,OAAA,CAGA,IACAuT,EAAA3Q,KAAA5C,MAEA,MAAA/D,GAEA,KADA0W,GAAA/P,KAAA5C,MACA/D,EAIA,GAAA+D,KAAAuS,KAAAoH,cACA,QAQA7F,EAAA5O,UAAA0U,gBAAA,WAGA,KAAAjH,EAAA/P,KAAA5C,QAGAoT,EAAAxQ,KAAA5C,OAGAA,KAAAuS,KAAAoH,mBAaA7F,EAAA5O,UAAAwC,SAAA,WAGA,IAAA1H,KAAAmU,MAAAnU,KAAA6Q,KACA,MAAA,KAIA,IAAAjJ,IACAuM,IAAAnU,KAAAmU,IACAtD,KAAA7Q,KAAA6Q,KAAAvG,QAIA,OAAA1C,IAMAkM,EAAA5O,UAAA4C,aAAA,SAAAF,GAGAA,GAAAA,EAAAuM,KAAAvM,EAAAiJ,OAKA7Q,KAAAkU,KAAAtM,EAAAuM,KACAnU,KAAAA,QAAA4H,EAAAiJ,QCj9CAiD,OAIApY,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAaAD,GAAAE,OAAA,0BACA,SAMAsN,QAAA,YAAA,aAAA,SAAA4E,GAUA,QAAA8L,GAAAC,GACA,OAAAA,EAAAC,WAAA,GAAAC,EAAAF,EAAAC,WAAA,GAAAC,GAMA,QAAAC,GAAAH,EAAAI,GAgBA,MAfAA,GAAAA,MACA,KAAAJ,GAAA,SAAAA,EACAI,EAAAxG,MAAA,GAKA,gBAAAoG,KACAA,EAAAD,EAAAC,IAIAI,EAAAnT,EAAA,EAAA+S,EAAA,GACAI,EAAAlT,EAAA,EAAA8S,EAAA,IAEAI,EAMA,QAAAC,GAAA7L,GACA,MAAAA,KAAAP,EAAAjR,EAAA,IAAAwR,IAAAP,EAAA/Q,EAAA,IAAA,GAMA,QAAAod,GAAA9L,GACA,MAAA,MAAAA,EACAP,EAAAjR,EAEA,MAAAwR,EACAP,EAAA/Q,EAEA+Q,EAAAnR,EAUA,QAAAyd,GAAA5G,GAGA,GAAA6G,GAAA3e,EAAA6O,KAAAiJ,GACAnF,EAAA6L,EAAA1G,EAAAnF,MAGA,OAAA,KAAAA,EACA,MAIAmF,EAAAC,QAAA,EACA4G,EAAAhM,GAAA,OAKAgM,EAAAhM,IAAAmF,EAAA1M,EAAA0M,EAAAzM,SAIAsT,GAAAvT,QACAuT,GAAAtT,QACAsT,GAAAhM,MAGAgM,GAMA,QAAAC,GAAA9G,GAGA,GAAAnF,GAAAwL,CAaA,OAVArG,GAAAzW,GACAsR,EAAA,IACAwL,EAAArG,EAAAzW,GAEAyW,EAAA3W,IACAwR,EAAA,IACAwL,EAAArG,EAAA3W,GAIAgd,EAKAG,EAAAH,GACAxL,MAAA8L,EAAA9L,KALA,KAYA,QAAAkM,GAAA3G,GAGA,GAAArS,GAAA8M,EACAmM,IAGA,KAAAjZ,IAAAqS,GACAA,EAAAtN,eAAA/E,KAGA8M,EAAA6L,EAAAtG,EAAArS,GAAA8M,QAAA,IAGA,mBAAAmM,GAAAnM,KACAmM,EAAAnM,OAIAmM,EAAAnM,GAAAnE,MAAA0J,EAAArS,GAAAuF,EAAA8M,EAAArS,GAAAwF,IAKA,OAAAyT,GAMA,QAAAC,GAAA7G,GAGA,GAAA1G,GAAAqK,EAAAlJ,EACAqM,IAGA,KAAAnD,IAAA3D,GACA,GAAAA,EAAAtN,eAAAiR,GAAA,CAGAlJ,EAAA8L,EAAA5C,EAGA,KAAArK,IAAA0G,GAAA2D,GACA3D,EAAA2D,GAAAjR,eAAA4G,IACAwN,EAAAxQ,KAAA8P,EAAApG,EAAA2D,GAAArK,IACAmB,MAAAA,KAQA,MAAAqM,GAMA,QAAAC,GAAAnT,GAGA,GAAAjG,GAAAoO,EACAiL,IAGA,KAAArZ,IAAAiG,GACAA,EAAAlB,eAAA/E,KAGAoO,EAAAnI,EAAAjG,GAAAoO,KAGA,mBAAAiL,GAAAjL,KACAiL,EAAAjL,OAIA,UAAAA,EACAiL,EAAAjL,GAAAzF,MAAA1C,EAAAjG,GAAAuF,EAAAU,EAAAjG,GAAAwF,EAAAS,EAAAjG,GAAAqO,OAGAgL,EAAAjL,GAAAzF,MAAA1C,EAAAjG,GAAAuF,EAAAU,EAAAjG,GAAAwF,IAMA,OAAA6T,GAMA,QAAAC,GAAArT,GAGA,GAAAhC,GAAAmK,EACAmL,IAGA,KAAAnL,IAAAnI,GACA,GAAAA,EAAAlB,eAAAqJ,GAGA,GAAA,UAAAA,GACA,IAAAnK,EAAA,EAAAA,EAAAgC,EAAAmI,GAAAzN,OAAAsD,IAGA,GAAA9J,EAAAyK,QAAAqB,EAAAmI,GAAAnK,IAAA,CAKA,GAAA,IAAAgC,EAAAmI,GAAAnK,GAAAtD,QAAA,gBAAAsF,GAAAmI,GAAAnK,GAAA,GAAA,CACA,GAAAoK,GAAApI,EAAAmI,GAAAnK,GAAA,EACAgC,GAAAmI,GAAAnK,GAAAoU,EAAApS,EAAAmI,GAAAnK,GAAA,IACAgC,EAAAmI,GAAAnK,GAAA0E,KAAA0F,GAIApI,EAAAmI,GAAAnK,GAAAtD,OAAA,GAKA4Y,EAAA5Q,KAAA8P,EAAAxS,EAAAmI,GAAAnK,IACAmK,KAAAA,EACAC,KAAApI,EAAAmI,GAAAnK,GAAA,WAOA,KAAAA,IAAAgC,GAAAmI,GACAnI,EAAAmI,GAAArJ,eAAAd,IACAsV,EAAA5Q,KAAA8P,EAAAxS,EAAAmI,GAAAnK,IACAmK,KAAAA,IASA,OAAAmL,GAMA,QAAAC,GAAApH,GACA,OAAAA,GACA,IAAA7F,GAAA/Q,EACA,MAAA,GACA,KAAA+Q,GAAAjR,EACA,MAAA,GACA,SACA,MAAA,IAOA,QAAAme,GAAArH,GACA,OAAAA,GACA,IAAA,IACA,MAAA7F,GAAA/Q;AACA,IAAA,IACA,MAAA+Q,GAAAjR,CACA,SACA,MAAAiR,GAAAlR,OAyBA,QAAA8U,GAAAuJ,EAAAvZ,GAOA,GAJA3B,KAAA2B,OAAAA,GAAA,KACA3B,KAAAwS,YAGA0I,EACA,IAAA,GAAA1D,KAAA0D,GACAA,EAAA3U,eAAAiR,KACAxX,KAAAwX,GAAA0D,EAAA1D,IA3UA,GAAAwC,GAAA,IAAAD,WAAA,GA+SAoB,GACA3F,OACA/B,KAAA4G,EACAxG,MAAA2G,EACA/S,OAAAmT,EACAhH,KAAAoH,GAEAlG,SACArB,KAAA8G,EACA1G,MAAA6G,EACAjT,OAAAqT,EACAlH,KAAAqH,GCxVA,ODkXAtJ,GAAAzM,UAAA4Q,SAAA,SAAAtU,GAEA,MADAA,GAAAA,GAAA,EACAxB,KAAAwS,SAAAhR,GACAxB,KAAAwS,SAAAhR,GAEA,MAMAmQ,EAAAzM,UAAAkW,YAAA,WACA,MAAApb,MAAAwS,UAMAb,EAAAzM,UAAAmW,YAAA,WACA,MAAArb,MAAAwS,SAAArQ,OAAA,GAMAwP,EAAAzM,UAAAoW,UAAA,WACA,MAAAtb,MAAA2B,QAMAgQ,EAAAzM,UAAAqW,kBAAA,WAGA,GAAAvb,KAAAwS,SAAArQ,QAAA,EACA,OAAA,CAKA,KAAA,GADAqZ,GAAA,EACAha,EAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IAQA,GALAxB,KAAAwS,SAAAhR,GAAAgS,UACAgI,IAIAA,EAAA,EACA,OAAA,CAKA,QAAA,GAMA7J,EAAAzM,UAAAuW,kBAAA,WAGA,GAAA,IAAAzb,KAAAwS,SAAArQ,OACA,OAAA,CAOA,KAAA,GAHAqZ,MAGAha,EAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IAGAxB,KAAAwS,SAAAhR,GAAAgS,UACAgI,EAAArR,KAAAnK,KAAAwS,SAAAhR,GAKA,OAAAga,IAMA7J,EAAAzM,UAAAsR,iBAAA,SAAAzP,EAAAC,GAGA,IAAA,GAAAxF,GAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IACA,GAAAxB,KAAAwS,SAAAhR,GAAAiS,MAAAzT,KAAAwS,SAAAhR,GAAAiS,KAAA1M,IAAAA,GAAA/G,KAAAwS,SAAAhR,GAAAiS,KAAAzM,IAAAA,EACA,MAAAxF,EAKA,WAMAmQ,EAAAzM,UAAAuS,gBAAA,SAAA1Q,EAAAC,GAGA,IAAA,GAAAxF,GAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IACA,GAAAxB,KAAAwS,SAAAhR,GAAAiS,MAAAzT,KAAAwS,SAAAhR,GAAAiS,KAAA1M,IAAAA,GAAA/G,KAAAwS,SAAAhR,GAAAiS,KAAAzM,IAAAA,EACA,OAAA,CAKA,QAAA,GAMA2K,EAAAzM,UAAAyU,YAAA,WACA,MAAA3Z,MAAA0b,UAAA1b,KAAA0b,SAAAvZ,OAAA,GAMAwP,EAAAzM,UAAAsO,OAAA,WACA,QAAAxT,KAAAyT,MAMA9B,EAAAzM,UAAAkR,cAAA,WAGA,MAAApW,MAAAwT,SACAxT,KAAA2B,OACA3B,KAAA2B,OAAAyU,gBAAA,EAEA,EAIApW,KAAA2B,OACA3B,KAAA2B,OAAAyU,gBAIA,GAUAzE,EAAAzM,UAAAgC,OAAA,WAGA,GAAAlH,KAAA2B,OAAA,CAKA,GAAAH,GAAAxB,KAAA2B,OAAA6Q,SAAArP,QAAAnD,KACAwB,SACAxB,KAAA2B,OAAA6Q,SAAAoG,OAAApX,EAAA,GAIAxB,KAAA2B,OAAA,OAMAgQ,EAAAzM,UAAAyW,OAAA,WAGA,GAAA3b,KAAA2B,OAAA,CAKA,GAAAH,GAAAxB,KAAA2B,OAAA6Q,SAAArP,QAAAnD,KACA,IAAAwB,EAAA,EAAA,CACA,GAAAoa,GAAA5b,KAAA2B,OAAA6Q,SAAAhR,EAAA,EACAxB,MAAA2B,OAAA6Q,SAAAhR,EAAA,GAAAxB,KACAA,KAAA2B,OAAA6Q,SAAAhR,GAAAoa,KAOAjK,EAAAzM,UAAA2W,SAAA,WAGA,GAAA7b,KAAA2B,OAAA,CAKA,GAAAH,GAAAxB,KAAA2B,OAAA6Q,SAAArP,QAAAnD,KACA,IAAAwB,QAAAA,EAAAxB,KAAA2B,OAAA6Q,SAAArQ,OAAA,EAAA,CACA,GAAAyZ,GAAA5b,KAAA2B,OAAA6Q,SAAAhR,EAAA,EACAxB,MAAA2B,OAAA6Q,SAAAhR,EAAA,GAAAxB,KACAA,KAAA2B,OAAA6Q,SAAAhR,GAAAoa,KAOAjK,EAAAzM,UAAAsT,SAAA,SAAAjG,GAQA,MALAvS,MAAAkH,SAGAlH,KAAA2B,OAAA4Q,EACAA,EAAAC,SAAArI,KAAAnK,MACAuS,EAAAC,SAAArQ,OAAA,GAMAwP,EAAAzM,UAAA9E,YAAA,SAAAmS,GAGA,MAFAA,GAAA5Q,OAAA3B,KACAA,KAAAwS,SAAArI,KAAAoI,GACAvS,KAAAwS,SAAArQ,OAAA,GAMAwP,EAAAzM,UAAA4W,WAAA,SAAAvJ,GAGA,IAAA,GAAA/Q,GAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IACAxB,KAAAwS,SAAAhR,GAAAG,OAAA4Q,CAIAA,GAAAC,SAAAD,EAAAC,SAAAnH,OAAArL,KAAAwS,UACAD,EAAA5Q,OAAA3B,KAGAA,KAAAwS,UAAAD,IAUAZ,EAAAzM,UAAA4P,QAAA,SAAAX,EAAA4H,GAGA,GAAA,mBAAA5H,GAAAkB,KACA,MAAA1D,GAAAmD,QAAAX,EAAAkB,KAAA0G,EAIA,IAAAC,GAAA1J,EAAA9Q,EAAA4J,CAMA,KAHA2Q,EAAAA,GAAA/b,KAGAwB,EAAA,EAAAA,EAAA2S,EAAAhS,OAAAX,IAAA,CAGA,GAAA7F,EAAAyK,QAAA+N,EAAA3S,IAGA,IAAA4J,EAAA,EAAAA,EAAA+I,EAAA3S,GAAAW,OAAAiJ,IAGA4Q,EAAA,GAAArK,GACAqK,EAAAlH,QAAAX,EAAA3S,GAAA4J,IAGA2Q,EAAA3b,YAAA4b,OAKA,CAGA,GAAAd,GAAAlH,OAAAU,oBAAAP,EAAA3S,GAGA,KAAA,GAAAgW,KAAA0D,GACA,GAAAA,EAAA3U,eAAAiR,GAAA,CACA,GAAA1G,GAAAoK,EAAA1D,EAGA,oBAAA2D,GAAArG,QAAAhE,GACAiL,EAAAjL,GAAAqK,EAAArG,QAAAhE,GAAAqD,EAAA3S,GAAAsP,IAEA,gBAAAqD,GAAA3S,GAAAsP,GACAiL,EAAAjL,GAAAnV,EAAA6O,KAAA2J,EAAA3S,GAAAsP,IAGAiL,EAAAjL,GAAAqD,EAAA3S,GAAAsP,IASAtP,EAAA,EAAA2S,EAAAhS,SAAAxG,EAAAyK,QAAA+N,EAAA3S,EAAA,MACA8Q,EAAA,GAAAX,GACAoK,EAAA3b,YAAAkS,GACAyJ,EAAAzJ,KAQAX,EAAAzM,UAAAsQ,MAAA,SAAAyG,GAGAA,EAAAA,KAGA,IAAA1J,MACA2I,EAAAlH,OAAAU,oBAAA1U,KAGA,KAAA,GAAAwX,KAAA0D,GACA,GAAAA,EAAA3U,eAAAiR,GAAA,CACA,GAAA1G,GAAAoK,EAAA1D,EAGA,IAAA,WAAA1G,GAAA,aAAAA,EACA,QAIA,oBAAAqK,GAAA3F,MAAA1E,GACAyB,EAAAzB,GAAAqK,EAAA3F,MAAA1E,GAAA9Q,KAAA8Q,IAEA,gBAAA9Q,MAAA8Q,GACAyB,EAAAzB,GAAAnV,EAAA6O,KAAAxK,KAAA8Q,IAGAyB,EAAAzB,GAAA9Q,KAAA8Q,GASA,GAHAmL,EAAA9R,KAAAoI,GAGAvS,KAAAwS,SAAArQ,OAAA,EAAA,CAGA,GAAA+Z,KACAD,GAAA9R,KAAA+R,EAGA,KAAA,GAAA1a,GAAA,EAAAA,EAAAxB,KAAAwS,SAAArQ,OAAAX,IAAA,CAGA,GAAA2a,KACAD,GAAA/R,KAAAgS,GAGAnc,KAAAwS,SAAAhR,GAAAgU,MAAA2G,QAKA,KAAAnc,KAAAwS,SAAArQ,QACAnC,KAAAwS,SAAA,GAAAgD,MAAAyG,EAIA,OAAAA,IC1vBAtK,MAGAjW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,0BACA,SAMAsN,QAAA,WAAA,WAKA,QAAAuI,KACA1R,KAAA2Q,QAkIA,QAAAyL,GAAA7J,EAAAsE,EAAAhG,GAGA,GAAA0B,EAAAxW,MAAAwW,EAAAxW,OAAA8a,EACA,OAAA,CAIA,KAAA,GAAArV,GAAA,EAAAA,EAAA+Q,EAAAC,SAAArQ,OAAAX,IAAA,CAMA,GAHAqP,EAAA6B,QAAAlR,GAGA4a,EAAA7J,EAAAC,SAAAhR,GAAAqV,EAAAhG,GACA,OAAA,CAIAA,GAAA+B,UAIA,OAAA,ECpLA,MDiCAlB,GAAAxM,UAAAyL,MAAA,WAIA,MAHA3Q,MAAAyT,KAAA,EACAzT,KAAA6Q,QACA7Q,KAAAqc,SAAA,EACArc,MAMA0R,EAAAxM,UAAAwN,QAAA,SAAAlR,GAUA,MAPAA,GAAA,IACAxB,KAAA6Q,KAAA7Q,KAAAyT,MAAA,EACAzT,KAAAqc,YAIArc,KAAAyT,OACAzT,MAMA0R,EAAAxM,UAAA0N,QAAA,WAGA,GAAA,IAAA5S,KAAAyT,KAYA,MAPAzT,MAAA6Q,KAAA7Q,KAAAyT,cACAzT,MAAA6Q,KAAA7Q,KAAAyT,MACAzT,KAAAqc,YAIArc,KAAAyT,OACAzT,MAMA0R,EAAAxM,UAAAoU,QAAA,SAAAgD,GAGA,GAAAA,EAAAtc,KAAAyT,KACA,IAAA,GAAAjS,KAAAxB,MAAA6Q,KACArP,EAAA8a,UACAtc,MAAA6Q,KAAArP,GACAxB,KAAAqc,WAOA,OADArc,MAAAyT,KAAA6I,EACAtc,MAMA0R,EAAAxM,UAAAmR,QAAA,WACA,MAAArW,MAAAyT,MAMA/B,EAAAxM,UAAAqU,OAAA,SAAA+C,GACA,MAAA,mBAAAtc,MAAA6Q,KAAAyL,GAAA,EAAAtc,KAAA6Q,KAAAyL,IAMA5K,EAAAxM,UAAAwF,QAAA,SAAA6R,GAGA,GAAAA,GAAA,gBAAAA,IAAA,mBAAAA,GAAA9I,KAAA,CAKA,GAAAzT,KAAAyT,OAAA8I,EAAA9I,MAAAzT,KAAAqc,WAAAE,EAAAF,SACA,OAAA,CAIA,KAAA,GAAA7a,KAAAxB,MAAA6Q,KACA,GAAA,mBAAA0L,GAAA1L,KAAArP,IAAAxB,KAAA6Q,KAAArP,KAAA+a,EAAA1L,KAAArP,GACA,OAAA,CAKA,QAAA,IAMAkQ,EAAAxM,UAAAoF,MAAA,WAGA,GAAAkS,GAAA,GAAA9K,EAQA,OALA8K,GAAA/I,KAAAzT,KAAAyT,KACA+I,EAAAH,SAAArc,KAAAqc,SACAG,EAAA3L,KAAAlV,EAAA6O,KAAAxK,KAAA6Q,MAGA2L,GAmCA9K,EAAAoF,SAAA,SAAAD,EAAA4F,GAGA,GAAA5L,GAAA,GAAAa,EAGA,OAAA0K,GAAAK,EAAA5F,EAAAhG,GACAA,EAIA,MCrMAa,KAGAhW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,8BACA,OACA,4BAMAsN,QAAA,gBAAA,aAAA,YAAA,SAAA4E,EAAApE,GAKA,QAAAiI,GAAA7R,EAAAG,GAGAF,KAAA/D,MAAA,EACA+D,KAAAD,MAAA,EACAC,KAAAE,OAAA,EACAF,KAAAwH,OAAA,GAAAmC,GACA3J,KAAAyH,OAAA,GAAAkC,GACA3J,KAAA4T,KAAA7F,EAAAjR,EAGAkD,KAAAsX,YACAtX,KAAAsX,SAAAvJ,EAAAjR,MACAkD,KAAAsX,SAAAvJ,EAAA/Q,MAGAgD,KAAAwH,OAAAqD,UAAAkD,EAAAlR,QAGAkD,GAAAG,IACAF,KAAAqD,QAAAtD,EAAAG,GClDA,MDyDA0R,GAAA1M,UAAA7B,QAAA,SAAAtD,EAAAG,GAGAH,EAAAA,GAAAG,GAAA,EACAA,EAAAA,GAAAH,GAAA,EAGAC,KAAAD,MAAAyG,SAAAzG,GACAC,KAAAE,OAAAsG,SAAAtG,GAGAF,KAAAwH,OAAAnE,QAAAtD,EAAAG,GACAF,KAAAyH,OAAApE,QAAAtD,EAAAG,GAGAF,KAAAqK,SAMAuH,EAAA1M,UAAAmF,MAAA,WACArK,KAAAwH,OAAA6C,QACArK,KAAAyH,OAAA4C,SAMAuH,EAAA1M,UAAAwX,SAAA,SAAA3V,EAAAC,EAAAsH,GACAtO,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAAsH,IAMAsD,EAAA1M,UAAAyX,UAAA,SAAA5V,EAAAC,EAAAS,GACAzH,KAAAyH,OAAAoC,IAAA9C,EAAAC,EAAAS,IAUAmK,EAAA1M,UAAA+S,aAAA,SAAAlR,EAAAC,EAAA4V,EAAAC,GAGA,IAAA7c,KAAAwH,OAAAsC,SAAA/C,EAAAC,GACA,OAAA,CAIA6V,GAAAA,GAAA,GAAAlT,GAAA3J,KAAAD,MAAAC,KAAAE,OAGA,IAAAoO,GAAAtO,KAAAwH,OAAA1B,IAAAiB,EAAAC,EAMA,OAHA4V,GAAAA,GAAAtO,EAGAuO,EAAA/W,IAAAiB,EAAAC,MAAA,GAAAsH,KAAAsO,IAKAtO,IAAAP,EAAAlR,QAKAggB,EAAAhT,IAAA9C,EAAAC,GAAA,GAIAhH,KAAAiY,aAAAlR,EAAAC,EAAA,EAAA4V,EAAAC,IACA7c,KAAAiY,aAAAlR,EAAAC,EAAA,EAAA4V,EAAAC,IACA7c,KAAAiY,aAAAlR,EAAA,EAAAC,EAAA4V,EAAAC,IACA7c,KAAAiY,aAAAlR,EAAA,EAAAC,EAAA4V,EAAAC,MAMAjL,EAAA1M,UAAA8S,gBAAA,SAAAjR,EAAAC,EAAA8V,GAGA,IAAA9c,KAAAwH,OAAAsC,SAAA/C,EAAAC,GACA,OAAA,CAOA,IAHA8V,EAAAA,GAAA9c,KAAAwH,OAAA1B,IAAAiB,EAAAC,GAGA8V,IAAA/O,EAAAlR,MACA,OAAA,CAIA,IAAAkgB,IAAA,CAiBA,OAdA/c,MAAAgd,WAAAjW,EAAAC,EAAA,GAAA8V,GAAA,KACAC,GAAA,GAEA/c,KAAAgd,WAAAjW,EAAAC,EAAA,GAAA8V,GAAA,KACAC,GAAA,GAEA/c,KAAAgd,WAAAjW,EAAA,EAAAC,GAAA8V,GAAA,KACAC,GAAA,GAEA/c,KAAAgd,WAAAjW,EAAA,EAAAC,GAAA8V,GAAA,KACAC,GAAA,GAIAA,GAMAnL,EAAA1M,UAAA8X,WAAA,SAAAjW,EAAAC,EAAAiW,EAAAC,GAGA,QAAAld,KAAAwH,OAAAsC,SAAA/C,EAAAC,KAKAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,KAAA+G,EAAAlR,QAKAogB,EAAAA,GAAAjd,KAAAwH,OAAA1B,IAAAiB,EAAAC,GAGAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,KAAAiW,KAKAjd,KAAAiY,aAAAlR,EAAAC,EAAAiW,KAKAC,GACAld,KAAAmY,aAAApR,EAAAC,EAAAiW,IAIA,OAMArL,EAAA1M,UAAAiT,aAAA,SAAApR,EAAAC,EAAAiW,GAGA,QAAAjd,KAAAwH,OAAAsC,SAAA/C,EAAAC,KAKAiW,EAAAA,GAAAjd,KAAAwH,OAAA1B,IAAAiB,EAAAC,GAGAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,KAAAiW,IAKAjd,KAAAmd,aAAApW,EAAAC,GAGAhH,KAAAmY,aAAApR,EAAAC,EAAA,EAAAiW,GACAjd,KAAAmY,aAAApR,EAAAC,EAAA,EAAAiW,GACAjd,KAAAmY,aAAApR,EAAA,EAAAC,EAAAiW,GACAjd,KAAAmY,aAAApR,EAAA,EAAAC,EAAAiW,IAGA,KAMArL,EAAA1M,UAAAiY,aAAA,SAAApW,EAAAC,GAGA,GAAAhH,KAAAwH,OAAAsC,SAAA/C,EAAAC,GAAA,CAKA,GAAAsH,GAAAtO,KAAAwH,OAAA1B,IAAAiB,EAAAC,EAGAsH,KAAAP,EAAAlR,QAKAmD,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAA+G,EAAAlR,OACAmD,KAAAsX,SAAAhJ,GAAAnE,MAAApD,EAAAA,EAAAC,EAAAA,OAMA4K,EAAA1M,UAAAkY,YAAA,SAAA9O,EAAAgJ,GACAtX,KAAAsX,SAAAhJ,GAAAgJ,GAMA1F,EAAA1M,UAAAmY,YAAA,SAAA/O,GACA,MAAAtO,MAAAsX,SAAAhJ,QAMAsD,EAAA1M,UAAAmS,gBAAA,SAAA/I,GACA,MAAAtO,MAAAsX,UAAAhJ,GAAAnM,QAUAyP,EAAA1M,UAAA6N,QAAA,SAAAzE,GACAtO,KAAA4T,KAAAtF,GAMAsD,EAAA1M,UAAAkS,QAAA,WACA,MAAApX,MAAA4T,MAMAhC,EAAA1M,UAAAoY,WAAA,WACAtd,KAAA4T,MAAA5T,KAAA4T,MAUAhC,EAAA1M,UAAAoF,MAAA,WAGA,GAAA6I,GAAA,GAAAvB,EAUA,OAPAuB,GAAAS,KAAA5T,KAAA4T,KACAT,EAAApT,MAAAC,KAAAD,MACAoT,EAAAjT,OAAAF,KAAAE,OACAiT,EAAA3L,OAAAxH,KAAAwH,OAAA8C,QACA6I,EAAA1L,OAAA,GAAAkC,GAAA3J,KAAAD,MAAAC,KAAAE,QAGAiT,GAMAvB,EAAA1M,UAAAuF,SAAA,SAAA0I,GAGA,MAAAnT,MAAAD,QAAAoT,EAAApT,OAAAC,KAAAE,SAAAiT,EAAAjT,QAKAF,KAAAwH,OAAAiD,SAAA0I,EAAA3L,SC/VAoK,MAGAlW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,2BACA,SAMAsN,QAAA,aAAA,aAAA,SAAA4E,GAKA,QAAAwP,KACA,MAAA/W,UAAAxG,KAAAwH,QAAAhB,SAAAxG,KAAAwd,WACAhX,SAAAxG,KAAAsX,UAAA9Q,SAAAxG,KAAAoS,MAMA,QAAAqL,KAGA,GAAAC,GAAA1d,IAGAA,MAAA2d,SACA3d,KAAA4d,SAGA5d,KAAA2Q,QAGA3Q,KAAA2d,MAAAE,MAAA,WACA,MAAAN,GAAA3a,KAAA8a,EAAAC,QAEA3d,KAAA4d,MAAAC,MAAA,WACA,MAAAN,GAAA3a,KAAA8a,EAAAE,QCnDA,MD0DAH,GAAAvY,UAAAyL,MAAA,WAMA,IAAA,GAHA8D,IAAA,SAAA,YAAA,WAAA,QAGAjT,EAAA,EAAAA,EAAAiT,EAAAtS,OAAAX,IACAxB,KAAA2d,MAAAlJ,EAAAjT,IAAA,EACAxB,KAAA4d,MAAAnJ,EAAAjT,IAAA,GAOAic,EAAAvY,UAAA4Y,OAAA,WAGA,GAAA7S,GAAAjL,KAAA2d,MAAAE,QACAE,EAAA/d,KAAA4d,MAAAC,OAGA,OAAAE,GAAA9S,EACA8C,EAAA/Q,EAEAiO,EAAA8S,EACAhQ,EAAAjR,EAEAiR,EAAAnR,GCtFA6gB,MAGA/hB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,4BACA,OACA,0BACA,4BAMAsN,QAAA,cAAA,YAAA,aAAA,YAAA,SAAAsU,EAAA1P,EAAApE,GAiBA,QAAAqU,GAAAjX,EAAAC,EAAAiX,EAAAC,GAGA,GAAAC,GAAAne,KAAAwH,OAAA1B,IAAAiB,EAAAC,GACAoX,EAAApe,KAAAmS,KAAA7K,SAAAE,OAAA1B,IAAAiB,EAAAC,EAGAhH,MAAAwH,OAAAsC,SAAA/C,EAAAC,IAAAmX,IAAAF,GAAAE,IAAAD,IAMA,EAAAE,IAAAH,EACAje,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAAoX,GAKApe,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAAiX,GAIAD,EAAApb,KAAA5C,KAAA+G,EAAA,EAAAC,EAAAiX,EAAAC,GACAF,EAAApb,KAAA5C,KAAA+G,EAAAC,EAAA,EAAAiX,EAAAC,GACAF,EAAApb,KAAA5C,KAAA+G,EAAA,EAAAC,EAAAiX,EAAAC,GACAF,EAAApb,KAAA5C,KAAA+G,EAAAC,EAAA,EAAAiX,EAAAC,IAMA,QAAAG,GAAAtX,EAAAC,GAGA,GAAAoX,GAAApe,KAAAmS,KAAA7K,SAAAE,OAAA1B,IAAAiB,EAAAC,EAGAhH,MAAAwH,OAAAsC,SAAA/C,EAAAC,IAAAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,KAAAoX,IAKApe,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAAoX,GAGAC,EAAAzb,KAAA5C,KAAA+G,EAAA,EAAAC,GACAqX,EAAAzb,KAAA5C,KAAA+G,EAAAC,EAAA,GACAqX,EAAAzb,KAAA5C,KAAA+G,EAAA,EAAAC,GACAqX,EAAAzb,KAAA5C,KAAA+G,EAAAC,EAAA,IAMA,QAAAsX,KAOA,IAJA,GACAC,GAAAC,EAAAC,EAAAxT,EAAA8S,EAAA/S,EAAAjE,EAAAC,EADA0X,GAAA,EAIAA,GAMA,IAHAA,GAAA,EAGA3X,EAAA,EAAAA,EAAA/G,KAAAwH,OAAAzH,MAAAgH,IACA,IAAAC,EAAA,EAAAA,EAAAhH,KAAAwH,OAAAtH,OAAA8G,IAMA,GAHAuX,EAAAve,KAAAwH,OAAA1B,IAAAiB,EAAAC,GAIAuX,IAAAI,EAAAC,SACAL,IAAAI,EAAAE,iBACAN,IAAAI,EAAAG,gBACA,CAcA,IAXAL,GACAze,KAAAwH,OAAA1B,IAAAiB,EAAA,EAAAC,GACAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,EAAA,GACAhH,KAAAwH,OAAA1B,IAAAiB,EAAA,EAAAC,GACAhH,KAAAwH,OAAA1B,IAAAiB,EAAAC,EAAA,IAIAiE,EAAA8S,GAAA,EAGA/S,EAAA,EAAAA,EAAA,EAAAA,IAEAyT,EAAAzT,KAAA2T,EAAAI,aACAN,EAAAzT,KAAA2T,EAAAE,gBAEA5T,GAAA,EAGAwT,EAAAzT,KAAA2T,EAAAK,aACAP,EAAAzT,KAAA2T,EAAAG,gBAEAf,GAAA,EAEAU,EAAAzT,KAAA2T,EAAAM,UACAhU,EAAA8S,GAAA,EAMAS,GADAvT,GAAA8S,EACAY,EAAAM,QAEAhU,EACA0T,EAAAE,kBAEAd,GACAY,EAAAG,gBAOAN,KAAA,GAAAA,IAAAD,IACAG,GAAA,EACA1e,KAAAwH,OAAAqC,IAAA9C,EAAAC,EAAAwX,KA5IA,GAAAG,IACAC,QAAA7Q,EAAAlR,MACAkiB,YAAAhR,EAAAjR,EACAkiB,YAAAjR,EAAA/Q,EACA6hB,gBAAA,EAAA9Q,EAAAjR,EACAgiB,gBAAA,EAAA/Q,EAAA/Q,EACAiiB,QAAA,EAAAlR,EAAAjR,GAiJAoiB,GAGA/M,KAAA,KAGAgN,MAAA,KAGA3X,OAAA,KACA8P,SAAA,KACAlH,OAAA,KAKA8D,KAAA,SAAA/B,GAGAnS,KAAAmf,MAAA,GAAA1B,GAGAzd,KAAAmS,KAAAA,EAGAnS,KAAAwH,OAAAxH,KAAAmS,KAAA7K,SAAAE,OAAA8C,QAGAtK,KAAAsX,SAAA,GAAA3N,GAAA3J,KAAAwH,OAAAzH,MAAAC,KAAAwH,OAAAtH,OAAAF,KAAAwH,OAAAoC,YACA5J,KAAAoQ,OAAA,GAAAzG,GAAA3J,KAAAwH,OAAAzH,MAAAC,KAAAwH,OAAAtH,OAAAF,KAAAwH,OAAAoC,aAMAwV,SAAA,WACA,MAAApf,MAAAmf,OAMAE,UAAA,WACA,MAAArf,MAAAoQ,QAMAiN,YAAA,WACA,MAAArd,MAAAsX,UAMAgI,UAAA,WAGA,IAAAtf,KAAAmS,KAEA,WADAxH,SAAAC,KAAA,wDAKA5K,MAAAoQ,OAAA/F,QACArK,KAAAsX,SAAAjN,QAGAiU,EAAA1b,KAAA5C,KAGA,IAAAoS,GAAApS,KAAAmS,KAAArM,IAAA,aACAwR,EAAAtX,KAAAmS,KAAAkF,iBAGArX,MAAAmf,MAAAxO,QAGA3Q,KAAAmf,MAAAxB,MAAArG,SAAAA,EAAAvJ,EAAAjR,GACAkD,KAAAmf,MAAAvB,MAAAtG,SAAAA,EAAAvJ,EAAA/Q,GACAgD,KAAAmf,MAAAxB,MAAAvL,KAAAA,EAAA,EAAAA,EAAA,EACApS,KAAAmf,MAAAvB,MAAAxL,KAAAA,EAAA,EAAAA,EAAA,CAGA,IAAArL,GAAAC,EAAAY,EAAA0G,CAGA,KAAAvH,EAAA,EAAAA,EAAA/G,KAAAwH,OAAAzH,MAAAgH,IACA,IAAAC,EAAA,EAAAA,EAAAhH,KAAAwH,OAAAtH,OAAA8G,IAGAY,EAAA5H,KAAAwH,OAAA1B,IAAAiB,EAAAC,GACAsH,EAAAtO,KAAAmS,KAAA7K,SAAAE,OAAA1B,IAAAiB,EAAAC,GAGAY,IAAA+W,EAAAI,aAAAzQ,IAAAP,EAAAjR,EAMA8K,IAAA+W,EAAAK,aAAA1Q,IAAAP,EAAA/Q,EAMA4K,IAAA+W,EAAAE,gBAaAjX,IAAA+W,EAAAG,kBACA9e,KAAAmf,MAAAvB,MAAAJ,YACAxd,KAAAoQ,OAAAvG,IAAA9C,EAAAC,EAAA+G,EAAA/Q,GAGAsR,IAAAP,EAAAjR,IACAkD,KAAAmf,MAAAvB,MAAAtG,WACAtX,KAAAsX,SAAAzN,IAAA9C,EAAAC,EAAA+G,EAAAjR,MAnBAkD,KAAAmf,MAAAxB,MAAAH,YACAxd,KAAAoQ,OAAAvG,IAAA9C,EAAAC,EAAA+G,EAAAjR,GAGAwR,IAAAP,EAAA/Q,IACAgD,KAAAmf,MAAAxB,MAAArG,WACAtX,KAAAsX,SAAAzN,IAAA9C,EAAAC,EAAA+G,EAAA/Q,KAZAgD,KAAAmf,MAAAvB,MAAApW,SANAxH,KAAAmf,MAAAxB,MAAAnW,UA0CA6H,KAAA,SAAAtI,EAAAC,GAGA,GAAAsH,GAAAtO,KAAAmS,KAAA7K,SAAAE,OAAA1B,IAAAiB,EAAAC,GACAY,EAAA5H,KAAAwH,OAAA1B,IAAAiB,EAAAC,EAGAsH,KAAAP,EAAA/Q,EAGA4K,IAAA+W,EAAAK,YACAhB,EAAApb,KAAA5C,KAAA+G,EAAAC,EAAA2X,EAAAE,gBAAAF,EAAAI,aAKAV,EAAAzb,KAAA5C,KAAA+G,EAAAC,GAKAsH,IAAAP,EAAAjR,IAGA8K,IAAA+W,EAAAI,YACAf,EAAApb,KAAA5C,KAAA+G,EAAAC,EAAA2X,EAAAG,gBAAAH,EAAAK,aAKAX,EAAAzb,KAAA5C,KAAA+G,EAAAC,KC7VA,OAAAkY,OAGAxjB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,wCACA,SAMAsN,QAAA,oBAAA,OAAA,SAAAsI,GAKA,QAAAM,GAAAwN,GAQA,OALAvf,KAAAuf,KAAAA,EACAvf,KAAAjE,KAAA,mBACAiE,KAAAwf,QAAA,iBAGAD,GACA,IAAA9N,GAAAxV,MAAAK,QACA0D,KAAAwf,SAAA,qBACA,MACA,KAAA/N,GAAAxV,MAAAM,aACAyD,KAAAwf,SAAA,sBACA,MACA,KAAA/N,GAAAxV,MAAAQ,YACAuD,KAAAwf,SAAA,2BACA,MACA,KAAA/N,GAAAxV,MAAAO,YACAwD,KAAAwf,SAAA,2BACA,MACA,KAAA/N,GAAAxV,MAAAS,iBACAsD,KAAAwf,SAAA,2BACA,MACA,KAAA/N,GAAAxV,MAAAU,sBACAqD,KAAAwf,SAAA,oCACA,MACA,SACAxf,KAAAwf,SAAA,6BCtDA,MD6DAzN,GAAA7M,UAAA,GAAAua,OACA1N,EAAA7M,UAAAwa,YAAA3N,EC9DAA,MAGArW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,4CACA,SAMAsN,QAAA,wBAAA,OAAA,aAAA,SAAAsI,EAAA1D,GAKA,QAAAiE,GAAAuN,EAAAxY,EAAAC,EAAAsH,GAcA,OAXAtO,KAAAuf,KAAAA,EACAvf,KAAAjE,KAAA,uBACAiE,KAAAwf,QAAA,6BAGA,mBAAAzY,IAAA,mBAAAC,IAAA,mBAAAsH,KACAtO,KAAAwf,SAAA,uBAAAlR,IAAAP,EAAA/Q,EAAA,QAAA,SACA,cAAA+J,EAAA,KAAAC,EAAA,KAIAuY,GACA,IAAA9N,GAAAxV,MAAA6b,wBACA9X,KAAAwf,SAAA,+CACA,MACA,KAAA/N,GAAAxV,MAAA8b,4BACA/X,KAAAwf,SAAA,sDACA,MACA,KAAA/N,GAAAxV,MAAAic,qBACAlY,KAAAwf,SAAA,8BACA,MACA,KAAA/N,GAAAxV,MAAAmc,uBACApY,KAAAwf,SAAA,sCACA,MACA,SACAxf,KAAAwf,SAAA,KCtDA,MD6DAxN,GAAA9M,UAAA,GAAAua,OACAzN,EAAA9M,UAAAwa,YAAA1N,EC9DAA,MAGAtW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,2BACA,SAMAsN,QAAA,aAAA,OAAA,SAAAsI,GAKA,GAAAkO,IACAC,QACAC,YAAApO,EAAA1V,KAAA,KAAA0V,EAAAzV,QACAA,QAAA,EACA8jB,QAAA,SAEA3N,MACAvC,KAAA,KACAmQ,UAEAzR,MAAA,QACAvS,KAAA,UAGAuS,MAAA,QACAvS,KAAA,WAIAyG,OACAzC,MAAA,GACAG,OAAA,IAEAmV,SAMA2K,GACAC,GAAAxO,EAAA1V,KAAA,IAAA0V,EAAAzV,QACAkkB,GAAA,QACAC,GAAA,IACAC,GAAA,IACAC,GAAA,KACAC,GAAA,QACAC,GAAA,SAMAzO,GAKAqC,IAAA,SAAAqM,GAGA,GAAAC,GAAA9kB,EAAA6O,KAAAmV,EAGA,IAAAa,EACA,IAAA,GAAA7L,KAAA6L,GACAA,EAAAja,eAAAoO,KACA8L,EAAA9L,GAAAhZ,EAAAgJ,OAAA8b,EAAA9L,OAAA6L,EAAA7L,IAMA,OAAA8L,IAMAvL,IAAA,SAAAsL,GAGA,GAAAC,GAAA9kB,EAAA6O,KAAAwV,EAGA,IAAAQ,EACA,IAAA,GAAA7L,KAAA6L,GACAA,EAAAja,eAAAoO,KACA8L,EAAA9L,GAAA6L,EAAA7L,GAMA,OAAA8L,IC7GA,OAAA3O,OAGApW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,4BACA,OACA,oCACA,oCACA,sCAQAC,SAAA,cAGAmkB,GAAA,qBACAC,GAAA,iBACAQ,GAAA,mBACAC,GAAA,gBACAC,GAAA,qBACAC,GAAA,mBAGAT,GAAA,YACAU,GAAA,YACAC,GAAA,YACAC,GAAA,gBACAC,GAAA,cACAC,GAAA,aACAC,GAAA,iBACAC,GAAA,qBACAC,GAAA,aACAC,GAAA,gBACAC,GAAA,aACAC,GAAA,aACAC,GAAA,eACAC,GAAA,eAGApB,GAAA,OACAC,GAAA,OACAoB,GAAA,OACAC,GAAA,OACAC,GAAA,OACAC,GAAA,OAGAC,EAAA,OACAC,EAAA,WACAC,GAAA,SACAC,GAAA,WACAC,GAAA,SACAC,GAAA,OACAC,GAAA,SACAC,GAAA,UAMAxmB,SAAA,YACAymB,EAAA,KACAC,EAAA,UACAC,EAAA,QACAC,EAAA,QACAC,EAAA,aACAC,EAAA,gBACAC,EAAA,UAMA1Z,QAAA,cAAA,UAAA,UAAA,UAAA,SAAA2Z,EAAAC,EAAAC,GAKA,GAAAnR,IAKAoD,QAAA,SAAAD,EAAAiO,GACA,MAAAH,GAAAI,MAAAlO,EAAAiO,IAMA9N,QAAA,SAAAD,EAAA+N,GACA,MAAAF,GAAAG,MAAAhO,EAAA+N,IAMA1N,QAAA,SAAApB,GACA,MAAA6O,GAAAE,MAAA/O,ICjHA,OAAAtC,OAGAnW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAIAD,GAAAE,OAAA,yBACA,yBAMAsD,UAAA,UAAA,SAAA,SAAAyE,GACA,OACAzC,SAAA,IAKAgiB,YAAA,SAAA,SAAAC,GAGAA,EAAAxf,SACAwf,EAAAxf,OAAAA,KAOAvC,KAAA,SAAAf,EAAAgB,EAAAC,GAGAqC,EAAA9B,YAAAR,GAGAC,EAAAyB,SAAA,OAAA,SAAAqgB,GACAzf,EAAA0f,WAAAD,KAEA9hB,EAAAyB,SAAA,OAAA,SAAAugB,GACA3f,EAAA4f,WAAAD,KAIAhiB,EAAAyB,SAAA,kBAAA,SAAAM,GACAM,EAAA6f,mBAAA,SAAAngB,KAEA/B,EAAAyB,SAAA,gBAAA,SAAAM,GACAM,EAAA8f,oBAAA,SAAApgB,KAEA/B,EAAAyB,SAAA,iBAAA,SAAAM,GACAM,EAAA+f,kBAAArgB,WCpDA5H,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,uBACA,OACA,wBACA,kCACA,qBACA,oBACA,6BAMAkI,SAAA,UAAA,cAAA,cAAA,cAAA,SAAA6f,EAAAC,EAAA7V,GAKA,GAAAhK,IAGAqf,KAAAO,EAAAhmB,OACA2lB,KAAAM,EAAA7lB,KAGA8lB,qBAAA,EACAC,uBAAA,EAGAC,eAAAhW,EAAAxQ,KAIAymB,iBAAA,EACAC,mBAAA,EACAC,mBAAA,EAMAnkB,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,aAAA,YAAA,OAAA,aAAA,QAAA,cAAA,SAAAC,EAAAuf,EAAAtQ,EAAAoL,EAAA7f,EAAAwkB,GAKA,QAAAQ,GAAAC,EAAAC,GAGA,IAAAvkB,KAAAwC,QAAA+hB,EAGA,MAFAD,GAAAvd,UACAud,EAAAtd,KAKA,IAAAD,GAAA,EACAC,EAAA,CAGA,oBAAAud,GAAAxV,QACAhI,EAAAwd,EAAAxV,QAGAwV,EAAAC,eAAA,mBAAAD,GAAAC,cAAAzV,QAEAhI,EAAAwd,EAAAC,cAAAzV,QAGAwV,EAAAC,eAAA,mBAAAD,GAAAC,cAAAC,SAEA1d,EAAAwd,EAAAC,cAAAC,QAIA,mBAAAF,GAAAtV,QACAjI,EAAAud,EAAAtV,QAGAsV,EAAAC,eAAA,mBAAAD,GAAAC,cAAAvV,QAEAjI,EAAAud,EAAAC,cAAAvV,QAGAsV,EAAAC,eAAA,mBAAAD,GAAAC,cAAAE,SAEA1d,EAAAud,EAAAC,cAAAE,QAIA3d,GAAArL,EAAAwF,kBAAA,EACA8F,GAAAtL,EAAAwF,kBAAA,EAGAojB,EAAAvd,EAAA/G,KAAAwC,MAAAsG,SAAA/B,GACAud,EAAAtd,EAAAhH,KAAAwC,MAAAwG,SAAAhC,GAGAud,EAAAI,OACAL,EAAAK,KAAAJ,EAAAI,MAOA,GAAA/gB,IAGAc,UAGAlC,MAAA,KACA2P,KAAA,KAGAyS,SACAC,SAGAxB,KAAA,GACAE,KAAA,GAGA1S,KAAA,KAKA7L,KAAA,WAGAhF,KAAAwC,MAAA,KACAxC,KAAAmS,KAAA,GAAA2B,GAGA9T,KAAA6Q,KAAA,KAGA7Q,KAAAqjB,KAAA,GACArjB,KAAAujB,KAAA,GAGAvjB,KAAA8jB,qBAAA,EACA9jB,KAAA+jB,uBAAA,EAGA/jB,KAAAgkB,eAAA,GAGAhkB,KAAAikB,iBAAA,EACAjkB,KAAAkkB,mBAAA,EACAlkB,KAAAmkB,mBAAA,EAGAnkB,KAAA8kB,kBAAA,KACA9kB,KAAA+kB,gBAAA,KAGA/kB,KAAAiF,eAMAnD,YAAA,SAAAR,GAGAtB,KAAAsB,QAAAA,EAGAtB,KAAAglB,qBAAA,UAAAZ,GAGApkB,KAAAglB,qBAAA,SACAhlB,KAAAglB,qBAAA,aACAhlB,KAAAglB,qBAAA,WACAhlB,KAAAglB,qBAAA,aACAhlB,KAAAglB,qBAAA,YACAhlB,KAAAglB,qBAAA,cACAhlB,KAAAglB,qBAAA,UAUA/f,YAAA,SAAAP,GAGA1E,KAAA0E,OAAA/I,EAAAgJ,UAAAX,EAAAU,OAGA1E,KAAAsjB,WAAAtjB,KAAA0E,OAAA2e,MACArjB,KAAAwjB,WAAAxjB,KAAA0E,OAAA6e,MACAvjB,KAAAilB,uBAAAjlB,KAAA0E,OAAAof,qBACA9jB,KAAAklB,yBAAAllB,KAAA0E,OAAAqf,uBACA/jB,KAAA2jB,kBAAA3jB,KAAA0E,OAAAsf,gBACAhkB,KAAAyjB,mBACAzjB,KAAA0E,OAAAuf,gBACAjkB,KAAA0E,OAAAwf,kBACAlkB,KAAA0E,OAAAyf,kBAIA,KAAA,GAAAd,KAAArjB,MAAA4kB,MACA5kB,KAAA4kB,MAAAvB,GAAApe,aACAjF,KAAA4kB,MAAAvB,GAAApe,YAAArC,KAAA5C,KAAAA,KAAA0E,SAQAugB,uBAAA,SAAAE,GACAA,IAAAnlB,KAAA8jB,sBACA9jB,KAAA8jB,oBAAAqB,EACAnlB,KAAAolB,UAAA,gBAAA,yBAOAF,yBAAA,SAAAG,GACAA,IAAArlB,KAAA+jB,wBACA/jB,KAAA+jB,sBAAAsB,EACArlB,KAAAolB,UAAA,gBAAA,2BAOAzB,kBAAA,SAAAK,GACAA,IAAAhkB,KAAAgkB,iBACAhkB,KAAAgkB,eAAAA,EACAhkB,KAAAolB,UAAA,gBAAA,oBAOA3B,mBAAA,SAAAQ,EAAAC,EAAAC,GAGA,GAAAzF,IAAA,CAGAuF,KAAAjkB,KAAAikB,kBACAjkB,KAAAikB,gBAAAA,EACAvF,GAAA,GAKA,mBAAAwF,IAAAA,IAAAlkB,KAAAkkB,oBAEAlkB,KAAAkkB,kBAAAA,EACAxF,GAAA,GAKA,mBAAAyF,IAAAA,IAAAnkB,KAAAmkB,oBAEAnkB,KAAAmkB,kBAAAA,EACAzF,GAAA,GAIAA,GACA1e,KAAAolB,UAAA,gBAAA,oBAWAE,aAAA,SAAAjC,EAAAkC,GAGAvlB,KAAA4kB,MAAAvB,GAAAkC,EAGAvlB,KAAA4kB,MAAAvB,GAAApe,aACAjF,KAAA4kB,MAAAvB,GAAApe,YAAArC,KAAA5C,KAAAA,KAAA0E,QAIA1E,KAAAqjB,OAAAA,IACArjB,KAAAsjB,WAAAtjB,KAAAqjB,MAAA,GACArjB,KAAAwjB,WAAAxjB,KAAAujB,MAAA,KAOAiC,SAAA,SAAAX,GACA7kB,KAAA6kB,MAAAA,IAAAhB,EAAA9lB,OAMA0nB,QAAA,SAAApC,GACA,QAAArjB,KAAA4kB,MAAAvB,IAMAqC,QAAA,SAAAnC,GACA,MAAAvjB,MAAA6kB,MAAA1hB,QAAAogB,SAMAD,WAAA,SAAAD,EAAAsC,GAGA,SAAAA,GAAAtC,GAAArjB,KAAAqjB,OAAAA,KAKArjB,KAAAqjB,MACArjB,KAAAolB,UAAA,WAAAplB,KAAAqjB,MAIArjB,KAAAqjB,KAAAA,EACArjB,KAAA6kB,SACA7kB,KAAAujB,KAAAM,EAAA9lB,KAGAiC,KAAAolB,UAAA,YAAAplB,KAAAqjB,OACA,IAMAG,WAAA,SAAAD,EAAAoC,GAGA,SAAAA,GAAApC,GAAAvjB,KAAAujB,OAAAA,OAKAvjB,KAAAqjB,OAAArjB,KAAA4kB,MAAA5kB,KAAAqjB,OAAArjB,KAAA6kB,MAAA1hB,QAAAogB,WAKAvjB,KAAAujB,KAAAA,EACAvjB,KAAAolB,UAAA,aAAAplB,KAAAujB,OACA,KAMAqC,UAAA,WAGA5lB,KAAA6lB,aACAxC,KAAArjB,KAAAqjB,KACAE,KAAAvjB,KAAAujB,KACAuB,kBAAA9kB,KAAA8kB,kBACAC,gBAAA/kB,KAAA+kB,iBAIA/kB,KAAA8lB,iBAMAhe,aAAA,WAGA9H,KAAA6lB,cAKA7lB,KAAAsjB,WAAAtjB,KAAA6lB,YAAAxC,MACArjB,KAAAwjB,WAAAxjB,KAAA6lB,YAAAtC,MACAvjB,KAAA8kB,kBAAA9kB,KAAA6lB,YAAAf,kBACA9kB,KAAA+kB,gBAAA/kB,KAAA6lB,YAAAd,gBAGA/kB,KAAA+lB,qBAUA7R,KAAA,SAAAH,EAAAiS,GAGA,IACAhmB,KAAAmS,KAAA+B,KAAAH,GAEA,MAAA9X,GACA,KAAAA,GAsBA,MAlBA+D,MAAA6Q,KAAA,MAGAmV,GAAA,mBAAAA,KACAhmB,KAAAiF,YAAAjF,KAAAmS,KAAArM,IAAA,aAIA9F,KAAAolB,UAAA,aAAAplB,KAAAmS,MAGAnS,KAAAwC,QACAxC,KAAAwC,MAAA2C,YACAnF,KAAAwC,MAAAyC,YAAAjF,KAAAmS,KAAArM,IAAA,UACA9F,KAAAimB,oBAIA,GAMA1R,OAAA,WAGAvU,KAAAmS,MAAAnS,KAAAmS,KAAAqC,aAKAxU,KAAAmS,KAAAoC,SAGAvU,KAAAwC,QACAxC,KAAAwC,MAAA2C,YACAnF,KAAAimB,qBAOAH,cAAA,WACA9lB,KAAAmS,MAAAnS,KAAAmS,KAAAqC,aACAxU,KAAAkmB,UAAAlmB,KAAAmS,KAAAzK,aAOAqe,iBAAA,WAGA/lB,KAAAmS,MAAAnS,KAAAkmB,YAKAlmB,KAAAmS,KAAArK,aAAA9H,KAAAkmB,WAGAlmB,KAAAwC,QACAxC,KAAAwC,MAAA2C,YACAnF,KAAAimB,qBAWA9M,KAAA,SAAA3X,GACAxB,KAAAmS,MAAAnS,KAAAmS,KAAAI,OAAAvS,KAAA+kB,kBACA/kB,KAAAmS,KAAAgH,KAAA3X,GACAxB,KAAAimB,oBAOA7M,SAAA,WACApZ,KAAAmS,MAAAnS,KAAAmS,KAAAI,OAAAvS,KAAA8kB,oBACA9kB,KAAAmS,KAAAiH,WACApZ,KAAAimB,oBAOA1W,KAAA,WACAvP,KAAAmS,OACAnS,KAAAmS,KAAA5C,OACAvP,KAAAimB,oBAOA3R,MAAA,WACAtU,KAAAmS,OACAnS,KAAAmS,KAAAmC,QACAtU,KAAAimB,oBAOAE,OAAA,SAAA9M,GACArZ,KAAAmS,MAAAkH,IACArZ,KAAAmS,KAAAnS,QAAAqZ,GACArZ,KAAAimB,oBAOAxM,aAAA,WACAzZ,KAAAmS,OACAnS,KAAAmS,KAAAsH,eACAzZ,KAAAimB,oBAOAzM,SAAA,WACAxZ,KAAAmS,OACAnS,KAAAmS,KAAAqH,WACAxZ,KAAAimB,oBAOAvM,YAAA,WACA1Z,KAAAmS,MAAAnS,KAAAmS,KAAAI,OAAAvS,KAAA+kB,kBACA/kB,KAAAmS,KAAAuH,cACA1Z,KAAAimB,oBAOArM,gBAAA,WACA5Z,KAAAmS,MAAAnS,KAAAmS,KAAAI,OAAAvS,KAAA8kB,oBACA9kB,KAAAmS,KAAAyH,kBACA5Z,KAAAimB,oBAOAG,aAAA,SAAAC,GAGArmB,KAAAmS,MAAAnS,KAAAmS,KAAAI,OAKA8T,EACArmB,KAAA+kB,gBAAA/kB,KAAAmS,KAAAI,KAGAvS,KAAA8kB,kBAAA9kB,KAAAmS,KAAAI,OAOA0T,gBAAA,WAGA,GAAAjmB,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAAA,CAKA,GAAAjC,GAAAvS,KAAAmS,KAAAwD,UACA9E,EAAA7Q,KAAAmS,KAAAuE,UACApP,EAAAtH,KAAAmS,KAAAsE,cACAlP,GAAAsJ,EAAAnG,QAAA1K,KAAA6Q,KAGA7Q,MAAAsmB,YAAA/T,EAAAjL,EAAAC,GAGAA,IAGAvH,KAAA6Q,KAAAA,EAAAvG,QACAtK,KAAAolB,UAAA,aAAA7S,GAGAA,EAAAxW,MACAiE,KAAAolB,UAAA,eAAA7S,EAAAxW,KAAAwW,IAKAA,EAAAkB,MAAAlB,EAAAkB,KAAAC,MACA1T,KAAAolB,UAAA,aAAA7S,KAOAgU,gBAAA,SAAAtQ,EAAAC,GAGA,GAAAlW,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAAA,CAKAyB,EAAAA,GAAA,EACAC,EAAAA,GAAAlW,KAAAmS,KAAAkE,SAGA,IAAAR,GAAA7V,KAAAmS,KAAA6D,aAAAC,EAAAC,GACAzC,EAAAwC,CAGAta,GAAA6qB,QAAA3Q,EAAA,SAAAtD,GACAvS,KAAAwC,MAAAsE,IAAA,SAAAyL,EAAAkB,KAAA1M,EAAAwL,EAAAkB,KAAAzM,GACA4I,KAAA5B,EAAAzQ,MACAsS,KAAA4D,OAEAzT,MAGAA,KAAAwC,MAAAsB,OAAA,YAUA2iB,QAAA,WACAzmB,KAAAmS,KAAA,GAAA2B,GACA9T,KAAAimB,mBAMAS,UAAA,WAGAxH,EAAAI,WAGA,IAAAH,GAAAD,EAAAE,WACAhP,EAAA8O,EAAAG,YACA/H,EAAA4H,EAAA7B,aAGArd,MAAAwC,MAAAM,OAAA2E,OAAAtC,YACAnF,KAAAwC,MAAAM,OAAAqc,MAAA/X,OAAAgJ,EAAAkH,GAGAtX,KAAAolB,UAAA,kBAAAjG,IAUAwH,SAAA,WACA,MAAA3mB,MAAAwC,OAMAqB,SAAA,SAAAxE,GAGAW,KAAAwC,MAAAnD,EAGAW,KAAAwC,OACAxC,KAAAolB,UAAA,aAAAplB,KAAAwC,OAIAxC,KAAAmS,MAAAnS,KAAAmS,KAAAqC,aACAxU,KAAAwC,MAAA2C,YACAnF,KAAAwC,MAAAyC,YAAAjF,KAAAmS,KAAArM,IAAA,UACA9F,KAAAimB,oBAOAK,YAAA,SAAA/T,EAAAjL,EAAAC,GAGAvH,KAAAwC,QAKAxC,KAAAwC,MAAA6E,eAAAC,EAAAC,GAGAvH,KAAAgkB,gBAAAzR,EAAAkB,OAAAlB,EAAAkB,KAAAC,MACA1T,KAAAwC,MAAAsE,IAAA,SAAAyL,EAAAkB,KAAA1M,EAAAwL,EAAAkB,KAAAzM,EAAAhH,KAAAgkB,gBAIAhkB,KAAAolB,UAAA,cAAA7S,KAUAyS,qBAAA,SAAA/iB,EAAAX,GAGA,mBAAAA,IAAAA,EAAAiB,KACAjB,EAAAtB,KAAAsB,SAKAA,EAAAslB,IAAA3kB,GACAX,EAAAiB,GAAAN,EAAAjC,KAAAolB,UAAAyB,KAAA7mB,KAAAiC,KAMAM,GAAA,SAAAqN,EAAAkX,EAAAzD,EAAAD,GAGA,GAAA,kBAAA0D,GAEA,WADAnc,SAAAC,KAAA,8BAAAkc,EAKAzD,IAAAA,EAAA1f,UACAyf,EAAAC,EACAA,EAAA,GAIA,EAAA,GAAAzT,EAAAzM,QAAA,UAAA,CASA,GAAAua,GAAA1d,KACAM,EAAA8iB,GAAAve,CAGA,OAAAvE,GAAA0B,IAAA,eAAA4N,EAAA,WAGA,KAAAyT,IAEA,gBAAAA,IAAAA,IAAA3F,EAAA2F,MACAA,EAAAlgB,QAAAua,EAAA2F,aAOA,YAAAzT,GAAAwU,EAAA,GAAA2C,cAAA,WAAA,CAUA,GALA,UAAAnX,GAAA,UAAAA,GAAA,UAAAA,EAAAhK,OAAA,EAAA,IACAye,EAAAzhB,KAAA8a,EAAA1M,UAAA,GAAAA,UAAA,IAIA0M,EAAAsJ,mBAAA,UAAApX,EAEA,kBADA8N,GAAAsJ,iBAGA,eAAApX,IACA8N,EAAAsJ,mBAAA,GAIAF,EAAA7V,MAAAyM,EAAA1M,cA3CA,IAAA,GADAxC,GAAAoB,EAAAxM,MAAA,KACA6jB,EAAA,EAAAA,EAAAzY,EAAArM,OAAA8kB,IACAjnB,KAAAuC,GAAAiM,EAAAyY,GAAAH,EAAAzD,EAAAD,KAiDAgC,UAAA,SAAAxV,EAAAmB,GAGAnB,IAKA/K,EAAAqiB,QAMAriB,EAAA5D,WAAA,eAAA2O,EAAAmB,GALAlM,EAAAsiB,OAAA,WACAtiB,EAAA5D,WAAA,eAAA2O,EAAAmB,OCz3BA,ODm4BAnN,GAAAoB,OCn4BApB,QAIAlI,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,sCACA,OACA,2BACA,0CAMAsN,QAAA,aAAA,aAAA,cAAA,SAAAoC,EAAA6b,GAKA,QAAAC,GAAA5e,EAAAI,EAAAye,EAAAC,GAGA,KAAA9e,EAAAzI,KAAAwC,MAAAwD,KAAAiC,OAAAQ,EAAAzI,KAAAwC,MAAAwD,KAAAkC,QAGAW,EAAA7I,KAAAwC,MAAAwD,KAAAmC,MAAAU,EAAA7I,KAAAwC,MAAAwD,KAAAoC,MAAA,CAKA,GAAArB,GAAA/G,KAAAwC,MAAAgG,QAAAC,GACAzB,EAAAhH,KAAAwC,MAAAoG,QAAAC,EAGA7I,MAAAN,QAAA6M,YACAvM,KAAAN,QAAA8nB,UAAAD,EACAvnB,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAAsgB,EAAA,EAAA,EAAA1mB,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,QAMA,QAAAC,GAAAnlB,EAAA9C,GAGAM,KAAAuE,aAAA,EAGAgH,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GC3DA,MDiEA/D,GAAAgJ,OAAAgjB,EAAAziB,UAAAqG,EAAArG,WAKAyiB,EAAAziB,UAAAe,eAAA,SAAAS,GACA1G,KAAAuE,YAAAmC,GAUAihB,EAAAziB,UAAAyC,OAAA,WACA,MAAA,OAMAggB,EAAAziB,UAAAkC,OAAA,aAOAugB,EAAAziB,UAAAC,UAAA,aAWAwiB,EAAAziB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAAA,CAKA,GAAA+b,GAAA5nB,KAAAwC,MAAA6C,cACAwiB,EAAA7nB,KAAAwC,MAAA8C,cAGA3E,EAAAX,KAAAwC,MAAA+F,cACA8D,EAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,iBAAAnF,GACA2O,EAAAtP,KAAAwC,MAAA4C,MAAAU,IAAA,gBACAqG,EAAAnM,KAAAwC,MAAA4C,MAAAU,IAAA,kBACAwhB,EAAAtnB,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAnF,GACA4mB,EAAAvnB,KAAAwC,MAAA4C,MAAAU,IAAA,mBACAgiB,EAAA9nB,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAA9F,KAAAwC,MAAAzC,MAAAC,KAAAwC,MAAAtC,QACAgR,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,EAGArM,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAA4P,QAAAA,EACAtP,KAAAN,QAAAyM,YAAAA,CAGA,IAAA3K,GAAAuF,EAAAC,CAGA,KAAAxF,EAAAxB,KAAAwC,MAAAwD,KAAAiC,MAAAzG,GAAAxB,KAAAwC,MAAAwD,KAAAkC,OAAA1G,IACAuF,EAAA/G,KAAAwC,MAAAgG,QAAAhH,GACAxB,KAAAN,QAAAiO,OAAA5G,EAAA8gB,GACA7nB,KAAAN,QAAAsoB,OAAAjhB,EAAA8gB,EAAA7nB,KAAAwC,MAAAgD,eAIA,KAAAhE,EAAAxB,KAAAwC,MAAAwD,KAAAmC,KAAA3G,GAAAxB,KAAAwC,MAAAwD,KAAAoC,KAAA5G,IACAwF,EAAAhH,KAAAwC,MAAAoG,QAAApH,GACAxB,KAAAN,QAAAiO,OAAAia,EAAA5gB,GACAhH,KAAAN,QAAAsoB,OAAAJ,EAAA5nB,KAAAwC,MAAA+C,cAAAyB,EAOA,KAHAhH,KAAAN,QAAAmO,SAGArM,EAAA,EAAAA,EAAAsmB,EAAA3lB,OAAAX,IACA6lB,EAAAzkB,KAAA5C,KAAA8nB,EAAAtmB,GAAAuF,EAAA+gB,EAAAtmB,GAAAwF,EAAAsgB,EAAAC,EAIAvnB,MAAAN,QAAAqoB,WAAA7W,GAAAA,GAGAlR,KAAAuE,aACA6iB,EAAApf,KAAApF,KAAA5C,QAOA2nB,EAAAziB,UAAAsG,UAAA,SAAA/C,EAAAI,GAGA,GAAA9B,GAAA/G,KAAAwC,MAAAgG,QAAAC,GACAzB,EAAAhH,KAAAwC,MAAAoG,QAAAC,GACAQ,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAGAgD,EAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA6H,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,EAGArM,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA6J,UAAAxC,EAAAuC,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAAA,GAGAtJ,KAAAN,QAAAqoB,WAAA7W,GAAAA,IAMAyW,EAAAziB,UAAAwG,WAAA,SAAAjD,EAAAI,GAGA,GAAA9B,GAAA/G,KAAAwC,MAAAgG,QAAAC,GACAzB,EAAAhH,KAAAwC,MAAAoG,QAAAC,GACAQ,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAGAgD,EAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA8C,EAAAnM,KAAAwC,MAAA4C,MAAAU,IAAA,kBACAwhB,EAAAtnB,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,GACAke,EAAAvnB,KAAAwC,MAAA4C,MAAAU,IAAA,mBACAoL,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,GACAyb,EAAA9nB,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAA9F,KAAAwC,MAAAzC,MAAAC,KAAAwC,MAAAtC,QAGAyM,EAAA,IAAAlE,EAAA1B,EAAAA,EAAAuC,EACA0D,EAAAvE,IAAAzI,KAAAwC,MAAAzC,MAAA,EAAAgH,EAAAA,EAAAuC,EACAwD,EAAA,IAAAjE,EAAA7B,EAAAA,EAAAsC,EACA2D,EAAApE,IAAA7I,KAAAwC,MAAAtC,OAAA,EAAA8G,EAAAA,EAAAsC,CAGAtJ,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAAyM,YAAAA,EAGAnM,KAAAN,QAAAiO,OAAAhB,EAAA3F,GACAhH,KAAAN,QAAAsoB,OAAAhb,EAAAhG,GACAhH,KAAAN,QAAAiO,OAAA5G,EAAA+F,GACA9M,KAAAN,QAAAsoB,OAAAjhB,EAAAkG,GACAjN,KAAAN,QAAAmO,QAGA,KAAA,GAAArM,KAAAsmB,GACAA,EAAAtmB,GAAAuF,IAAA0B,GAAAqf,EAAAtmB,GAAAwF,IAAA6B,GACAwe,EAAAzkB,KAAA5C,KAAAyI,EAAAI,EAAAye,EAAAC,EAKAvnB,MAAAN,QAAAqoB,WAAA7W,GAAAA,ICnPAyW,MAGAjsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,uCACA,OACA,2BACA,mCACA,yCAMAsN,QAAA,cAAA,aAAA,SAAA,aAAA,SAAAoC,EAAA0c,EAAAC,GAKA,QAAAC,GAAA3lB,EAAA9C,GAGAM,KAAAooB,WAGA7c,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GC/BA,MDqCA/D,GAAAgJ,OAAAwjB,EAAAjjB,UAAAqG,EAAArG,WAKAijB,EAAAjjB,UAAA4B,IAAA,SAAAC,EAAAC,EAAAqhB,GAGA,GAAAroB,KAAAgG,KAAA8D,SAAA/C,EAAAC,GAAA,CAcA,GATAhH,KAAAkH,OAAAH,EAAAC,GAGAqhB,EAAAC,QACAvhB,EAAAA,EACAC,EAAAA,GAIA,WAAAqhB,EAAAzY,KACAyY,EAAAE,YAAAL,EACAG,EAAAC,OAAAha,MAAA+Z,EAAAphB,UAIA,CAAA,GAAA,WAAAohB,EAAAzY,KAaA,WADAjF,SAAAC,KAAA,qBAAAyd,EAAAzY,KAXAyY,GAAAE,YAAAN,EACA,gBAAAI,GAAAphB,MACAohB,EAAAC,OAAA3sB,EAAAgJ,OAAA0jB,EAAAC,OAAAD,EAAAphB,OAGAohB,EAAAC,OAAA1Y,KAAAyY,EAAAphB,MAWAjH,KAAAwC,MAAA2E,IAAAkhB,EAAAzY,KAAA7I,EAAAC,KACAhH,KAAAooB,QAAAje,MACApD,EAAAA,EACAC,EAAAA,EACAvF,MAAA4mB,EAAAzY,KACA3I,MAAAjH,KAAAwC,MAAAsD,IAAAuiB,EAAAzY,KAAA7I,EAAAC,KAEAhH,KAAAwC,MAAA0E,OAAAmhB,EAAAzY,KAAA7I,EAAAC,IAIAhH,KAAAgG,KAAA6D,IAAA9C,EAAAC,EAAAqhB,GAGAA,EAAAE,aAAAF,EAAAE,YAAAvgB,MACAqgB,EAAAE,YAAAvgB,KAAApF,KAAA5C,KAAAqoB,EAAAC,UAOAH,EAAAjjB,UAAAgC,OAAA,SAAAH,EAAAC,GAGA,GAAAhH,KAAAgG,KAAAmB,IAAAJ,EAAAC,GAAA,CAKA,GAAAqhB,GAAAroB,KAAAgG,KAAAF,IAAAiB,EAAAC,EACAqhB,GAAAE,aAAAF,EAAAE,YAAAxgB,OACAsgB,EAAAE,YAAAxgB,MAAAnF,KAAA5C,KAAAqoB,EAAAC,OAIA,KAAA,GAAA9mB,GAAA,EAAAA,EAAAxB,KAAAooB,QAAAjmB,OAAAX,IACAxB,KAAAooB,QAAA5mB,GAAAuF,IAAAA,GAAA/G,KAAAooB,QAAA5mB,GAAAwF,IAAAA,IACAhH,KAAAwC,MAAAsE,IACA9G,KAAAooB,QAAA5mB,GAAAC,MAAAzB,KAAAooB,QAAA5mB,GAAAuF,EAAA/G,KAAAooB,QAAA5mB,GAAAwF,EAAAhH,KAAAooB,QAAA5mB,GAAAyF,OAEAjH,KAAAooB,QAAAxP,OAAApX,EAAA,MAQA2mB,EAAAjjB,UAAAC,UAAA,WAGA,IAAAnF,KAAAgG,KAAA6B,UAAA,CAKA,GAAArG,GACA6mB,EAAAroB,KAAAgG,KAAAiE,IAAA,QAGA,KAAAzI,EAAA,EAAAA,EAAA6mB,EAAAlmB,OAAAX,IACA6mB,EAAA7mB,GAAA+mB,aAAAF,EAAA7mB,GAAA+mB,YAAAxgB,OACAsgB,EAAA7mB,GAAA+mB,YAAAxgB,MAAAnF,KAAA5C,KAAAqoB,EAAA7mB,GAAA8mB,OASA,KAJAtoB,KAAA+H,QACA/H,KAAAgG,KAAAqE,QAGA7I,EAAA,EAAAA,EAAAxB,KAAAooB,QAAAjmB,OAAAX,IACAxB,KAAAwC,MAAAsE,IACA9G,KAAAooB,QAAA5mB,GAAAC,MAAAzB,KAAAooB,QAAA5mB,GAAAuF,EAAA/G,KAAAooB,QAAA5mB,GAAAwF,EAAAhH,KAAAooB,QAAA5mB,GAAAyF,MAKAjH,MAAAooB,aAMAD,EAAAjjB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAMA,IAAA,GADAwc,GAAAroB,KAAAgG,KAAAiE,IAAA,SACAzI,EAAA,EAAAA,EAAA6mB,EAAAlmB,OAAAX,IACA6mB,EAAAE,aAAAF,EAAAE,YAAAvgB,MACAqgB,EAAAE,YAAAvgB,KAAApF,KAAA5C,KAAAqoB,EAAAC,SClLAH,MAGAzsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,qCAMAsN,QAAA,eAAA,aAAA,SAAA,SAAAoC,EAAA0c,GAKA,QAAAO,GAAAhmB,EAAA9C,GAGA6L,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GC3BA,MDiCA/D,GAAAgJ,OAAA6jB,EAAAtjB,UAAAqG,EAAArG,WASAsjB,EAAAtjB,UAAAkC,OAAA,SAAApB,GAGA,GAAAxE,GACA6E,EAAArG,KAAAgG,KAAA0E,QAAA1E,EAAA,OAGA,KAAAxE,EAAA,EAAAA,EAAA6E,EAAAa,OAAA/E,OAAAX,IACAymB,EAAAlgB,MAAAnF,KAAA5C,KAAAqG,EAAAa,OAAA1F,GAIA,KAAAA,EAAA,EAAAA,EAAA6E,EAAAS,IAAA3E,OAAAX,IACAymB,EAAAjgB,KAAApF,KAAA5C,KAAAqG,EAAAS,IAAAtF,GAIAxB,MAAAgG,KAAAA,EAAAsE,SAMAke,EAAAtjB,UAAAC,UAAA,WAMA,IAAA,GAHAsC,GAAAzH,KAAAgG,KAAAiE,IAAA,QAGAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAymB,EAAAlgB,MAAAnF,KAAA5C,KAAAyH,EAAAjG,GAIAxB,MAAAgG,KAAAqE,SAUAme,EAAAtjB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAQA,IAAA,GAHApE,GAAAzH,KAAAgG,KAAAiE,IAAA,QAGAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAymB,EAAAjgB,KAAApF,KAAA5C,KAAAyH,EAAAjG,KAOAgnB,EAAAtjB,UAAAuG,SAAA,SAAA1E,EAAAC,GAGA,IAAAhH,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,YAKA7L,KAAAgG,KAAAmB,IAAAJ,EAAAC,IACAihB,EAAAjgB,KAAApF,KAAA5C,KAAAA,KAAAgG,KAAAF,IAAAiB,EAAAC,EAAA,UAOAwhB,EAAAtjB,UAAAsG,UAAA,SAAAzE,EAAAC,GACAhH,KAAAgG,KAAAmB,IAAAJ,EAAAC,IACAihB,EAAAlgB,MAAAnF,KAAA5C,KAAAA,KAAAgG,KAAAF,IAAAiB,EAAAC,EAAA,UC3HAwhB,MAGA9sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,uCACA,OACA,2BACA,sCACA,yCAMAsN,QAAA,cAAA,aAAA,YAAA,aAAA,SAAAoC,EAAAkd,EAAAP,GAKA,QAAAQ,GAAAlmB,EAAA9C,GAGAM,KAAAoQ,UACApQ,KAAAsX,YAGA/L,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GChCA,MDsCA/D,GAAAgJ,OAAA+jB,EAAAxjB,UAAAqG,EAAArG,WASAwjB,EAAAxjB,UAAAkC,OAAA,SAAAgJ,EAAAkH,GAGAtX,KAAAmF,YAGAnF,KAAAoQ,OAAAA,EAAAnG,IAAA,SACAjK,KAAAsX,SAAAA,EAAArN,IAAA,SAGAjK,KAAAgI,QAMA0gB,EAAAxjB,UAAAC,UAAA,WAGA,IAAA,GAAA3D,GAAA,EAAAA,EAAAxB,KAAAsX,SAAAnV,OAAAX,IACAxB,KAAAwC,MAAAsE,IAAA,SAAA9G,KAAAsX,SAAA9V,GAAAuF,EAAA/G,KAAAsX,SAAA9V,GAAAwF,EAAAhH,KAAAsX,SAAA9V,GAAA8M,MAIAtO,MAAA+H,QAGA/H,KAAAoQ,UACApQ,KAAAsX,aAUAoR,EAAAxjB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAAA,CAKA,GAAArK,EAGA,KAAAA,EAAA,EAAAA,EAAAxB,KAAAsX,SAAAnV,OAAAX,IACAxB,KAAAwC,MAAA0E,OAAA,SAAAlH,KAAAsX,SAAA9V,GAAAuF,EAAA/G,KAAAsX,SAAA9V,GAAAwF,GACAkhB,EAAAlgB,KAAApF,KAAA5C,KAAAA,KAAAsX,SAAA9V,GAIA,KAAAA,EAAA,EAAAA,EAAAxB,KAAAoQ,OAAAjO,OAAAX,IACAinB,EAAAzgB,KAAApF,KAAA5C,KAAAA,KAAAoQ,OAAA5O,MCvGAknB,MAGAhtB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,0CAMAsN,QAAA,eAAA,aAAA,cAAA,SAAAoC,EAAAod,GAKA,QAAAC,GAAApmB,EAAA9C,GAGA6L,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GC3BA,MDiCA/D,GAAAgJ,OAAAikB,EAAA1jB,UAAAqG,EAAArG,WAKA0jB,EAAA1jB,UAAA4B,IAAA,SAAAoH,GAGAA,EAAAE,UAAA,GAAA,mBAAAF,GAAAU,OAAAV,EAAAU,MAAA,GAKA5O,KAAAgG,KAAAmB,IAAA+G,EAAAnH,EAAAmH,EAAAlH,KAKAhH,KAAAgG,KAAA6D,IAAAqE,EAAAnH,EAAAmH,EAAAlH,EAAAkH,EAAAI,OAGAtO,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,YACA8c,EAAA3gB,KAAApF,KAAA5C,KAAAkO,KAOA0a,EAAA1jB,UAAAgC,OAAA,SAAAgH,GAGAlO,KAAAgG,KAAA+D,MAAAmE,EAAAnH,EAAAmH,EAAAlH,GAGAhH,KAAA8D,UAMA8kB,EAAA1jB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAAA,CAKA,GAAAgd,GAAA7oB,KAAAwC,MAAA4C,MAAAU,IAAA,cAAA9F,KAAAwC,MAAA+F,cAGAvI,MAAAN,QAAAopB,aAAA,EAAA,EAAA,EAAA,EAAAD,EAAAA,EAMA,KAAA,GAHArhB,GAAAxH,KAAAgG,KAAAiE,IAAA,SAGAzI,EAAA,EAAAA,EAAAgG,EAAArF,OAAAX,IACAmnB,EAAA3gB,KAAApF,KAAA5C,KAAAwH,EAAAhG,MC5FAonB,MAGAltB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,oCAMAsN,QAAA,eAAA,aAAA,QAAA,aAAA,SAAAoC,EAAAwd,EAAAhb,GAKA,QAAAib,GAAAxmB,EAAA9C,GAGA6L,EAAA3I,KAAA5C,KAAAwC,EAAA9C,GAGAM,KAAAgG,KAAA6E,UAAAkD,EAAAlR,OC9BA,MDoCAlB,GAAAgJ,OAAAqkB,EAAA9jB,UAAAqG,EAAArG,WASA8jB,EAAA9jB,UAAAkC,OAAA,SAAApB;AAGA,GAAAxE,GACA6E,EAAArG,KAAAgG,KAAA0E,QAAA1E,EAAA,QAGA,KAAAxE,EAAA,EAAAA,EAAA6E,EAAAa,OAAA/E,OAAAX,IACAunB,EAAAhhB,MAAAnF,KAAA5C,KAAAqG,EAAAa,OAAA1F,GAIA,KAAAA,EAAA,EAAAA,EAAA6E,EAAAS,IAAA3E,OAAAX,IACAunB,EAAA/gB,KAAApF,KAAA5C,KAAAqG,EAAAS,IAAAtF,GAIAxB,MAAAgG,KAAAA,EAAAsE,SAUA0e,EAAA9jB,UAAA8C,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAQA,IAAA,GAHArE,GAAAxH,KAAAgG,KAAAiE,IAAA,SAGAzI,EAAA,EAAAA,EAAAgG,EAAArF,OAAAX,IACAunB,EAAA/gB,KAAApF,KAAA5C,KAAAwH,EAAAhG,KAOAwnB,EAAA9jB,UAAApB,OAAA,WAGA9D,KAAAwC,MAAA2C,UAAA,UAGAnF,KAAA+H,QACA/H,KAAAgI,QAMAghB,EAAA9jB,UAAAuG,SAAA,SAAA1E,EAAAC,GAGA,IAAAhH,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,YAKA7L,KAAAgG,KAAAmB,IAAAJ,EAAAC,IACA+hB,EAAA/gB,KAAApF,KAAA5C,KAAAA,KAAAgG,KAAAF,IAAAiB,EAAAC,EAAA,WAOAgiB,EAAA9jB,UAAAsG,UAAA,SAAAzE,EAAAC,GACAhH,KAAAgG,KAAAmB,IAAAJ,EAAAC,IACA+hB,EAAAhhB,MAAAnF,KAAA5C,KAAAA,KAAAgG,KAAAF,IAAAiB,EAAAC,EAAA,WC1HAgiB,MAGAttB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,yCACA,SAMAsN,QAAA,cAAA,WAGA,GAAA8f,IACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IACA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KACA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,KACA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAIAjP,EAAA,IAAAD,WAAA,GACAmP,EAAA,IAAAnP,WAAA,GAKAxV,GAGA0kB,MAAA,SAAAznB,GACA,MAAAynB,GAAAznB,IAAA,IAIA2nB,QAAA,SAAA3nB,GACA,MAAAA,GAAA,GAIA4nB,QAAA,SAAA5nB,GAGA,GAAA+O,GAAA,EAcA,OAXA/O,IAAA,KACA+O,EAAA,IACA/O,GAAA,IAIAA,GAAA,GACAA,IAIA+O,EAAAT,OAAAC,aAAAiK,EAAAxY,IAIA2S,IAAA,SAAA3S,GACA,MAAAA,IAIA0T,IAAA,SAAA1T,GACA,GAAA+O,EAOA,OALAA,GADA/O,EAAA,GACA0nB,EAAA1nB,EAGAwY,EAAAxY,EAEAsO,OAAAC,aAAAQ,KAOA6W,GAKApf,KAAA,WAGA,GAAAhI,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAAA,CAKA,GAAAlL,GAAAX,KAAAwC,MAAA+F,cAGA8gB,EAAAzoB,KAAAoO,MAAAhP,KAAAwC,MAAA6C,cAAA1E,EAAA,GAAA,GACA2oB,EAAAtpB,KAAAwC,MAAA/B,UAAA4oB,EACAE,EAAA3oB,KAAAoO,MAAAhP,KAAAwC,MAAA8C,cAAA3E,EAAA,GAAA,GACA6oB,EAAAxpB,KAAAwC,MAAA9B,WAAA6oB,EAGA/B,EAAAxnB,KAAAwC,MAAA4C,MAAAU,IAAA,qBACAuK,GACAX,KAAA1P,KAAAwC,MAAA4C,MAAAU,IAAA,6BACA7C,KAAAjD,KAAAwC,MAAA4C,MAAAU,IAAA,6BACAqI,MAAAnO,KAAAwC,MAAA4C,MAAAU,IAAA,8BACAwK,QAAAtQ,KAAAwC,MAAA4C,MAAAU,IAAA,iCAEA0K,GACAd,KAAA1P,KAAAwC,MAAA4C,MAAAU,IAAA,+BACA7C,KAAAjD,KAAAwC,MAAA4C,MAAAU,IAAA,+BACAqI,MAAAnO,KAAAwC,MAAA4C,MAAAU,IAAA,gCACAwK,QAAAtQ,KAAAwC,MAAA4C,MAAAU,IAAA,kCAIA9F,MAAAN,QAAA8nB,UAAAA,EACAxnB,KAAAN,QAAA+pB,aAAA,SACAzpB,KAAAN,QAAAgqB,UAAA,QAGA,IAAAloB,GAAA4J,EAAArE,EAAAC,EAAAuJ,CAGA,KAAA/O,EAAA,EAAAA,EAAAxB,KAAAwC,MAAAtC,OAAAsB,IAGA4J,EAAA5J,EACA6O,EAAAC,UACAlF,EAAApL,KAAAwC,MAAAtC,OAAAsB,EAAA,GAKA+O,EADA,kBAAAF,GAAAlC,MACAkC,EAAAlC,MAAAvL,KAAA5C,KAAAoL,GAEA7G,EAAA8L,EAAAlC,OACA5J,EAAA8L,EAAAlC,OAAAvL,KAAA5C,KAAAoL,GAGAA,EAIApE,EAAAhH,KAAAwC,MAAAoG,QAAApH,GACAxB,KAAAN,QAAAgQ,KAAAW,EAAApN,KAAAsN,EAAA5P,GAAA,IAAA0P,EAAAX,KACA1P,KAAAN,QAAAiqB,SAAApZ,EAAA8Y,EAAAriB,GACAhH,KAAAN,QAAAiqB,SAAApZ,EAAA+Y,EAAAtiB,EAIA,KAAAxF,EAAA,EAAAA,EAAAxB,KAAAwC,MAAAzC,MAAAyB,IAGA4J,EAAA5J,EACAgP,EAAAF,UACAlF,EAAApL,KAAAwC,MAAAzC,MAAAyB,EAAA,GAKA+O,EADA,kBAAAC,GAAArC,MACAqC,EAAArC,MAAAvL,KAAA5C,KAAAoL,GAEA7G,EAAAiM,EAAArC,OACA5J,EAAAiM,EAAArC,OAAAvL,KAAA5C,KAAAoL,GAGAA,EAIArE,EAAA/G,KAAAwC,MAAAgG,QAAAhH,GACAxB,KAAAN,QAAAgQ,KAAAc,EAAAvN,KAAAsN,EAAA5P,GAAA,IAAA6P,EAAAd,KACA1P,KAAAN,QAAAiqB,SAAApZ,EAAAxJ,EAAAwiB,GACAvpB,KAAAN,QAAAiqB,SAAApZ,EAAAxJ,EAAAyiB,KC3LA,OAAApC,MAGA1rB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,oCACA,OACA,8BAMAsN,QAAA,UAAA,cAAA,cAAA,SAAA6E,EAAApC,GAWA,QAAAge,GAAAniB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,yBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,EAGArM,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EAGArM,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiO,OAAA5G,EAAAC,EAAAsC,GACAtJ,KAAAN,QAAAsoB,OAAAjhB,EAAAnG,KAAA+H,MAAAW,EAAAugB,GAAA7iB,EAAApG,KAAA+H,MAAAW,EAAA,IACAtJ,KAAAN,QAAAsoB,OAAAjhB,EAAAnG,KAAA+H,MAAAW,EAAAugB,GAAA7iB,EAAApG,KAAA+H,MAAAW,EAAA,IACAtJ,KAAAN,QAAAoqB,YACA9pB,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAA6Y,GAAAtiB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAAmqB,GAAAppB,KAAA+H,MAAAW,EAAA2gB,GAGA1b,EAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,EAGArM,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EAGArM,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAwqB,KAAAnjB,EAAAijB,EAAAhjB,EAAAgjB,EAAA,EAAAA,EAAA,EAAAA,GACAhqB,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAiZ,GAAA1iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EAGArM,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAAsC,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAkZ,GAAA3iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,qBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAAmqB,GAAAppB,KAAA+H,MAAAW,EAAA2gB,GAGA1b,EAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAAtP,KAAAwC,MAAA4C,MAAAU,IAAA,uBACAqG,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7E,EAGArM,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAA4P,QAAAA,EAGAtP,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiO,OAAA5G,EAAAijB,EAAAhjB,EAAAgjB,GACAhqB,KAAAN,QAAAsoB,OAAAjhB,EAAAijB,EAAAhjB,EAAAgjB,GACAhqB,KAAAN,QAAAiO,OAAA5G,EAAAijB,EAAAhjB,EAAAgjB,GACAhqB,KAAAN,QAAAsoB,OAAAjhB,EAAAijB,EAAAhjB,EAAAgjB,GACAhqB,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAmZ,GAAA5iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAme,EAAA/f,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA8nB,UAAAA,EACAxnB,KAAAN,QAAA2M,UAAAA,EAGArM,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAAsC,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,OAGA1nB,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAoZ,GAAA7iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,qBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGAgjB,EAAA/f,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,gBAAA7H,EAGArJ,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA8nB,UAAAA,EAGAxnB,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiO,OAAA5G,EAAAC,GACAhH,KAAAN,QAAAsoB,OAAAjhB,EAAAuC,EAAAtC,GACAhH,KAAAN,QAAAsoB,OAAAjhB,EAAAC,EAAAsC,GACAtJ,KAAAN,QAAAoqB,YACA9pB,KAAAN,QAAAgoB,OAGA1nB,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAqZ,GAAA9iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAAtP,KAAAwC,MAAA4C,MAAAU,IAAA,yBACAqG,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAA4P,QAAAA,EAGAtP,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAmO,SACA7N,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAmO,SACA7N,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiO,OAAA5G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,GACAtJ,KAAAN,QAAAkO,cACA7G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,GAEAtJ,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAsZ,GAAA/iB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA+H,MACA3I,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAArJ,KAAAwC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAAtP,KAAAwC,MAAA4C,MAAAU,IAAA,yBACAqG,EAAA1E,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAAyM,YAAAA,EACAnM,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAA4P,QAAAA,EAGAtP,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAmO,SACA7N,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAmO,SACA7N,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiO,OAAA5G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAA,GACAtJ,KAAAN,QAAAkO,cACA7G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAA,GAEAtJ,KAAAN,QAAAmO,SAGA7N,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAuZ,GAAAhjB,GAGA,GAAAV,GAAA/G,KAAAwC,MAAAgG,QAAAf,EAAAV,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA5B,GAAA5H,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA7B,EAAA5H,OAIA,IAAA0O,GAAAvO,KAAAwC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAAhH,KAAAwC,MAAAgC,gBAGAkL,EAAAjI,EAAAiI,MAAA1P,KAAAwC,MAAA4C,MAAAU,IAAA,sBAAA,GACA0hB,EAAA/f,EAAA6G,OAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAwC,MAAA2E,IAAA,SAAAM,EAAAV,EAAAU,EAAAT,IACAhH,KAAAwC,MAAAM,OAAAkD,KAAAwF,UAAA/D,EAAAV,EAAAU,EAAAT,GAIAhH,KAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAlR,KAAAN,QAAA8nB,UAAAA,EACAxnB,KAAAN,QAAA+pB,aAAA,SACAzpB,KAAAN,QAAAgqB,UAAA,SAGA,gBAAAjiB,GAAAoI,OACApI,EAAAoI,KAAApI,EAAAoI,KAAA6a,YAIA,IAAAjjB,EAAAoI,KAAA1N,OACAnC,KAAAN,QAAAgQ,KAAA9O,KAAA+H,MAAA,IAAAW,GAAA,MAAAoG,EAEA,IAAAjI,EAAAoI,KAAA1N,OACAnC,KAAAN,QAAAgQ,KAAA9O,KAAA+H,MAAA,IAAAW,GAAA,MAAAoG,EAGA1P,KAAAN,QAAAgQ,KAAApG,EAAA,MAAAoG,EAIA1P,KAAAN,QAAA6M,YACAvM,KAAAN,QAAAiqB,SAAAliB,EAAAoI,KAAA9I,EAAAC,EAAA,EAAAsC,GAGAtJ,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAyZ,GAAAljB,GAGAzH,KAAAwC,MAAA2E,IAAA,SAAAM,EAAAV,EAAAU,EAAAT,IACAhH,KAAAwC,MAAAM,OAAAkD,KAAA0F,WAAAjE,EAAAV,EAAAU,EAAAT,GA5bA,GAAAijB,GAAArpB,KAAAgM,IAAAhM,KAAAiM,GAAA,GACAgd,EAAAjpB,KAAAgM,IAAAhM,KAAAiM,GAAA,GAkcAob,GAKAjgB,KAAA,SAAAP,GAGA,GAAAzH,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAKA,OAAApE,EAAAmI,MAGA,IAAA5B,GAAA9Q,SACA0sB,EAAAhnB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAA5Q,OACA2sB,EAAAnnB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAA7Q,OACAgtB,EAAAvnB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAA3Q,KACA+sB,EAAAxnB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAA1Q,OACA+sB,EAAAznB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAAtQ,MACA6sB,EAAA3nB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAAvQ,IACA+sB,EAAA5nB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAAxQ,KACA8sB,EAAA1nB,KAAA5C,KAAAyH,EACA,MAGA,KAAAuG,GAAAzQ,MACAkK,EAAAoI,KAAApI,EAAAoI,MAAA,GACA4a,EAAA7nB,KAAA5C,KAAAyH,KAQAM,MAAA,SAAAN,GAGAzH,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,aAKAD,EAAA7D,MAAAnF,KAAA5C,KAAAyH,GAGAA,EAAAmI,OAAA5B,EAAAzQ,OACAotB,EAAA/nB,KAAA5C,KAAAyH,KC5iBA,OAAAwgB,OAGAvsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,mCACA,OACA,4BACA,oCAMAsN,QAAA,SAAA,YAAA,cAAA,aAAA,eAAA,SAAArE,EAAA8G,EAAAmC,EAAA6c,GAUA,QAAAC,GAAA3c,GAGA,GAAAnH,GAAA/G,KAAAwC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAArO,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA4E,EAAArO,QAIAqO,EAAAE,QAAA,CAGA,IAAAE,GAAAJ,EAAAI,MAAAtO,KAAAwC,MAAAgC,gBAGA6H,EAAArM,KAAAwC,MAAA4C,MAAAU,IAAA,uBAAAuD,IAAA,EACAme,EAAAxnB,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAwI,GACAnC,EAAAnM,KAAAwC,MAAA4C,MAAAU,IAAA,uBAAAwI,GACA4C,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA5c,EAAAU,OAIA5O,KAAAN,QAAA8nB,UAAAA,EAGAxnB,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA+C,GAAA,EAAA,EAAAzL,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,OAGA1nB,KAAAN,QAAA2M,UAAAA,EACArM,KAAAN,QAAAyM,YAAAA,EAGAnM,KAAAN,QAAAmO,SAGAK,EAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA,GAIA9qB,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAA6Z,GAAA7c,GAGA,GAAAnH,GAAA/G,KAAAwC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAArO,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA4E,EAAArO,OAIA,IAAAyO,GAAAJ,EAAAI,MAAAtO,KAAAwC,MAAAgC,gBAGA0M,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAGAlR,MAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA5c,EAAAU,OAIA5O,KAAAN,QAAA6M,YAGA+B,IAAAP,EAAA/Q,GACAgD,KAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEAtJ,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,QACAjrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,UAGAjrB,KAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEAtJ,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,QACAjrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,SAIAjrB,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,OAGAxZ,EAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA,GAIA9qB,KAAAN,QAAAqoB,WAAA7W,GAAAA,GAMA,QAAAga,GAAAhd,GAGA,GAAAnH,GAAA/G,KAAAwC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAArO,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA4E,EAAArO,QAIAsrB,EAAAA,GAAAvqB,KAAAoO,KAAA,QAAApO,KAAAwqB,SAGA,IAAA9c,GAAAJ,EAAAI,MAAAtO,KAAAwC,MAAAgC,gBAGA6mB,EAAArrB,KAAAwC,MAAA4C,MAAAU,IAAA,qBACA0hB,EAAAxnB,KAAAwC,MAAA4C,MAAAU,IAAA,oBAAAwI,GACAnC,EAAAnM,KAAAwC,MAAA4C,MAAAU,IAAA,sBACAoL,EAAAlR,KAAAwC,MAAA4C,MAAA8L,iBAiBA,IAdAlR,KAAAN,QAAAqoB,UAAA7W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA5c,EAAAU,OAIA5O,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAA8nB,UAAAA,EACAxnB,KAAAN,QAAAgoB,OAGApZ,IAAAP,EAAA/Q,EAAA,CAGA,GAAA4S,GACAub,GAAAE,EAAAlpB,OAAA+L,EAAAnH,EAAA/G,KAAAwC,MAAAzC,MAAAmO,EAAAlH,GAAAqkB,EAAAlpB,OAGAmpB,EAAAtrB,KAAAwC,MAAAzC,MAAAC,KAAAwC,MAAAtC,OAAAgO,EAAAnH,EAAA/G,KAAAwC,MAAAzC,MAAAmO,EAAAlH,EACA0F,EAAA,EAAA4e,GAAAH,EAAAG,EAGAV,GAAAhoB,KAAAyoB,EAAAzb,GAAA5P,KAAAN,QAAAqH,EAAAC,EAAAsC,EAAAoD,EAAAP,GAGAnM,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,GAEAtJ,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,yBACAjrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,uBACAjrB,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,WAOA1nB,MAAAN,QAAA6M,YACAvM,KAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,GAEAtJ,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,oBACAjrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,iBACAjrB,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,OAGA1nB,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEAtJ,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,oBACAjrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,iBACAjrB,KAAAN,QAAA+nB,IAAA1gB,EAAAC,EAAApG,KAAA4L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAA1I,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,MAIAxZ,GAAAU,OAAAV,EAAAU,MAAA,IACA5O,KAAAN,QAAAorB,YAAA,GAIA9qB,KAAAN,QAAAqoB,WAAA7W,GAAAA,GA7NA,GAAAia,GAmOApC,GAKA/gB,KAAA,SAAAkG,GAGA,GAAAlO,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,WAAA,CAKA,GAAAsC,GAAAnO,KAAAwC,MAAA4C,MAAAU,IAAA,cAGA,QAAAqI,GAGA,IAAA,QACA+c,EAAAtoB,KAAA5C,KAAAkO,EACA,MAGA,KAAA,QACA6c,EAAAnoB,KAAA5C,KAAAkO,EACA,MAGA,KAAA,OACA2c,EAAAjoB,KAAA5C,KAAAkO,EACA,MAGA,SACA,GAAAqd,GAAAzmB,EAAAgB,IAAAqI,EACAod,IACAA,EAAA3oB,KAAA5C,KAAAkO,IAKAlO,KAAAwC,MAAAxC,WAAAkO,EAAAE,UAAA,GAAApO,KAAAwC,MAAA4C,MAAAU,IAAA,iBACA9F,KAAAwC,MAAAM,OAAAsL,OAAAtH,IAAAoH,KAOAnG,MAAA,SAAAmG,GAGAlO,KAAAN,SAAA,IAAAM,KAAAwC,MAAA/B,WAAA,IAAAT,KAAAwC,MAAAqJ,aAKAD,EAAA7D,MAAAnF,KAAA5C,KAAAkO,IAGAlO,KAAAwC,MAAAxC,WAAAkO,EAAAE,UAAA,GAAApO,KAAAwC,MAAA4C,MAAAU,IAAA,iBACA9F,KAAAwC,MAAAM,OAAAsL,OAAAlH,OAAAgH,KC7TA,OAAA6a,OAGArtB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,wCACA,OACA,oCAMAsN,QAAA,cAAA,QAAA,SAAA4f,GAKA,GAAAb,IAKAlgB,KAAA,SAAAkG,GAGAA,EAAArO,MAAAG,KAAAwC,MAAA4C,MAAAU,IAAA,qBACAoI,EAAAU,MAAA5O,KAAAwC,MAAA4C,MAAAU,IAAA,oBAAAoI,EAAAI,OAGAJ,EAAAE,QAAA,EAGA2a,EAAA/gB,KAAApF,KAAA5C,KAAAkO,IAMAnG,MAAA,SAAAmG,GAGAA,EAAAE,QAAA,EAGA2a,EAAAhhB,MAAAnF,KAAA5C,KAAAkO,ICtDA,OAAAga,OAGAxsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,uCACA,OACA,oCAMAsN,QAAA,aAAA,QAAA,SAAA4f,GAKA,GAAAN,IAKAzgB,KAAA,SAAAkG,GAGAA,EAAArO,MAAAG,KAAAwC,MAAA4C,MAAAU,IAAA,oBACAoI,EAAAU,MAAA5O,KAAAwC,MAAA4C,MAAAU,IAAA,mBAAAoI,EAAAI,OAGAJ,EAAAE,QAAA,EAGA2a,EAAA/gB,KAAApF,KAAA5C,KAAAkO,IAMAnG,MAAA,SAAAmG,GAGAA,EAAAE,QAAA,EAGA2a,EAAAhhB,MAAAnF,KAAA5C,KAAAkO,ICvDA,OAAAua,OAGA/sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,yCACA,OACA,8BAMAsN,QAAA,cAAA,WAKA,GAAAwf,IAKA3gB,KAAA,SAAAkG,GAGA,GAAAlO,KAAAN,WAKAwO,EAAAU,OAAAV,EAAAU,MAAA,GAAAV,EAAAE,UAAA,GAAA,CAKA,GAAArH,GAAA/G,KAAAwC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAA1I,KAAA4L,IAAA,EAAAxM,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAA,GAGA6E,GAAArO,QACAyJ,EAAA1I,KAAA+H,MAAAW,EAAA4E,EAAArO,OAIA,IAAAiP,GAAA9O,KAAAwC,MAAA4C,MAAAU,IAAA,cAAAuD,GACA0F,EAAA/O,KAAAwC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA4F,EAAAjP,KAAAwC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACAmiB,EAAAxrB,KAAAwC,MAAA4C,MAAAU,IAAA,eAGA9F,MAAAN,QAAA8nB,UAAAxnB,KAAAN,QAAAsrB,qBACAjkB,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAA,EAAAwF,EAAA/H,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAAwF,GAEA9O,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAAO,GACAxrB,KAAAN,QAAA8nB,UAAAyD,aAAA,EAAA,iBAGAjrB,KAAAN,QAAA6M,YACAvM,KAAAN,QAAA+nB,IAAA1gB,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAAwF,EAAA,EAAA,EAAAlO,KAAAiM,IAAA,GACA7M,KAAAN,QAAAgoB,SAMA3f,MAAA,SAAAmG,GAQA,GAAAlO,KAAAN,WAKAwO,EAAAU,OAAAV,EAAAU,MAAA,GAAAV,EAAAE,UAAA,GAAA,CAKA,GAAArH,GAAA/G,KAAAwC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAAhH,KAAAwC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAArJ,KAAAwC,MAAA+F,cACAe,EAAAtJ,KAAAwC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGArJ,MAAAN,QAAA6J,UAAAxC,EAAA,IAAAuC,EAAAtC,EAAA,IAAAsC,EAAA,IAAAA,EAAA,IAAAA,KCrGA,OAAAqf,MAGAjtB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,mCACA,OACA,6BAMA4vB,KAAA,SAAA,cAAA,mBAAA,SAAA7nB,EAAAggB,EAAA8H,GAKA9nB,EAAArB,GAAA,UAAAmpB,EAAAC,SACA/H,EAAAhmB,OAAAgmB,EAAA/lB,OAEA+F,EAAArB,GAAA,mBAAAmpB,EAAAE,YACAhI,EAAAhmB,OAAAgmB,EAAA/lB,OAEA+F,EAAArB,GAAA,YAAAmpB,EAAAG,WACAjI,EAAAhmB,OAAAgmB,EAAA/lB,KAAA+lB,EAAA9lB,QAEA8F,EAAArB,GAAA,WAAAmpB,EAAAI,UACAlI,EAAAhmB,OAAAgmB,EAAA/lB,KAAA+lB,EAAA9lB,QAEA8F,EAAArB,GAAA,YAAAmpB,EAAAK,WACAnI,EAAAhmB,OAAAgmB,EAAA/lB,KAAA+lB,EAAA9lB,QAEA8F,EAAArB,GAAA,UAAAmpB,EAAAM,SACApI,EAAAhmB,OAAAgmB,EAAA/lB,KAAA+lB,EAAA9lB,WAOAqL,QAAA,oBAAA,SAAA,cAAA,aAAA,WAAA,SAAAvF,EAAAigB,EAAA3E,EAAA+M,GAKA,QAAAC,GAAAjqB,GAGA,GAAA0iB,IACAwH,OACAplB,EAAA/G,KAAAosB,MAAAC,UAAAtlB,EAAA9E,EAAA8E,EAAA9E,EAAA8E,EAAA/G,KAAAosB,MAAAC,UAAAtlB,EACAC,EAAAhH,KAAAosB,MAAAC,UAAArlB,EAAA/E,EAAA+E,EAAA/E,EAAA+E,EAAAhH,KAAAosB,MAAAC,UAAArlB,GAEA4Q,MACA7Q,EAAA/G,KAAAosB,MAAAC,UAAAtlB,EAAA9E,EAAA8E,EAAA/G,KAAAosB,MAAAC,UAAAtlB,EAAA9E,EAAA8E,EACAC,EAAAhH,KAAAosB,MAAAC,UAAArlB,EAAA/E,EAAA+E,EAAAhH,KAAAosB,MAAAC,UAAArlB,EAAA/E,EAAA+E,GAmBA,OAdA2d,GAAAwH,MAAAplB,EAAA,IACA4d,EAAAwH,MAAAplB,EAAA,GAEA4d,EAAAwH,MAAAnlB,EAAA,IACA2d,EAAAwH,MAAAnlB,EAAA,GAEA2d,EAAA/M,KAAA7Q,EAAA/G,KAAAwC,MAAAzC,MAAA,IACA4kB,EAAA/M,KAAA7Q,EAAA/G,KAAAwC,MAAAzC,MAAA,GAEA4kB,EAAA/M,KAAA5Q,EAAAhH,KAAAwC,MAAAtC,OAAA,IACAykB,EAAA/M,KAAA5Q,EAAAhH,KAAAwC,MAAAtC,OAAA,GAIAykB,EAMA,QAAA2H,GAAArqB,GAGA,GAAAsqB,GAAA,EACAC,EAAA,CAmCA,OAhCA,UAAAvqB,KACAuqB,EAAAvqB,EAAAwqB,WAEA,cAAAxqB,KACAuqB,EAAAvqB,EAAAyqB,YAEA,eAAAzqB,KACAuqB,EAAAvqB,EAAA0qB,aAEA,eAAA1qB,KACAsqB,EAAAtqB,EAAA2qB,gBAIA,QAAA3qB,IAAAA,EAAA4qB,OAAA5qB,EAAA6qB,kBACAP,EAAAC,KACAA,EAAA,GAIA,UAAAvqB,KACAuqB,EAAAvqB,EAAAuqB,WAEA,UAAAvqB,KACAsqB,EAAAtqB,EAAAsqB,QAIAtqB,EAAA8qB,YAAAR,EACAtqB,EAAA+qB,YAAAR,EAGAvqB,EAMAtG,EAAAgJ,OAAAf,GAKAwoB,OAGAC,UAAA,KAGAY,SACAC,WAOA,IAAA3H,IAKAoG,QAAA,SAAA1pB,EAAAkrB,GAGA,GAAAntB,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAKA,OAAA2Y,EAAAC,SAGA,IAAAnB,GAAAztB,IAGAwB,KAAAosB,MAAAC,UAAA,KACArsB,KAAAgnB,mBAAA,CACA,MAGA,KAAAiF,GAAA5tB,MAGA2B,KAAA8jB,sBACAqJ,EAAAE,iBAGArtB,KAAAujB,OAAAM,EAAA7lB,MAAAgC,KAAAmS,KAAAI,OAAAvS,KAAA+kB,iBACA/kB,KAAAmZ,OAGA,MAGA,KAAA8S,GAAA7tB,KAGA4B,KAAA8jB,sBACAqJ,EAAAE,iBAGArtB,KAAAujB,OAAAM,EAAA7lB,MAAAgC,KAAAmS,KAAAI,OAAAvS,KAAA8kB,mBACA9kB,KAAAoZ,WAGA,MAGA,KAAA6S,GAAA3tB,GACA,KAGA,KAAA2tB,GAAA1tB,QAQAqtB,WAAA,SAAA3pB,EAAAsiB,GAGA,IAAAvkB,KAAA+jB,uBAAA/jB,KAAAujB,OAAAM,EAAA7lB,KACA,OAAA,CAIA,KAAAgC,KAAAmS,OAAAnS,KAAAmS,KAAAqC,WACA,OAAA,CAIA+P,GAAA+H,EAAA/H,EAGA,IAAA+I,GAAA/I,EAAAyI,aAAAzI,EAAAiI,MAGAc,GAAA,GACAttB,KAAAwC,OACAxC,KAAAwC,MAAA2C,UAAA,SAEAnF,KAAAmZ,QAIAmU,EAAA,IACAttB,KAAAwC,OACAxC,KAAAwC,MAAA2C,UAAA,SAEAnF,KAAAoZ,YAIA,IAAAkU,GACA/I,EAAA8I,kBAOAvB,SAAA,WACA9rB,KAAAwC,OACAxC,KAAAwC,MAAA2C,UAAA,UAOA0mB,UAAA,SAAA5pB,EAAAsiB,IAIAvkB,KAAAosB,MAAAC,WACArsB,KAAAosB,MAAAC,UAAAtlB,IAAA9E,EAAA8E,GAAA/G,KAAAosB,MAAAC,UAAArlB,IAAA/E,EAAA+E,IAEAud,EAAAI,KAAAuH,EAAAtpB,KAAA5C,KAAAiC,IAIAjC,KAAAwC,OAAAxC,KAAAwC,MAAAM,OAAAulB,QAKAroB,KAAAosB,MAAAa,QAAAhrB,EAAA8E,GAAA/G,KAAAosB,MAAAc,QAAAjrB,EAAA+E,IAKAhH,KAAAosB,MAAAa,MAAAhrB,EAAA8E,EACA/G,KAAAosB,MAAAc,MAAAjrB,EAAA+E,EAGAhH,KAAAolB,UAAA,QAAAb,MAMAwH,UAAA,SAAA9pB,GACAjC,KAAAosB,MAAAC,WACAtlB,EAAA9E,EAAA8E,EACAC,EAAA/E,EAAA+E,IAOAglB,QAAA,SAAA/pB,EAAAsiB,IAEAvkB,KAAAosB,MAAAC,WACArsB,KAAAosB,MAAAC,UAAAtlB,IAAA9E,EAAA8E,GAAA/G,KAAAosB,MAAAC,UAAArlB,IAAA/E,EAAA+E,IAEAud,EAAAI,KAAAuH,EAAAtpB,KAAA5C,KAAAiC,GACAjC,KAAAolB,UAAA,YAAAb,IAEAvkB,KAAAosB,MAAAC,UAAA,MChUA,OAAA9G,OAGA7pB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,iCACA,OACA,6BAMAC,SAAA,cACAiB,MAAA,QACAE,MAAA,QACAswB,MAAA,UAMAzxB,SAAA,eACAoB,SAAA,WACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,OAAA,SACAG,IAAA,MACAC,MAAA,QACA8vB,KAAA,OACAC,OAAA,SACAF,MAAA,UAMA9B,KAAA,SAAA,cAAA,iBAAA,SAAA7nB,EAAAggB,EAAA8J,GAGA9pB,EAAArB,GAAA,aAAAmrB,EAAAC,WAAA/J,EAAA/lB,MACA+F,EAAArB,GAAA,aAAAmrB,EAAAE,WAAAhK,EAAA/lB,MACA+F,EAAArB,GAAA,YAAAmrB,EAAAG,UAAAjK,EAAA/lB,MACA+F,EAAArB,GAAA,YAAAmrB,EAAAI,UAAAlK,EAAA/lB,MACA+F,EAAArB,GAAA,UAAAmrB,EAAA/B,QAAA/H,EAAA/lB,MACA+F,EAAArB,GAAA,QAAAmrB,EAAAK,MAAAnK,EAAA/lB,MACA+F,EAAArB,GAAA,QAAAmrB,EAAArF,MAAAzE,EAAA/lB,MAGA+F,EAAA0hB,aAAA1B,EAAA/lB,KAAA6vB,MAMA3pB,SAAA,iBAAA,WAKA,GAAAC,KAOAhE,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,SAAA,cAAA,aAAA,cAAA,cAAA,aAAA,aAAA,SACAhB,EAAAigB,EAAAmK,EAAAC,EAAAjgB,EAAAkR,EAAAnR,GAUA,QAAAmgB,GAAAnnB,EAAAC,EAAAmnB,GASA,GANA,mBAAApnB,IAAA,mBAAAC,KACAD,EAAA/G,KAAAosB,MAAAa,MACAjmB,EAAAhH,KAAAosB,MAAAc,OAIAltB,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAAhH,KAAAujB,MAGA,IAAAM,GAAA3lB,MAGA8B,KAAAouB,YAAAJ,EAAAT,MAGAvtB,KAAAmS,KAAA2G,SAAA/R,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA3Q,OASA2C,KAAAmS,KAAA2G,SAAA/R,EAAAC,EAAAhH,KAAAquB,kBAQAF,GACAnuB,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA3Q,OAVA2C,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAjH,KAAAquB,kBAYA,MAGA,KAAAxK,GAAA1lB,OAGA6B,KAAAsuB,aAAAL,EAAAV,OAAAvtB,KAAAmS,KAAA4G,UAAAhS,EAAAC,GACAhH,KAAAmS,KAAA4G,UAAAhS,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA3Q,OAMA2C,KAAAsuB,aAAAL,EAAAT,MAAAxtB,KAAAsuB,aAAAL,EAAAR,OACAztB,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,OACA2I,KAAA5B,EAAAzQ,MACAsS,KAAA7P,KAAAuuB,eAOAvuB,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAjH,KAAAsuB,YAGA,MAGA,KAAAzK,GAAA7lB,MAGAgC,KAAAmS,KAAA2G,SAAA/R,EAAAC,IAAAhH,KAAAmS,KAAA0F,YAAA9Q,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAjH,KAAAmS,KAAAiF,WAGA,MAGA,KAAAyM,GAAA5lB,MAGA+B,KAAAmS,KAAA2G,SAAA/R,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA3Q,QAUA,QAAAsf,GAAA5V,EAAAC,GAGA,GAAAhH,KAAAmS,KAAA4G,UAAAhS,EAAAC,GAAA,CAGA,GAAAS,GAAAzH,KAAAmS,KAAA8G,UAAAlS,EAAAC,EAGA,IAAAS,EAAAmI,OAAA5B,EAAAzQ,OAAAkK,EAAAoI,KAAA,CACA,GAAArO,GAAAxB,KAAAwuB,aAAArrB,QAAAsE,EAAAoI,KACArO,SACAxB,KAAAwuB,aAAA5V,OAAApX,EAAA,GAMA,WADAxB,MAAAmS,KAAA0G,aAAA9R,EAAAC,GAKAhH,KAAAsuB,aAAAL,EAAAV,QAKAvtB,KAAAsuB,aAAAL,EAAAT,MACAxtB,KAAAmS,KAAAsG,UAAA1R,EAAAC,GACA4I,KAAA5B,EAAAzQ,MACAsS,KAAA7P,KAAAuuB,cAIAvuB,KAAAwuB,aAAArkB,KAAAnK,KAAAuuB,aACAvuB,KAAAyuB,wBAIAzuB,KAAAsuB,aAAAL,EAAAR,QACAztB,KAAAmS,KAAAsG,UAAA1R,EAAAC,GACA4I,KAAA5B,EAAAzQ,MACAsS,KAAA7P,KAAAuuB,cAIAvuB,KAAAwuB,aAAArkB,KAAAnK,KAAAuuB,aACAvuB,KAAAyuB,wBAKAzuB,KAAAmS,KAAAsG,UAAA1R,EAAAC,EAAAhH,KAAAsuB,aAOA,QAAA5R,GAAA3V,EAAAC,EAAAmnB,GAGA,GAAA7f,GAAAtO,KAAAquB,gBAGA,IAAA/f,IAAAP,EAAAlR,MACAmD,KAAAmS,KAAAuG,YAAA3R,EAAAC,OAIA,CAGA,IAAAmnB,GAAAnuB,KAAAmS,KAAA2G,SAAA/R,EAAAC,EAAAsH,GAEA,WADAtO,MAAAmS,KAAAuG,YAAA3R,EAAAC,EAKAhH,MAAAmS,KAAA2G,SAAA/R,EAAAC,IACAhH,KAAAmS,KAAAuG,YAAA3R,EAAAC,GAIAhH,KAAAmS,KAAAmG,SAAAvR,EAAAC,EAAAsH,GAIAtO,KAAAwC,MAAAM,OAAA2E,OAAAiE,WAAA3E,EAAAC,GAMA,QAAA0nB,KAMA,GAHA1uB,KAAAwuB,gBAGAxuB,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAMA,IAAA,GADA/M,GAAAzH,KAAAmS,KAAA7K,SAAAG,OAAAwC,IAAA,QACAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAiG,EAAAjG,GAAAoO,OAAA5B,EAAAzQ,OAAA,KAAAkK,EAAAjG,GAAAqO,MACA7P,KAAAwuB,aAAArkB,KAAA1C,EAAAjG,GAAAqO,MApOA,GAAAmK,GAAA,IAAAD,WAAA,GACAmP,EAAA,IAAAnP,WAAA,EA2OApe,GAAAgJ,OAAAf,GAGAwqB,UAAAJ,EAAAjxB,MACAuxB,WAAAL,EAAA/wB,SAGAsxB,gBACAD,YAAA,GAKAI,gBAAA,SAAApL,GACAvjB,KAAAouB,UAAA7K,GAMAqL,iBAAA,SAAArL,GACAvjB,KAAAsuB,WAAA/K,EACAvjB,KAAAsuB,aAAAL,EAAAT,MAAAxtB,KAAAsuB,aAAAL,EAAAR,QACAztB,KAAAyuB,wBAOAJ,eAAA,WACA,OAAAruB,KAAAouB,WACA,IAAAJ,GAAAjxB,MACA,MAAAgR,GAAAjR,CACA,KAAAkxB,GAAA/wB,MACA,MAAA8Q,GAAA/Q,CACA,SACA,MAAA+Q,GAAAlR,QAOAgyB,eAAA,SAAApf,GACAA,IACAzP,KAAAuuB,YAAA9e,IAOAgf,qBAAA,WAMA,OAHAzuB,KAAAuuB,YAAA,GAGAvuB,KAAAsuB,YAGA,IAAAL,GAAAT,KAIA,IAHA,GAAAhsB,GAAA,GAGAxB,KAAAuuB,aAAAvuB,KAAAwuB,aAAArrB,QAAAnD,KAAAuuB,mBAGA/sB,EAAA,GACAxB,KAAAuuB,YAAAze,OAAAC,aAAAiK,EAAAxY,GAIAA,EAAA,GACAxB,KAAAuuB,YAAAze,OAAAC,aAAAmZ,EAAA1nB,EAAA,IAKAxB,KAAAuuB,YAAAze,OAAAC,aAAAiK,EAAApZ,KAAAE,MAAAU,EAAA,IAAA,GACAsO,OAAAC,aAAAiK,EAAAxY,EAAA,IAIAA,GAEA,MAGA,KAAAysB,GAAAR,OAIA,IAHAztB,KAAAuuB,YAAA,EAGA,IAAAvuB,KAAAuuB,aAAAvuB,KAAAwuB,aAAArrB,QAAAnD,KAAAuuB,mBACAvuB,KAAAuuB,iBAUA,IAAAb,IAKArF,MAAA,SAAApmB,GAGA,GAAAjC,KAAAwC,MAAA,CAQA,GAHAxC,KAAAwC,MAAA2C,UAAA,UAGAlD,EAAA0iB,MAAA3kB,KAAAujB,OAAAM,EAAA3lB,OAAA8B,KAAAujB,OAAAM,EAAA1lB,OAEA,WADA+vB,GAAAtrB,KAAA5C,KAKA,IAAAA,KAAAsuB,aAAAL,EAAAT,MAAAxtB,KAAAsuB,aAAAL,EAAAR,OAEA,WADAS,GAAAtrB,KAAA5C,KAKA,KAAA,GAAA+G,GAAA9E,EAAA0iB,KAAAwH,MAAAplB,EAAAA,GAAA9E,EAAA0iB,KAAA/M,KAAA7Q,EAAAA,IACA,IAAA,GAAAC,GAAA/E,EAAA0iB,KAAAwH,MAAAnlB,EAAAA,GAAA/E,EAAA0iB,KAAA/M,KAAA5Q,EAAAA,IACAknB,EAAAtrB,KAAA5C,KAAA+G,EAAAC,GAAA,KAQA2kB,QAAA,SAAA1pB,EAAAkrB,GAGAA,EAAAC,SASAW,MAAA,SAAA9rB,GAGA,GAAAjC,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAAA,CASA,OAHAhH,KAAAwC,MAAA2C,UAAA,SAGAnF,KAAAujB,MAGA,IAAAM,GAAA7lB,KAGA,IAAAgC,KAAAmS,KAAA+G,KAAAjX,EAAA8E,EAAA9E,EAAA+E,GACA,MAEAhH,MAAAimB,iBACA,MAGA,KAAApC,GAAA3lB,MAGAwe,EAAA9Z,KAAA5C,KAAAiC,EAAA8E,EAAA9E,EAAA+E,GACAhH,KAAAimB,iBACA,MAGA,KAAApC,GAAA1lB,OAGAwe,EAAA/Z,KAAA5C,KAAAiC,EAAA8E,EAAA9E,EAAA+E,GACAhH,KAAAimB,iBACA,MAGA,KAAApC,GAAA5lB,MAGAihB,EAAA7P,KAAApN,EAAA8E,EAAA9E,EAAA+E,GACAhH,KAAA0mB,YAKAgH,EAAArF,MAAAzlB,KAAA5C,KAAAiC,KAMA6rB,UAAA,SAAA7rB,GAGA,GAAA8E,GAAAC,CASA,QALAhH,KAAAwC,OACAxC,KAAAwC,MAAA2C,UAAA,SAIAnF,KAAAujB,MAGA,IAAAM,GAAA3lB,MAGA,IAAA6I,EAAA9E,EAAA0iB,KAAAwH,MAAAplB,EAAAA,GAAA9E,EAAA0iB,KAAA/M,KAAA7Q,EAAAA,IACA,IAAAC,EAAA/E,EAAA0iB,KAAAwH,MAAAnlB,EAAAA,GAAA/E,EAAA0iB,KAAA/M,KAAA5Q,EAAAA,IACA0V,EAAA9Z,KAAA5C,KAAA+G,EAAAC,GAAA,EAKAhH,MAAAimB,iBACA,MAGA,KAAApC,GAAA1lB,OAGA,GAAA6B,KAAAsuB,aAAAL,EAAAT,MAAAxtB,KAAAsuB,aAAAL,EAAAR,OACA,KAIA,KAAA1mB,EAAA9E,EAAA0iB,KAAAwH,MAAAplB,EAAAA,GAAA9E,EAAA0iB,KAAA/M,KAAA7Q,EAAAA,IACA,IAAAC,EAAA/E,EAAA0iB,KAAAwH,MAAAnlB,EAAAA,GAAA/E,EAAA0iB,KAAA/M,KAAA5Q,EAAAA,IACA2V,EAAA/Z,KAAA5C,KAAA+G,EAAAC,EAKAhH,MAAAimB,kBAKAyH,EAAArF,MAAAzlB,KAAA5C,KAAAiC,IAMA0rB,WAAA,WACAe,EAAA9rB,KAAA5C,OAMA6tB,UAAA,WAGA7tB,KAAAwlB,UACA3B,EAAA7lB,KACA6lB,EAAA3lB,MACA2lB,EAAA1lB,OACA0lB,EAAA5lB,QAIA+B,KAAAujB,KAAAvjB,KAAA6kB,MAAA,GAGA6J,EAAA9rB,KAAA5C,OAMA4tB,WAAA,WAGA5tB,KAAAujB,OAAAM,EAAA5lB,OAGA+B,KAAA8uB,gBAAA9uB,KAAAwC,MAAAkF,WAGAwX,EAAAhL,KAAAlU,KAAAmS,MACAnS,KAAA0mB,aAKA1mB,KAAA8uB,kBACA9uB,KAAAwC,MAAAsF,aAAA9H,KAAA8uB,uBACA9uB,MAAA8uB,kBC7nBA,OAAApB,QAIAhyB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,mCACA,OACA,6BAMA4vB,KAAA,SAAA,cAAA,mBAAA,SAAA7nB,EAAAggB,EAAAmL,GAGAnrB,EAAArB,GAAA,gBAAAwsB,EAAAC,cAAApL,EAAAhmB,QACAgG,EAAArB,GAAA,cAAAwsB,EAAAE,YAAArL,EAAAhmB,QACAgG,EAAArB,GAAA,aAAAwsB,EAAApB,WAAA/J,EAAAhmB,QACAgG,EAAArB,GAAA,aAAAwsB,EAAAnB,WAAAhK,EAAAhmB,QACAgG,EAAArB,GAAA,YAAAwsB,EAAAlB,UAAAjK,EAAAhmB,QACAgG,EAAArB,GAAA,WAAAwsB,EAAAG,SAAAtL,EAAAhmB,QACAgG,EAAArB,GAAA,QAAAwsB,EAAAhB,MAAAnK,EAAAhmB,QACAgG,EAAArB,GAAA,QAAAwsB,EAAA1G,MAAAzE,EAAAhmB,QAGAgG,EAAA0hB,aAAA1B,EAAAhmB,OAAAmxB,MAMAhrB,SAAA,mBAAA,WAKA,GAAAC,IAGAmrB,cAAA,IAMAnvB,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,YAAA,SAAA,cAAA,cAAA,cAAA,aAAA,SAAAwqB,EAAAxrB,EAAAggB,EAAAC,EAAA7V,EAAAkR,GAKA,QAAAgP,GAAAnnB,EAAAC,GASA,GANA,mBAAAD,IAAA,mBAAAC,KACAD,EAAA/G,KAAAosB,MAAAa,MACAjmB,EAAAhH,KAAAosB,MAAAc,OAIAltB,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAAhH,KAAAujB,MAGA,IAAAM,GAAA7lB,MAGAgC,KAAAmS,KAAA2G,SAAA/R,EAAAC,IAAAhH,KAAAmS,KAAAsF,gBAAA1Q,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAjH,KAAAmS,KAAAiF,WAGA,MAGA,KAAAyM,GAAA5lB,MAGA+B,KAAAmS,KAAA2G,SAAA/R,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA3Q,QAUA,QAAAgyB,GAAAC,GACA,IAAA,GAAA9tB,GAAA,EAAAA,EAAA8tB,EAAAntB,OAAAX,IAGAxB,KAAAwC,MAAA2E,IAAA,SAAAmoB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,IAKAhH,KAAAwC,MAAAsE,IAAA,SAAAwoB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,GACA4I,KAAA5P,KAAAwC,MAAA4C,MAAAU,IAAA,yBACA+J,KAAA7P,KAAAwC,MAAA4C,MAAAU,IAAA,wBAAAtE,GACA8M,MAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,4BAQA,QAAAypB,GAAAD,GACA,IAAA,GAAA9tB,GAAA,EAAAA,EAAA8tB,EAAAntB,OAAAX,IACAxB,KAAAwC,MAAA0E,OAAA,SAAAooB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,GAOA,QAAAwoB,GAAA9oB,GAGA,GAAA1G,KAAAwC,OAAAxC,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAAA,CAKA,GACA8a,GADA/c,EAAAvS,KAAAmS,KAAAwD,SAEApD,KAKAvS,KAAAkkB,mBAAA3R,EAAAgJ,sBACA+T,EAAA/c,EAAAkJ,oBACA/U,EACA2oB,EAAAzsB,KAAA5C,KAAAsvB,GAGAC,EAAA3sB,KAAA5C,KAAAsvB,IAKAtvB,KAAAmkB,mBAAA5R,EAAA5Q,QAAA4Q,EAAA5Q,OAAA4Z,sBACA+T,EAAA/c,EAAA5Q,OAAA8Z,oBACA/U,EACA2oB,EAAAzsB,KAAA5C,KAAAsvB,GAGAC,EAAA3sB,KAAA5C,KAAAsvB,MAQA3zB,EAAAgJ,OAAAf,GAGA6rB,aAAA,EACAN,cAAA,IACAO,gBAAA,KAKAC,iBAAA,SAAAC,GACA5vB,KAAAmvB,gBAAAS,IACA5vB,KAAAmvB,cAAAS,EACA5vB,KAAAolB,UAAA,gBAAA,mBAOA+G,MAAA,SAAAyD,GAGA,GAAA5vB,KAAAqjB,OAAAO,EAAAhmB,SAAAoC,KAAAyvB,aAKAzvB,KAAAmS,MAAAnS,KAAAmS,KAAAI,KAAA8I,cAAA,CAKA,GAAAqC,GAAA1d,IAGA4vB,GAAA,gBAAAA,GAAAA,EAAA5vB,KAAAmvB,cAGAnvB,KAAAwjB,WAAAK,EAAA9lB,MAGAiC,KAAAyvB,aAAA,EACAzvB,KAAA0vB,gBAAAN,EAAA,WAGA1R,EAAAvE,KAAA,GAAA,GAGAuE,EAAAvL,KAAAI,KAAA8I,eACAqC,EAAA9F,QAEAgY,GAGA5vB,KAAAolB,UAAA,kBAAAplB,KAAAmS,KAAAI,QAMAqF,KAAA,WAGA5X,KAAAqjB,OAAAO,EAAAhmB,QAAAoC,KAAAyvB,cAKAzvB,KAAA0vB,iBACAN,EAAAS,OAAA7vB,KAAA0vB,iBAIA1vB,KAAA0vB,gBAAA,KACA1vB,KAAAyvB,aAAA,EAGAzvB,KAAAolB,UAAA,kBAAAplB,KAAAmS,KAAAI,SAOA,IAAAwc,IAKA9pB,YAAA,SAAAP,GAGA1E,KAAA0E,OAAA/I,EAAAgJ,UAAA3E,KAAA0E,OAAAV,EAAAU,OAGA1E,KAAA2vB,iBAAA3vB,KAAA0E,OAAAyqB,gBAMAH,cAAA,SAAA/sB,EAAA6tB,GAGA,oBAAAA,GACAN,EAAA5sB,KAAA5C,KAAAA,KAAAikB,kBAOAoE,MAAA,WAGAroB,KAAAwC,QACAxC,KAAAwC,MAAA2C,UAAA,SACA+oB,EAAAtrB,KAAA5C,QAOAivB,YAAA,WAGAjvB,KAAAikB,iBACAuL,EAAA5sB,KAAA5C,MAAA,IAOA+tB,MAAA,SAAA9rB,GAGA,GAAAjC,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAAA,CAKA,OAAAhH,KAAAujB,MAGA,IAAAM,GAAA7lB,KAGAgC,KAAAmS,KAAAsF,gBAAAxV,EAAA8E,EAAA9E,EAAA+E,IACAhH,KAAAmZ,KAAAnZ,KAAAmS,KAAAqE,iBAAAvU,EAAA8E,EAAA9E,EAAA+E,GAEA,MAGA,KAAA6c,GAAA5lB,MAGAihB,EAAA7P,KAAApN,EAAA8E,EAAA9E,EAAA+E,GACAhH,KAAA0mB,YAKAqI,EAAA1G,MAAAzlB,KAAA5C,KAAAiC,KAMA0rB,WAAA,WAGA3tB,KAAAwC,QACAxC,KAAAwC,MAAA2C,UAAA,SACA+oB,EAAAtrB,KAAA5C,QAOA6tB,UAAA,WAGA7tB,KAAAwlB,UACA3B,EAAA7lB,KACA6lB,EAAA5lB,MACA4lB,EAAA9lB,OAIAiC,KAAAujB,KAAAvjB,KAAA6kB,MAAA,GAGA7kB,KAAAikB,iBACAuL,EAAA5sB,KAAA5C,MAAA,IAOAkvB,SAAA,WAGAlvB,KAAAyvB,aACAzvB,KAAA4X,OAIA5X,KAAAikB,iBACAuL,EAAA5sB,KAAA5C,MAAA,IAOA4tB,WAAA,WAGA5tB,KAAAujB,OAAAM,EAAA5lB,OAGA+B,KAAA8uB,gBAAA9uB,KAAAwC,MAAAkF,WAGAwX,EAAAhL,KAAAlU,KAAAmS,MACAnS,KAAA0mB,aAKA1mB,KAAA8uB,kBACA9uB,KAAAwC,MAAAsF,aAAA9H,KAAA8uB,uBACA9uB,MAAA8uB,kBCpaA,OAAAC,QAIArzB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,kCACA,SAMA4vB,KAAA,SAAA,cAAA,kBAAA,SAAA7nB,EAAAggB,EAAAmM,GAGAnsB,EAAArB,GAAA,gBAAAwtB,EAAAf,cAAApL,EAAA9lB,OACA8F,EAAArB,GAAA,cAAAwtB,EAAAd,YAAArL,EAAA9lB,OACA8F,EAAArB,GAAA,aAAAwtB,EAAApC,WAAA/J,EAAA9lB,OACA8F,EAAArB,GAAA,YAAAwtB,EAAAlC,UAAAjK,EAAA9lB,OACA8F,EAAArB,GAAA,WAAAwtB,EAAAb,SAAAtL,EAAA9lB,OACA8F,EAAArB,GAAA,UAAAwtB,EAAApE,QAAA/H,EAAA9lB,OACA8F,EAAArB,GAAA,QAAAwtB,EAAAhC,MAAAnK,EAAA9lB,OACA8F,EAAArB,GAAA,QAAAwtB,EAAA1H,MAAAzE,EAAA9lB,OAGA8F,EAAA0hB,aAAA1B,EAAA9lB,MAAAiyB,MAMAhsB,SAAA,mBAAA,aAAA,SAAAgK,GAKA,GAAA/J,IAGAgsB,YAAAjiB,EAAAjR,EAGAmzB,eAAA,EAGAC,eAAA,EACAC,mBAAA,IAMAnwB,MAAAyE,UAAA,SAAAC,GACAV,EAAArI,EAAAgJ,OAAAX,EAAAU,IAMA1E,KAAA4E,MAAA,WAAA,SAAA,cAAA,cAAA,WAAA,SAAAwrB,EAAAxsB,EAAAggB,EAAAC,EAAAoI,GAKA,QAAAoE,KAKA,OAAArwB,KAAAkwB,kBAKAlwB,KAAAswB,kBAKAtwB,KAAAuwB,gBAKAvwB,KAAAmS,KAAAiF,YAAApX,KAAAgwB,cAWA,QAAA9B,GAAAnnB,EAAAC,GASA,GANA,mBAAAD,IAAA,mBAAAC,KACAD,EAAA/G,KAAAosB,MAAAa,MACAjmB,EAAAhH,KAAAosB,MAAAc,OAIAltB,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAAhH,KAAAujB,MAGA,IAAAM,GAAA7lB,KAGAqyB,EAAAztB,KAAA5C,OAAAA,KAAAmS,KAAA0F,YAAA9Q,EAAAC,IACAhH,KAAAwC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAjH,KAAAmS,KAAAiF,aAUA,QAAAoZ,GAAAlB,GACA,IAAA,GAAA9tB,GAAA,EAAAA,EAAA8tB,EAAAntB,OAAAX,IACA8tB,EAAA9tB,GAAAwO,YAAA,EACAhQ,KAAAwC,MAAAsE,IAAA,SAAAwoB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,GACA4I,KAAA5P,KAAAwC,MAAA4C,MAAAU,IAAA,8BACA+J,KAAA7P,KAAAwC,MAAA4C,MAAAU,IAAA,6BAAAtE,GACA3B,MAAAG,KAAAwC,MAAA4C,MAAAU,IAAA,+BACAwI,MAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,iCAIA9F,KAAAwC,MAAAsE,IAAA,SAAAwoB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,GACA4I,KAAA5P,KAAAwC,MAAA4C,MAAAU,IAAA,gCACA+J,KAAA7P,KAAAwC,MAAA4C,MAAAU,IAAA,+BAAAtE,GACA3B,MAAAG,KAAAwC,MAAA4C,MAAAU,IAAA,iCACAwI,MAAAtO,KAAAwC,MAAA4C,MAAAU,IAAA,mCASA,QAAA2qB,GAAAnB,GACA,IAAA,GAAA9tB,GAAA,EAAAA,EAAA8tB,EAAAntB,OAAAX,IACAxB,KAAAwC,MAAA0E,OAAA,SAAAooB,EAAA9tB,GAAAiS,KAAA1M,EAAAuoB,EAAA9tB,GAAAiS,KAAAzM,GAOA,QAAA0pB,GAAAhqB,GAGA,GAAA1G,KAAAwC,OAAAxC,KAAAmS,MAAAnS,KAAAmS,KAAAqC,WAAA,CAKA,GAAAjC,GAAAvS,KAAAmS,KAAAwD,UACA2Z,EAAA/c,EAAAkJ,mBAGA,OAAA/U,KAAA1G,KAAAswB,eAAAtwB,KAAAkwB,eACAlwB,KAAAmS,KAAAiF,YAAApX,KAAAgwB,gBACAS,GAAA7tB,KAAA5C,KAAAsvB,QAMA5oB,EACA8pB,EAAA5tB,KAAA5C,KAAAsvB,GAGAmB,EAAA7tB,KAAA5C,KAAAsvB,KAOA3zB,EAAAgJ,OAAAf,GAGA0sB,eAAA,EACAC,gBAAA,EAGAI,iBAAA,KAGAX,YAAA,EAGAC,eAAA,EAGAC,eAAA,EACAC,mBAAA,IAGAS,wBAAA,EAKAC,iBAAA,SAAAC,GACA9wB,KAAAkwB,gBAAAY,IACA9wB,KAAAkwB,cAAAY,EACA9wB,KAAAolB,UAAA,gBAAA,mBAOA2L,sBAAA,SAAAnB,GACA5vB,KAAAmwB,qBAAAP,IACA5vB,KAAAmwB,mBAAAP,EACA5vB,KAAAolB,UAAA,gBAAA,wBAOA4L,eAAA,SAAA1iB,GACAtO,KAAAgwB,cAAA1hB,IACAtO,KAAAgwB,YAAA1hB,EACAtO,KAAAolB,UAAA,gBAAA,iBAOA6L,eAAA,SAAAC,GACA,MAAAA,IAAAlxB,KAAAwC,MACAxC,KAAAwC,MAAAgC,gBAAAxE,KAAAgwB,YAEAhwB,KAAAgwB;EAMAtM,oBAAA,SAAAuM,GAGA,mBAAAA,KACAA,GAAAjwB,KAAAiwB,eAIAA,IAAAjwB,KAAAiwB,gBACAjwB,KAAAiwB,cAAAA,EACAjwB,KAAAolB,UAAA,gBAAA,mBAOA+L,aAAA,SAAAC,GAGA,GAAApxB,KAAAmS,MAAAnS,KAAAmS,KAAAqC,YAAA,IAAAxU,KAAAmS,KAAAI,KAAAC,SAAArQ,OAAA,CAKA,GAEAX,GAFAgR,KACAkL,EAAA1d,IAIA,KAAAwB,EAAA,EAAAA,EAAAxB,KAAAmS,KAAAI,KAAAC,SAAArQ,OAAAX,IACAxB,KAAAmS,KAAAI,KAAAC,SAAAhR,GAAAwO,UACAwC,EAAArI,KAAAnK,KAAAmS,KAAAI,KAAAC,SAAAhR,GAaA,IARA,IAAAgR,EAAArQ,SACAqQ,EAAAxS,KAAAmS,KAAAI,KAAAC,UAIAhR,EAAAZ,KAAAE,MAAAF,KAAAwqB,SAAA5Y,EAAArQ,QAGAivB,IAAApxB,KAAAmwB,mBAEA,WADAnwB,MAAAmZ,KAAA3G,EAAAhR,GAKAxB,MAAA4wB,wBAAA,EACAR,EAAA,WAGA1S,EAAAvE,KAAA3G,EAAAhR,IACAkc,EAAAkT,wBAAA,GAEA5wB,KAAAmwB,sBAMAkB,MAAA,WAGA,SAAArxB,KAAAmS,OAAAnS,KAAAmS,KAAAqC,cAKAxU,KAAAswB,eAAA,EACAtwB,KAAAuwB,gBAAA,EAGAvwB,KAAA2wB,iBAAA3wB,KAAAmS,KAAAuE,SAAA,GAGA1W,KAAAomB,oBAGApmB,KAAAkwB,eAAAlwB,KAAAmS,KAAAiF,YAAApX,KAAAgwB,aACAhwB,KAAAmxB,kBAOAG,eAAA,WAGAtxB,KAAAqjB,OAAAO,EAAA9lB,OAAAkC,KAAAmS,MAAAnS,KAAAmS,KAAAqC,aAKAxU,KAAAswB,eAAA,EACAtwB,KAAAuwB,gBAAA,EAGAvwB,KAAA2wB,kBACA3wB,KAAAA,QAAAA,KAAA2wB,kBAIA3wB,KAAAkwB,eAAAlwB,KAAAmS,KAAAiF,YAAApX,KAAAgwB,aACAhwB,KAAAmxB,kBAQA,IAAApB,IAKA9qB,YAAA,SAAAP,GAGA1E,KAAA0E,OAAA/I,EAAAgJ,UAAA3E,KAAA0E,OAAAV,EAAAU,OAGA1E,KAAA0jB,oBAAA1jB,KAAA0E,OAAAurB,eACAjwB,KAAAgxB,eAAAhxB,KAAA0E,OAAAsrB,aACAhwB,KAAA6wB,iBAAA7wB,KAAA0E,OAAAwrB,eACAlwB,KAAA+wB,sBAAA/wB,KAAA0E,OAAAyrB,qBAMAnB,cAAA,SAAA/sB,EAAA6tB,GAGA,kBAAAA,GACAY,EAAA9tB,KAAA5C,KAAAA,KAAAiwB,eAIA,gBAAAH,IAGAY,EAAA9tB,KAAA5C,KAAAA,KAAAiwB,gBAIAjwB,KAAAswB,eAAAtwB,KAAAkwB,eAAAlwB,KAAAmS,KAAAiF,YAAApX,KAAAgwB,aAEAhwB,KAAAmxB,cAAA,KAQA9I,MAAA,SAAApmB,GAGAjC,KAAAwC,QACAxC,KAAAwC,MAAA2C,UAAA,SACA+oB,EAAAtrB,KAAA5C,KAAAiC,EAAA8E,EAAA9E,EAAA+E,KAOAioB,YAAA,WAGAjvB,KAAAiwB,eACAS,EAAA9tB,KAAA5C,MAAA,IAOA2rB,QAAA,SAAA1pB,EAAAkrB,GAGA,OAAAA,EAAAC,SAGA,IAAAnB,GAAA5tB,MAGA2B,KAAA8jB,sBACAqJ,EAAAE,iBAGArtB,KAAA4wB,wBAAA5wB,KAAAmS,KAAAI,OAAAvS,KAAA+kB,iBAGA/kB,KAAAswB,eACAtwB,KAAAmZ,OAIA,MAGA,KAAA8S,GAAA7tB,KAGA4B,KAAA8jB,sBACAqJ,EAAAE,iBAGArtB,KAAA4wB,wBAAA5wB,KAAAmS,KAAAI,OAAAvS,KAAA8kB,oBAGA9kB,KAAAoZ,YAKApZ,KAAAswB,eAAAtwB,KAAAkwB,eACAlwB,KAAAmS,KAAAiF,aAAApX,KAAAgwB,aAEAhwB,KAAAoZ,eAWA2U,MAAA,SAAA9rB,GAGA,GAAAjC,KAAAwC,OAAAxC,KAAAwC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAKA,GAAAhH,KAAAmS,KAAAsF,gBAAAxV,EAAA8E,EAAA9E,EAAA+E,GAAA,CAGA,GAAAxF,GAAAxB,KAAAmS,KAAAqE,iBAAAvU,EAAA8E,EAAA9E,EAAA+E,EAGAhH,MAAAmZ,KAAA3X,EACA,IAAA+Q,GAAAvS,KAAAmS,KAAAwD,SAGA,KAAApD,EAAAC,SAAArQ,OACAoQ,EAAAvC,YAAA,GACAhQ,KAAAswB,eAAA,EACAtwB,KAAAolB,UAAA,gBAAA7S,IAGAvS,KAAAolB,UAAA,gBAAA7S,IAKAvS,KAAAswB,eAAAtwB,KAAAkwB,eACAlwB,KAAAmxB,mBAKAnxB,MAAAmS,KAAA+G,KAAAjX,EAAA8E,EAAA9E,EAAA+E,KACAhH,KAAAuwB,gBAAA,EACAvwB,KAAAimB,kBACAjmB,KAAAolB,UAAA,kBAAAplB,KAAAmS,KAAAwD,aAOAgY,WAAA,WAGA3tB,KAAAwC,QACAxC,KAAAwC,MAAA2C,UAAA,SACA+oB,EAAAtrB,KAAA5C,QAOA6tB,UAAA,WAGA7tB,KAAAwlB,UACA3B,EAAA7lB,OAIAgC,KAAAujB,KAAAvjB,KAAA6kB,MAAA,GAGA7kB,KAAAiwB,eACAS,EAAA9tB,KAAA5C,MAAA,IAOAkvB,SAAA,WAGAlvB,KAAAiwB,eACAS,EAAA9tB,KAAA5C,MAAA,ICzkBA,OAAA+vB,SAIAr0B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,qCACA,OACA,4BAMAsN,QAAA,WAAA,OAAA,YAAA,SAAAsI,EAAAK,GAeA,QAAAyf,GAAApd,EAAAqd,GAGA,mBAAArd,GAAAhC,KAAA4N,UACA5L,EAAAhC,KAAA4N,WAcA,KAAA,GAVAzR,GAAA,UAAAkjB,EAAA,GAAA7rB,cAAA,QAAA,QAGA8rB,GACAnjB,MAAAA,EACAvS,KAAAy1B,EAAA,GACAE,KAAAF,EAAA,GAAAtuB,eAIAyR,EAAA,EAAAA,EAAAR,EAAAhC,KAAA4N,QAAA5d,OAAAwS,IACA,GAAAR,EAAAhC,KAAA4N,QAAApL,GAAArG,QAAAA,EAEA,YADA6F,EAAAhC,KAAA4N,QAAApL,GAAA8c,EAMAtd,GAAAhC,KAAA4N,QAAA5V,KAAAsnB,GAMA,QAAAE,GAAAxd,EAAAqd,GACArd,EAAAhC,KAAAC,KAAA4E,WAAAwa,EAAA,GAAA,IAMA,QAAAI,GAAAzd,EAAAqd,GAGA,mBAAArd,GAAAhC,KAAA0f,QACA1d,EAAAhC,KAAA0f,UAIA1d,EAAAhC,KAAA0f,MAAA1nB,KAAAqnB,EAAA,GAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,IAMA,QAAAM,GAAA3d,EAAAqd,GAGA,GAAAO,GAAA,UAAAP,EAAA,GAAAtuB,cAAA,IAAA,GACA6uB,IAAA,IAIAA,GADAP,EAAA,GAAAA,MAAA,QACA,IAEAA,EAAA,GAAAA,MAAA,SACA,IAGAA,EAAA,GAIArd,EAAAhC,KAAA4f,OAAAA,EAMA,QAAAC,GAAA7d,EAAA5B,EAAAif,GAGA,GAAAljB,GAAAkjB,EAAA,EACA,IAAA,IAAAljB,EACAA,EAAA,QAEA,CAAA,GAAA,IAAAA,EAIA,MAHAA,GAAA,IAOAiE,EAAAkB,QASAlB,EAAAkB,KAAAnF,IAAA,EAAAkjB,EAAA,GAAA,EAAAA,EAAA,IA/GA,GAAAS,GAAA,gDACAC,EAAA,0DACAC,EAAA,wBACAC,EAAA,6CACAC,EAAA,gDACAC,EAAA,yDAiHAC,GAKArP,MAAA,SAAAlO,EAAAiO,GAGA,GAGAuO,GAHArd,EAAArC,EAAAqC,MAIA8H,EAAA9H,EAAAkB,KAKA9C,GAAAO,MAAA,EAIA,KAHAmJ,EAAA9R,KAAAoI,GAGAif,EAAAU,EAAAM,KAAAxd,IACAuc,EAAApd,EAAAqd,EAmBA,MAfAA,EAAAW,EAAAK,KAAAxd,KACA2c,EAAAxd,EAAAqd,IAIAA,EAAAY,EAAAI,KAAAxd,KACA4c,EAAAzd,EAAAqd,KAIAA,EAAAa,EAAAG,KAAAxd,MAAAwc,EAAAc,EAAAE,KAAAxd,MACA8c,EAAA3d,EAAAqd,GAIAA,EAAAS,EAAAO,KAAAxd,IAGAzC,KAGAyf,EAAA7d,EAAA5B,EAAAif,GAGAvV,EAAA9R,KAAAoI,EAIA,OAAA0Q,GACAtnB,EAAA+Z,OAAAvB,GAIAA,GC7MA,OAAAoe,OAGA72B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,qCACA,OACA,4BAMAsN,QAAA,WAAA,OAAA,aAAA,WAAA,YAAA,SAAAsI,EAAAghB,EAAAC,EAAA5gB,GAoBA,QAAA+H,GAAAC,GACA,MAAAhK,QAAAC,aAAAiK,EAAAF,EAAA,IAAAhK,OAAAC,aAAAiK,EAAAF,EAAA,IAUA,QAAA6Y,GAAA9iB,GACA,MAAA,gBAAAA,GACAA,EAAA+iB,QAAA,MAAA,QAAAA,QAAA,KAAA,OAEA/iB,EAMA,QAAAgjB,GAAA/hB,EAAAgiB,EAAAC,EAAAC,GACA,GAAAF,EAAA3wB,OAAA,CACA4wB,EAAA7d,KAAApE,CACA,KAAA,GAAAtP,GAAA,EAAAA,EAAAsxB,EAAA3wB,OAAAX,IACAuxB,EAAA7d,KAAA,KAAA8d,EAAAL,EAAAG,EAAAtxB,IAAAsxB,EAAAtxB,IAAA,KAQA,QAAAwwB,GAAAve,EAAAsf,GAGA,GAAAzkB,GAAAmF,EAAA3W,EAAA,IAAA2W,EAAAzW,EAAA,IAAA,EACA,IAAA,KAAAsR,EAAA,CAKA,GAAAwL,GAAA,SAAArG,EAAAnF,GAAA,GAAAmF,EAAAnF,EAGAykB,GAAA7d,KAAA5G,EAAA,IAAAuL,EAAAC,GAAA,KAMA,QAAAmZ,GAAApf,EAAAkf,GAGA,IAAA,GAAAzkB,KAAAuF,GACA,GAAAA,EAAAtN,eAAA+H,GAAA,CAGA,IAAA,GAAA9M,GAAA,EAAAA,EAAAqS,EAAAvF,GAAAnM,OAAAX,IACAqS,EAAAvF,GAAA9M,GAAAqY,EAAAhG,EAAAvF,GAAA9M,GAIAqxB,GAAA,IAAAvkB,EAAAuF,EAAAvF,GAAAykB,IAQA,QAAAG,GAAA/T,EAAA4T,GAGA,IAAA,GAAAzkB,KAAA6Q,GACA,GAAAA,EAAA5Y,eAAA+H,GAAA,CAGA,IAAA,GAAA9M,GAAA,EAAAA,EAAA2d,EAAA7Q,GAAAnM,OAAAX,IACA2d,EAAA7Q,GAAA9M,GAAAqY,EAAAsF,EAAA7Q,GAAA9M,GAIAqxB,GAAA,IAAAvkB,EAAA6Q,EAAA7Q,GAAAykB,IAQA,QAAAI,GAAA1rB,EAAAsrB,GAGA,IAAA,GAAAnjB,KAAAnI,GACA,GAAAA,EAAAlB,eAAAqJ,GAAA,CACA,GAAApO,EAGA,IAAA,UAAAoO,EACA,IAAApO,EAAA,EAAAA,EAAAiG,EAAAmI,GAAAzN,OAAAX,IACAiG,EAAAmI,GAAApO,GAAAqY,EAAApS,EAAAmI,GAAApO,IAAA,IAAAiG,EAAAmI,GAAApO,GAAA,OAIA,KAAAA,EAAA,EAAAA,EAAAiG,EAAAmI,GAAAzN,OAAAX,IACAiG,EAAAmI,GAAApO,GAAAqY,EAAApS,EAAAmI,GAAApO,GAKA,oBAAA4xB,GAAAxjB,KACAA,EAAAwjB,EAAAxjB,IAIAijB,EAAAjjB,EAAAnI,EAAAmI,GAAAmjB,IAQA,QAAAM,GAAAzf,EAAAmf,GACAA,EAAA7d,KAAA,MAAAtB,EAAA,IAMA,QAAA0f,GAAA5X,EAAAqX,GAOA,IAAA,GAJAvb,GAAA,mBAAA4b,GAAA1X,SAAA0X,EAAA1X,SAAA,IAGA6X,KACApmB,EAAA,EAAAA,EAAAuO,EAAAvZ,OAAAgL,IACA,gBAAAuO,GAAAvO,GACAomB,EAAAppB,KAAAuR,EAAAvO,IAEAuO,EAAAvO,GAAAqmB,SACAD,EAAAppB,KAAAuR,EAAAvO,GAAAqmB,QAKAX,GAAArb,EAAA+b,EAAAR,GAAA,GAMA,QAAAU,GAAA5c,EAAAkc,GACA,GAAAvb,GAAA,mBAAA4b,GAAAr3B,KAAAq3B,EAAAr3B,KAAA,GACAg3B,GAAA7d,KAAAsC,EAAA,IAAAmb,EAAA9b,GAAA,IAMA,QAAA6c,GAAAvhB,GAGA,IAAA,GAAA3Q,KAAAkxB,GACA,GAAAA,EAAAnsB,eAAA/E,IAAAkxB,EAAAlxB,KAAA2Q,EACA,MAAA3Q,EAKA,OAAA,GAMA,QAAAmyB,GAAA9T,GACA,GAAA+T,GAAA/T,EAAAzc,MAAA,KACA,OAAAwwB,GAAAzxB,OAAA,EACAyxB,EAAA,GAAA,IAAAA,EAAA,GAEA/T,EAMA,QAAA0R,GAAAE,EAAAoC,GAGA,GAAAC,GAAA,CACArC,GAAAxN,kBACA6P,GAAA,GAEArC,EAAAtN,oBACA2P,GAAA,GAIAD,EAAAE,GAAAD,EAMA,QAAAE,GAAAxxB,EAAAqxB,GAGArxB,EAAAzC,OAAAyC,EAAAtC,OAGAsC,EAAAzC,QAAAyC,EAAAtC,OACA2zB,EAAAxT,GAAA7d,EAAAzC,MAMA8zB,EAAAxT,GAAA7d,EAAAzC,MAAA,IAAAyC,EAAAtC,OAKAsC,EAAAzC,MACA8zB,EAAAxT,GAAA7d,EAAAzC,MAEAyC,EAAAtC,OACA2zB,EAAAxT,GAAA7d,EAAAtC,OAKA2zB,EAAAxT,GAAA,GAOA,QAAA4T,GAAAlU,EAAA8T,GAGA,IAAA,GAAAlf,GAAA,EAAAA,EAAAoL,EAAA5d,OAAAwS,IAGA,GAAAoL,EAAApL,GAAArG,QAAA,UAAAyR,EAAApL,GAAArG,OAAA,UAAAyR,EAAApL,GAAArG,OAAA,CAKA,GAAAA,GAAA,UAAAyR,EAAApL,GAAArG,MAAA,IAAA,GAGAyR,GAAApL,GAAA5Y,OACA83B,EAAA,IAAAvlB,GAAAyR,EAAApL,GAAA5Y,MAIAgkB,EAAApL,GAAA+c,OACAmC,EAAAvlB,EAAA,KAAAyR,EAAApL,GAAA+c,MAIA3R,EAAApL,GAAAuf,OACAL,EAAAvlB,EAAA,KAAAyR,EAAApL,GAAAuf,OAkCA,QAAAC,GAAA9e,EAAA0d,GAGA,IAAA,GAAAvxB,GAAA,EAAAA,EAAA6T,EAAAlT,OAAAX,IAAA,CACA,GAAA+Q,GAAA8C,EAAA7T,EAGA,IAAA7F,EAAAyK,QAAAmM,GACA,IAAA,GAAAnH,GAAA,EAAAA,EAAAmH,EAAApQ,OAAAiJ,IACA2nB,EAAA7d,KAAA,OACAif,EAAA5hB,EAAAnH,GAAA2nB,GACAA,EAAA7d,KAAA,UAJA,CAYA,IAAA,GAAAsC,KAAAjF,GACA,GAAAA,EAAAhM,eAAAiR,GAAA,CAGA,GAAA,mBAAA4c,GAAA5c,GAAA,CACA4c,EAAA5c,GAAAjF,EAAAiF,GAAAub,EACA,UAIA,GAAA,gBAAAxgB,GAAAiF,GACA,QAIAub,GAAA7d,KAAAsC,EAAA,IAAAmb,EAAApgB,EAAAiF,IAAA,IAKAhW,EAAA,EAAA6T,EAAAlT,SACA4wB,EAAA7d,KAAA,SAQA,QAAAmf,GAAAlgB,EAAA0f,EAAArc,GAGA,mBAAAA,KACAA,EAAA,GAIA,KAAA,GAAA8c,KAAAngB,GACA,GAAAA,EAAA5N,eAAA+tB,GAAA,CAGA,GAAA,QAAAA,EACA,QAIA,IAAAC,GAAA,KAAA/c,EAAA8c,EAAA9c,EAAA,IAAA8c,CAGA,IAAA,gBAAAngB,GAAAmgB,GAAA,CAGA,mBAAAF,GAAAG,GACAH,EAAAG,GAAApgB,EAAAmgB,GAAAT,GAKAQ,EAAAlgB,EAAAmgB,GAAAT,EAAAU,EAEA,UAIA,GAAAttB,EACA,oBAAAmsB,GAAAmB,KAIAttB,EADA,mBAAAmtB,GAAAG,GACAH,EAAAG,GAAApgB,EAAAmgB,IAGA3B,EAAAxe,EAAAmgB,IAIAT,EAAAT,EAAAmB,IAAAttB,IA1ZA,GAAAmsB,KACA,KAAA,GAAAoB,KAAA/B,GACAA,EAAAlsB,eAAAiuB,KACApB,EAAAX,EAAA+B,IAAAA,EAOA,IAAAxa,GAAA,IAAAD,WAAA,GAuRAqa,GAGA3gB,KAAAue,EACAne,MAAAof,EACA9T,MAAA+T,EACAzrB,OAAA0rB,EACAvf,KAAAyf,EACA3X,SAAA4X,EACAv3B,KAAA03B,EAGAgB,qBAAAd,EACAlC,OAAAF,EACA/uB,MAAAwxB,EACAU,YAAAhB,EACAiB,eAAAV,GAkHA1B,GAKArP,MAAA,SAAA/O,GAQA,GALA,gBAAAA,KACAA,EAAAxY,EAAAyZ,SAAAjB,KAIAA,EAAAkB,KAEA,WADA1K,SAAA1O,MAAA,8BAKA,IAAA82B,IAAA7d,IAAA,QACApC,EAAAnX,EAAA6O,KAAA2J,GACA0f,EAAA/hB,EAAAoD,KAKAf,GAAAkB,MAAAlB,EAAAkB,KAAAlT,OAAA,GAAAgS,EAAAkB,KAAA,GAAAvC,OACAA,EAAAnX,EAAAgJ,OAAAmO,EAAAqB,EAAAkB,KAAA,UACAvC,GAAAA,WACAqB,GAAAkB,KAAA,UAIAvC,GAAAuC,KACAgf,EAAAvhB,EAAA+gB,EAGA,KAAA,GAAArc,KAAAqc,GACAA,EAAArc,KACAub,EAAA7d,KAAAsC,EAAA,IAAAmb,EAAAkB,EAAArc,IAAA,IASA,OAJA2c,GAAAhgB,EAAAkB,KAAA0d,GAGAA,EAAA7d,KAAA,IACA6d,EAAA7d,KC9eA,OAAAqd,OAGA72B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,qCACA,OACA,4BAMAsN,QAAA,WAAA,OAAA,aAAA,WAAA,YAAA,SAAAsI,EAAAghB,EAAAC,EAAA5gB,GAkBA,QAAA+H,GAAAC,GACA,OAAAA,EAAAC,WAAA,GAAAC,EAAAF,EAAAC,WAAA,GAAAC,GAUA,QAAA4a,GAAAzgB,EAAA5B,EAAAiF,EAAAvQ,GACA,IAAAkN,EAAAyL,OAAAC,YAAA,CACA,GAAAgV,GAAA5tB,EAAA,GAAA7D,MAAA,IACAyxB,GAAA1yB,OAAA,EACAgS,EAAAyL,OAAAC,YAAAgV,EAAA,GAAA,KAAAA,EAAA,GAGA1gB,EAAAyL,OAAAC,YAAAgV,EAAA,IAQA,QAAAC,MAOA,QAAApB,GAAAvf,EAAA5B,EAAAiF,EAAAvQ,GACA,GAAAkL,GAAAlL,EAAA,EACA,oBAAAyrB,GAAAvgB,GACAgC,EAAAhC,KAAAvC,KAAA8iB,EAAAvgB,GAGAgC,EAAAhC,KAAAvC,KAAA3I,EAAA,GAOA,QAAA+qB,GAAA7d,EAAA5B,EAAAiF,EAAAvQ,GAGAsL,EAAAkB,QAGA,KAAAxM,EAAA,IAAAkN,EAAApU,OAAA,IAAA,OAAAkH,EAAA,GACAsL,EAAAkB,KAAA+D,GAAA,OAKAjF,EAAAkB,KAAA+D,GAAAqC,EAAA5S,EAAA,IAOA,QAAA8tB,GAAA5gB,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAwrB,GAAAjb,KACAA,EAAAib,EAAAjb,IAIAjF,EAAAiF,GAAAvQ,EAMA,QAAAwsB,GAAAtf,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAwrB,GAAAjb,KACAA,EAAAib,EAAAjb,IAIAjF,EAAAiF,GAAAvQ,EAAA,GAMA,QAAAgsB,GAAA9e,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAsL,GAAAsB,QACAtB,EAAAsB,UAIA2D,EAAAA,EAAA5C,OAAA,GAGA,mBAAArC,GAAAsB,MAAA2D,KACAjF,EAAAsB,MAAA2D,MAIA,KAAA,GAAAhW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACA+Q,EAAAsB,MAAA2D,GAAArN,KAAA0P,EAAA5S,EAAAzF,KAOA,QAAA0xB,GAAA/e,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAsL,GAAA4M,QACA5M,EAAA4M,OACAriB,KACAE,OAKAwa,EAAAA,EAAA5C,OAAA,EAGA,KAAA,GAAApT,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACA+Q,EAAA4M,MAAA3H,GAAArN,KAAA0P,EAAA5S,EAAAzF,KAOA,QAAA6xB,GAAAlf,EAAA5B,EAAAiF,EAAAvQ,GACAsL,EAAAqB,KAAA3M,EAAA,GAMA,QAAA+tB,GAAA7gB,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAwrB,GAAAjb,KACAA,EAAAib,EAAAjb,IAIA,mBAAAjF,GAAA9K,SACA8K,EAAA9K,WAIA,mBAAA8K,GAAA9K,OAAA+P,KACAjF,EAAA9K,OAAA+P,MAIA,KAAA,GAAAhW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IAAA,CAGA,GAAAsY,GAAAD,EAAA5S,EAAAzF,GAAAoE,OAAA,EAAA,GACAkU,GAAA3P,KAAAlD,EAAAzF,GAAAoE,OAAA,IAGA2M,EAAA9K,OAAA+P,GAAArN,KAAA2P,IAOA,QAAAqZ,GAAAhf,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAwrB,GAAAjb,KACAA,EAAAib,EAAAjb,IAIA,mBAAAjF,GAAA9K,SACA8K,EAAA9K,WAIA,mBAAA8K,GAAA9K,OAAA+P,KACAjF,EAAA9K,OAAA+P,MAIA,KAAA,GAAAhW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACA+Q,EAAA9K,OAAA+P,GAAArN,KAAA0P,EAAA5S,EAAAzF,KAOA,QAAAyzB,GAAA9gB,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAkN,GAAA3R,QACA2R,EAAA3R,SAIA,IAAAS,GAAAgE,EAAA,GAAA7D,MAAA,IACAH,GAAAd,OAAA,GACAgS,EAAA3R,MAAAzC,MAAAyG,SAAAvD,EAAA,IACAkR,EAAA3R,MAAAtC,OAAAsG,SAAAvD,EAAA,KAGAkR,EAAA3R,MAAAzC,MAAAoU,EAAA3R,MAAAtC,OAAAsG,SAAAvD,EAAA,IAOA,QAAA2uB,GAAAzd,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAkN,GAAAhC,KAAA0f,QACA1d,EAAAhC,KAAA0f,SAKA,KAAA,GADAA,GAAA5qB,EAAA,GAAA7D,MAAA,KACA8xB,EAAA,EAAAA,EAAArD,EAAA1vB,OAAA+yB,IACA/gB,EAAAhC,KAAA0f,MAAA1nB,KAAA0nB,EAAAqD,IAOA,QAAAvD,GAAAxd,EAAA5B,EAAAiF,EAAAvQ,GACAkN,EAAAhC,KAAAC,KAAA4E,WAAA/P,EAAA,IAMA,QAAAkuB,GAAAhhB,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAkN,GAAAsd,SACAtd,EAAAsd,WAIAtd,EAAAsd,OAAAxN,iBAAA,EACA9P,EAAAsd,OAAAvN,mBAAA,EACA/P,EAAAsd,OAAAtN,mBAAA,CAGA,IAAA2P,GAAAttB,SAAAS,EAAA,GAGA,QAAA6sB,GACA,IAAA,GACA3f,EAAAsd,OAAAxN,iBAAA,EACA9P,EAAAsd,OAAAvN,mBAAA,CACA,MACA,KAAA,GACA/P,EAAAsd,OAAAxN,iBAAA,EACA9P,EAAAsd,OAAAtN,mBAAA,CACA,MACA,KAAA,GACAhQ,EAAAsd,OAAAvN,mBAAA,CACA,MACA,KAAA,GACA/P,EAAAsd,OAAAtN,mBAAA,GAQA,QAAAoN,GAAApd,EAAA5B,EAAAiF,EAAAvQ,GAGA,mBAAAkN,GAAAhC,KAAA4N,UACA5L,EAAAhC,KAAA4N,WAIA,IAAAzR,GAAA,OAAAkJ,GAAA,OAAAA,GAAA,OAAAA,EAAA,QAAA,OAGA,oBAAAib,GAAAjb,KACAA,EAAAib,EAAAjb,GAIA,KAAA,GAAA7C,GAAA,EAAAA,EAAAR,EAAAhC,KAAA4N,QAAA5d,OAAAwS,IACA,GAAAR,EAAAhC,KAAA4N,QAAApL,GAAArG,QAAAA,EAEA,YADA6F,EAAAhC,KAAA4N,QAAApL,GAAA6C,GAAAvQ,EAAA,GAMA,IAAAwqB,IAAAnjB,MAAAA,EACAmjB,GAAAja,GAAAvQ,EAAA,GACAkN,EAAAhC,KAAA4N,QAAA5V,KAAAsnB,GAkEA,QAAA2D,GAAAjhB,EAAA7M,EAAAL,GAGA,GAAA,gBAAAK,GAAA,CASA,IAAA,GAHAkQ,GADAjF,EAAA4B,EAIAQ,EAAA,EAAAA,EAAArN,EAAAnF,SAGAqV,EAAAlQ,EAAAqN,GAGAA,EAAA,IAAArN,EAAAnF,QANAwS,IAWA,gBAAApC,GAAAiF,KACAjF,EAAAiF,OAIAjF,EAAAA,EAAAiF,EAIAjF,GAAAiF,GAAAvQ,GAvaA,GAAAouB,GAAA,2DACAC,EAAA,4CACAC,EAAA,SACAC,EAAA,gCAKAxb,EAAA,IAAAD,WAAA,GAmUAqa,GAGAnU,GAAA2U,EACAzU,GAAA2U,EACA1U,GAAAsT,EACArT,GAAA4U,EACAlU,GAAA4Q,EACAtQ,GAAAuQ,EAGAmC,GAAAoB,EAGA7U,GAAAiR,EACAhR,GAAAgR,EACA5P,GAAA4P,EACA3P,GAAA2P,EACA1P,GAAA0P,EACAzP,GAAAyP,EAGAz0B,EAAAk1B,EACAh1B,EAAAg1B,EAGAhQ,EAAA+S,EACAhT,EAAA0R,EAGAgC,GAAAxC,EACAyC,GAAAzC,EACA0C,GAAA1C,EACA2C,GAAAvC,EACAwC,GAAA3C,EACA4C,GAAA5C,EAGAjR,GAAAkR,EACAhR,GAAAgR,EACAjR,GAAAiR,EACA/Q,GAAA+Q,EACA9Q,GAAA8Q,EACA7Q,GAAA0S,GAMAe,GACA,IAAA,IAAA,IAAA,IAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,MAgDAxD,GAKArP,MAAA,SAAAhO,EAAA+N,GAGA,GAAA9O,GAAArC,EAAAqC,KAAAyL,QAAA1K,UAGA8gB,KACA/Z,EAAA9H,EAAAkB,KAKA9C,GAAAO,MAAA,EACAmJ,GAAA9R,KAAAoI,EAMA,KAAA,GAHA0jB,GAAA/gB,EAAAsc,MAAA6D,GAGA7zB,EAAA,EAAAA,EAAAy0B,EAAA9zB,OAAAX,IAGA,GAAA,MAAAy0B,EAAAz0B,GAyBA,GAAA,MAAAy0B,EAAAz0B,GAAA,CAWA,IAAA,GAHA0Z,GAAA+a,EAAAz0B,GAAAgwB,MAAA8D,OAGAlqB,EAAA,EAAAA,EAAA8P,EAAA/Y,OAAAiJ,IAAA,CAOA,IAAA,GAJAoM,GAAA+d,EAAA/C,KAAAtX,EAAA9P,IAAA,GAAAzF,cACAmtB,EAAA5X,EAAA9P,GAAAomB,MAAAgE,GAGAU,EAAA,EAAAA,EAAApD,EAAA3wB,OAAA+zB,IACApD,EAAAoD,GAAApD,EAAAoD,GAAAC,UAAA,EAAArD,EAAAoD,GAAA/zB,OAAA,GAAAywB,QAAA,YAAA,GAIA,oBAAAwB,GAAA5c,IAqBA,IAAAsb,EAAA3wB,SACA2wB,EAAAA,EAAA,IAIA,mBAAAL,GAAAjb,GAYAjF,EACAA,EAAAiF,GAAAsb,EAKA3e,EAAAqD,GAAAsb,EAbAsC,EAAAjhB,EAAAse,EAAAjb,GAAApU,MAAA,KAAA0vB,KA5BAiD,EAAA5yB,QAAAqU,UAIAjF,GAAA,MAAAiF,GAAA,MAAAA,IACAjF,KACA0J,EAAA9R,KAAAoI,KAKA6hB,EAAA5c,GAAArD,EAAA5B,EAAAiF,EAAAsb,IAmCAvgB,IAAAA,EAAAO,OACAP,EAAA,UAxEAyjB,GAAA7zB,SACA8Z,EAAA+Z,EAAA3iB,WA3BA,CAGA,GAAA,IAAA7R,GAAA,MAAAA,EACA,QAIAw0B,GAAA7rB,KAAA8R,GAGAtgB,EAAAyK,QAAA6V,EAAAA,EAAA9Z,OAAA,KACA8Z,EAAA9R,SAIA8R,EAAAA,EAAAA,EAAA9Z,OAAA,GAGA8Z,EAAA9R,SACA8R,EAAAA,EAAAA,EAAA9Z,OAAA,GAmFA,MAAA8gB,GACAtnB,EAAA+Z,OAAAvB,GAIAA,GCigXE,OAAOoe,OAGN72B,OAAQA,OAAOC","file":"ngGo.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\r\n * ngGo\r\n *\r\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\r\n * refactored to fit the Angular framework, as well as having been linted, properly commented\r\n * and generally cleaned up.\r\n *\r\n * Copyright (c) 2013 Jan Prokop (WGo)\r\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify, merge,\r\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\r\n * to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo', [])\r\n\r\n/**\r\n * ngGo constants\r\n */\r\n.constant('ngGo', {\r\n  name: 'ngGo',\r\n  version: '1.3.1',\r\n  error: {\r\n\r\n    //Position errors\r\n    POSITION_OUT_OF_BOUNDS: 1,\r\n    POSITION_ALREADY_HAS_STONE: 2,\r\n    POSITION_IS_SUICIDE: 3,\r\n    POSITION_IS_REPEATING: 4,\r\n\r\n    //Data loading errors\r\n    NO_DATA: 5,\r\n    UNKNOWN_DATA: 6,\r\n    INVALID_SGF: 7,\r\n    INVALID_GIB: 8,\r\n    INVALID_JGF_JSON: 9,\r\n    INVALID_JGF_TREE_JSON: 10\r\n  }\r\n})\r\n\r\n/**\r\n * Stone colors\r\n */\r\n.constant('StoneColor', {\r\n  E: 0,\r\n  EMPTY: 0,\r\n  B: 1,\r\n  BLACK: 1,\r\n  W: -1,\r\n  WHITE: -1\r\n})\r\n\r\n/**\r\n * Markup types\r\n */\r\n.constant('MarkupTypes', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  LABEL: 'label',\r\n  LAST: 'last',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy'\r\n})\r\n\r\n/**\r\n * Player modes\r\n */\r\n.constant('PlayerModes', {\r\n  PLAY: 'play',\r\n  REPLAY: 'replay',\r\n  EDIT: 'edit',\r\n  SOLVE: 'solve'\r\n})\r\n\r\n/**\r\n * Player tools\r\n */\r\n.constant('PlayerTools', {\r\n  NONE: 'none',\r\n  MOVE: 'move',\r\n  SCORE: 'score',\r\n  SETUP: 'setup',\r\n  MARKUP: 'markup'\r\n})\r\n\r\n/**\r\n * Key codes\r\n */\r\n.constant('KeyCodes', {\r\n  LEFT: 37,\r\n  RIGHT: 39,\r\n  UP: 38,\r\n  DOWN: 40,\r\n  ESC: 27,\r\n  ENTER: 13,\r\n  SPACE: 32,\r\n  TAB: 9,\r\n  SHIFT: 16,\r\n  CTRL: 17,\r\n  ALT: 18,\r\n  HOME: 36,\r\n  END: 35,\r\n  PAGEUP: 33,\r\n  PAGEDOWN: 34\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Directive', [\r\n  'ngGo.Board.Service'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('board', ['$window', 'Board', function($window, Board) {\r\n\r\n  //Get pixel ratio\r\n  var pixelRatio = window.devicePixelRatio || 1;\r\n\r\n  /**\r\n   * Helper to create a layer canvas\r\n   */\r\n  function createLayerCanvas(name) {\r\n\r\n    //Create canvas element and get context\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    //Scale context depending on pixel ratio\r\n    if (pixelRatio > 1) {\r\n      context.scale(pixelRatio, pixelRatio);\r\n    }\r\n\r\n    //Set class\r\n    canvas.className = name;\r\n\r\n    //Set initial canvas width/height based on our own size\r\n    canvas.width = this.clientWidth * pixelRatio;\r\n    canvas.height = this.clientHeight * pixelRatio;\r\n\r\n    //Append to element now and return context\r\n    this.appendChild(canvas);\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Helper to determine draw size\r\n   */\r\n  function determineDrawSize(scope, availableWidth, availableHeight) {\r\n\r\n    //Init vars\r\n    var drawWidth, drawHeight, cellSize;\r\n\r\n    //Stretch available height to width if zero\r\n    if (availableHeight === 0 && availableWidth > 0) {\r\n      availableHeight = availableWidth;\r\n    }\r\n\r\n    //Grid size known?\r\n    if (scope.Board.width && scope.Board.height) {\r\n\r\n      //Determine smallest cell size\r\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\r\n\r\n      //Set draw size\r\n      drawWidth = Math.floor(cellSize * scope.Board.width);\r\n      drawHeight = Math.floor(cellSize * scope.Board.height);\r\n    }\r\n\r\n    //Otherwise, use the lesser of the available width/height\r\n    else {\r\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\r\n    }\r\n\r\n    //Broadcast new size if changed\r\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\r\n      scope.lastDrawWidth = drawWidth;\r\n      scope.lastDrawHeight = drawHeight;\r\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\r\n      return true;\r\n    }\r\n\r\n    //No change\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Directive\r\n   */\r\n  return {\r\n    restrict: 'E',\r\n    scope: {\r\n      instance: '&'\r\n    },\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Init vars\r\n      var i, context, layer, playerElement;\r\n      var parent = element.parent();\r\n      var sizingElement = element[0];\r\n      var existingInstance = true;\r\n\r\n      //Remember last draw width/height\r\n      scope.lastDrawWidth = 0;\r\n      scope.lastDrawHeight = 0;\r\n\r\n      //Get board instance\r\n      scope.Board = scope.instance();\r\n\r\n      //Function given?\r\n      if (typeof scope.Board === 'function') {\r\n        scope.Board = scope.Board();\r\n      }\r\n\r\n      //Instantiate board if not present in scope\r\n      if (!scope.Board) {\r\n        existingInstance = false;\r\n        scope.Board = new Board();\r\n      }\r\n\r\n      //Link element\r\n      scope.Board.linkElement(element);\r\n\r\n      //Find player element\r\n      if (parent[0].tagName === 'PLAYER') {\r\n        playerElement = parent;\r\n        sizingElement = parent.parent()[0];\r\n      }\r\n\r\n      //Listen for board drawsize events\r\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\r\n\r\n        //First set the new dimensions on the canvas elements\r\n        var canvas = element.find('canvas');\r\n        for (i = 0; i < canvas.length; i++) {\r\n          canvas[i].width = width * pixelRatio;\r\n          canvas[i].height = height * pixelRatio;\r\n        }\r\n\r\n        //Set on the element if we're using a player element and if there is a size\r\n        if (playerElement || attrs.forceSize === 'true') {\r\n          element.css({width: width + 'px', height: height + 'px'});\r\n        }\r\n\r\n        //Next set it on the board itself\r\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\r\n      });\r\n\r\n      //Determine initial draw size\r\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n\r\n      //On window resize, determine the draw size again\r\n      angular.element($window).on('resize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On manual resize, determine draw size again\r\n      scope.$on('ngGo.board.determineDrawSize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On board grid resize, determine the draw size again\r\n      scope.$on('ngGo.board.resize', function(event, board) {\r\n\r\n        //Only relevent if this was our own board\r\n        if (board !== scope.Board) {\r\n          return;\r\n        }\r\n\r\n        //If the draw size didn't change, the draw size event won't be triggered.\r\n        //However, that means we should call the resized() method now manually because\r\n        //it won't be called with the setDrawSize() call.\r\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\r\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\r\n          scope.Board.resized();\r\n        }\r\n      });\r\n\r\n      //Static board\r\n      if (attrs.static && attrs.static === 'true') {\r\n\r\n        //Add static class and make the board static\r\n        element.addClass('static');\r\n        scope.Board.makeStatic();\r\n\r\n        //Create single canvas and link to all relevant layer service classes\r\n        context = createLayerCanvas.call(element[0], 'static');\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Dynamic board\r\n      else {\r\n\r\n        //Create individual layer canvasses and link the canvas context to the layer service class\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          context = createLayerCanvas.call(element[0], layer);\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Observe the board size attribute\r\n      attrs.$observe('size', function(size) {\r\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\r\n          size = size.split('x');\r\n          scope.Board.setSize(size[0], size[1]);\r\n        }\r\n        else {\r\n          scope.Board.setSize(size, size);\r\n        }\r\n      });\r\n\r\n      //Observe the coordinates attribute\r\n      attrs.$observe('coordinates', function(attr) {\r\n        scope.Board.toggleCoordinates(attr === 'true');\r\n      });\r\n\r\n      //Observe the cutoff attribute\r\n      attrs.$observe('cutoff', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.setCutoff(attr.split(','));\r\n        }\r\n      });\r\n\r\n      //Observe color multiplier\r\n      attrs.$observe('colorMultiplier', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.swapColors(attr);\r\n        }\r\n      });\r\n\r\n      //Link board to player if present in parent scope\r\n      if (scope.$parent.Player) {\r\n        scope.$parent.Player.setBoard(scope.Board);\r\n      }\r\n\r\n      //Redraw board if we had an existing instance (it might contain data)\r\n      if (existingInstance) {\r\n        scope.Board.redraw();\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\r\n * and is used for placing and removing objects on the board. The class has helpers to figure out\r\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\r\n * responsible for drawing all layers on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Directive',\r\n  'ngGo.Board.Theme.Service',\r\n  'ngGo.Board.Layer.GridLayer.Service',\r\n  'ngGo.Board.Layer.ShadowLayer.Service',\r\n  'ngGo.Board.Layer.StonesLayer.Service',\r\n  'ngGo.Board.Layer.MarkupLayer.Service',\r\n  'ngGo.Board.Layer.ScoreLayer.Service',\r\n  'ngGo.Board.Layer.HoverLayer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.Stone.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Board', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Width and height\r\n    width: 0,\r\n    height: 0,\r\n\r\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\r\n    cutoff: [],\r\n\r\n    //Section of board to display\r\n    section: {top: 0, right: 0, bottom: 0, left: 0},\r\n\r\n    //Show coordinates?\r\n    coordinates: false,\r\n\r\n    //Color multiplier (use -1 to swap colors)\r\n    colorMultiplier: 1\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\r\n\r\n    /**\r\n     * Board constructor\r\n     */\r\n    function Board(config) {\r\n\r\n      //Initialize board\r\n      this.init();\r\n\r\n      //Parse config\r\n      this.parseConfig(config || {});\r\n    }\r\n\r\n    /**\r\n     * Initialize board\r\n     */\r\n    Board.prototype.init = function() {\r\n\r\n      //Remove everything\r\n      this.removeAll();\r\n\r\n      //Set board theme\r\n      this.theme = new BoardTheme();\r\n\r\n      //Initialize board draw dimensions in pixels\r\n      this.cellSize = 0;\r\n      this.drawWidth = 0;\r\n      this.drawHeight = 0;\r\n      this.drawMarginHor = 0;\r\n      this.drawMarginVer = 0;\r\n      this.gridDrawWidth = 0;\r\n      this.gridDrawHeight = 0;\r\n\r\n      //Set layer order\r\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\r\n\r\n      //Initialize layers\r\n      this.layers = {};\r\n      for (var l = 0; l < this.layerOrder.length; l++) {\r\n        var layer = this.layerOrder[l];\r\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\r\n        var LayerClass = $injector.get(layerClass);\r\n        this.layers[layer] = new LayerClass(this);\r\n      }\r\n\r\n      //Static board flag\r\n      this.static = false;\r\n\r\n      //Get margin from theme\r\n      this.margin = this.theme.get('board.margin');\r\n\r\n      //Color multiplier (to allow color swapping)\r\n      this.colorMultiplier = 1;\r\n\r\n      //Turn off coordinates\r\n      this.coordinates = false;\r\n      this.layers.grid.setCoordinates(false);\r\n\r\n      //Initialize grid size\r\n      this.width = 0;\r\n      this.height = 0;\r\n\r\n      //Initialize cutoff\r\n      this.cutoff = {\r\n        top: false,\r\n        left: false,\r\n        right: false,\r\n        bottom: false\r\n      };\r\n\r\n      //Initialize section\r\n      this.section = {\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Link the board to a HTML element\r\n     */\r\n    Board.prototype.linkElement = function(element) {\r\n      this.element = element;\r\n    };\r\n\r\n    /**\r\n     * Make this board static (one canvas layer, only grid, stones and markup)\r\n     */\r\n    Board.prototype.makeStatic = function() {\r\n      this.static = true;\r\n      this.layerOrder = ['grid', 'stones', 'markup'];\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Configuration\r\n     ***/\r\n\r\n    /**\r\n     * Parse config instructions\r\n     */\r\n    Board.prototype.parseConfig = function(config) {\r\n\r\n      //Validate\r\n      if (typeof config !== 'object') {\r\n        return;\r\n      }\r\n\r\n      //Extend from default config\r\n      config = angular.extend({}, defaultConfig, config);\r\n\r\n      //Process settigns\r\n      this.toggleCoordinates(config.coordinates);\r\n      this.swapColors(config.colorMultiplier);\r\n      this.setCutoff(config.cutoff);\r\n      this.setSection(config.section);\r\n      this.setSize(config.width, config.height);\r\n    };\r\n\r\n    /**\r\n     * Set margin\r\n     */\r\n    Board.prototype.setMargin = function(margin) {\r\n\r\n      //Reset when not defined\r\n      if (typeof margin === 'undefined') {\r\n        margin = this.theme.get('board.margin');\r\n      }\r\n\r\n      //Set margin if changed\r\n      if (this.margin !== margin) {\r\n        this.margin = margin;\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set grid cut-off\r\n     */\r\n    Board.prototype.setCutoff = function(cutoff) {\r\n\r\n      //Nothing given? Reset cutoff\r\n      if (!cutoff || !angular.isArray(cutoff)) {\r\n        cutoff = [];\r\n      }\r\n\r\n      //Init\r\n      var changes = false;\r\n\r\n      //Check if there's a change\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff.hasOwnProperty(side)) {\r\n          if (cutoff.indexOf(side) !== -1) {\r\n            if (!this.cutoff[side]) {\r\n              this.cutoff[side] = true;\r\n              changes = true;\r\n            }\r\n          }\r\n          else {\r\n            if (this.cutoff[side]) {\r\n              this.cutoff[side] = false;\r\n              changes = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Trigger resized if there were changes\r\n      if (changes) {\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set section of the board to be displayed\r\n     */\r\n    Board.prototype.setSection = function(section) {\r\n\r\n      //Nothing given?\r\n      if (!section || typeof section !== 'object') {\r\n        return this;\r\n      }\r\n\r\n      //Expand on default\r\n      section = angular.extend({\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      }, section);\r\n\r\n      //No changes?\r\n      if (\r\n        this.section.top === section.top && this.section.bottom === section.bottom &&\r\n        this.section.left === section.left && this.section.right === section.right\r\n      ) {\r\n        return this;\r\n      }\r\n\r\n      //Set section and call resized handler\r\n      this.section = section;\r\n      this.resized();\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set board size. This will clear the board objects.\r\n     */\r\n    Board.prototype.setSize = function(width, height) {\r\n\r\n      //Check what's given\r\n      width = parseInt(width || height || 0);\r\n      height = parseInt(height || width || 0);\r\n\r\n      //Invalid?\r\n      if (isNaN(width) || isNaN(height)) {\r\n        return;\r\n      }\r\n\r\n      //Changing?\r\n      if (width !== this.width || height !== this.height) {\r\n\r\n        //Remember size\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        //Set size in layers\r\n        for (var layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].setSize(width, height);\r\n          }\r\n        }\r\n\r\n        //Broadcast event (no call to resized, as that is handled in the directive)\r\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set new draw size\r\n     */\r\n    Board.prototype.setDrawSize = function(width, height) {\r\n      if (width !== this.drawWidth || height !== this.drawHeight) {\r\n        this.drawWidth = width;\r\n        this.drawHeight = height;\r\n        this.resized();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Toggle the coordinates\r\n     */\r\n    Board.prototype.toggleCoordinates = function(show) {\r\n\r\n      //Set or toggle\r\n      if (typeof show !== 'undefined') {\r\n        this.coordinates = show;\r\n      }\r\n      else {\r\n        this.coordinates = !this.coordinates;\r\n      }\r\n\r\n      //Set in grid layer\r\n      this.layers.grid.setCoordinates(this.coordinates);\r\n\r\n      //Set the proper board margin\r\n      if (this.coordinates) {\r\n        this.setMargin(this.theme.get('coordinates.margin'));\r\n      }\r\n      else {\r\n        this.setMargin(this.theme.get('board.margin'));\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Swap colors on the board\r\n     */\r\n    Board.prototype.swapColors = function(multiplier) {\r\n\r\n      //Multiplier not given? Set to inverse of current value\r\n      if (typeof multiplier === 'undefined') {\r\n        multiplier = -this.colorMultiplier;\r\n      }\r\n      else {\r\n        multiplier = parseInt(multiplier);\r\n        if (isNaN(multiplier)) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //No change?\r\n      if (multiplier === this.colorMultiplier) {\r\n        return;\r\n      }\r\n\r\n      //Set new value\r\n      this.colorMultiplier = multiplier;\r\n\r\n      //For static board, redraw the whole thing\r\n      if (this.static) {\r\n        this.redraw();\r\n      }\r\n\r\n      //For a dynamic board, only these layers\r\n      else {\r\n        this.redraw('stones');\r\n        this.redraw('markup');\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Theme handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the current theme object\r\n     */\r\n    Board.prototype.getTheme = function() {\r\n      return this.theme;\r\n    };\r\n\r\n    /**\r\n     * Set the theme object\r\n     */\r\n    Board.prototype.setTheme = function(theme) {\r\n      this.theme = theme;\r\n      return this;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Object handling\r\n     ***/\r\n\r\n    /**\r\n     * Add an object to a board layer\r\n     */\r\n    Board.prototype.add = function(layer, x, y, value) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].add(x, y, value);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove an object from a board layer\r\n     */\r\n    Board.prototype.remove = function(layer, x, y) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].remove(x, y);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get something from a board layer\r\n     */\r\n    Board.prototype.get = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].get(x, y));\r\n    };\r\n\r\n    /**\r\n     * Check if we have something at given coordinates for a given layer\r\n     */\r\n    Board.prototype.has = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].has(x, y));\r\n    };\r\n\r\n    /**\r\n     * Set all objects (grid) for a given layer\r\n     */\r\n    Board.prototype.setAll = function(layer, grid) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].setAll(grid);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove all objects from the board, optionally for a given layer\r\n     */\r\n    Board.prototype.removeAll = function(layer) {\r\n      if (layer) {\r\n        if (typeof this.layers[layer] !== 'undefined') {\r\n          this.layers[layer].removeAll();\r\n        }\r\n      }\r\n      else {\r\n        for (layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].removeAll();\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Position handling\r\n     ***/\r\n\r\n    /**\r\n     * Update the board with a new position\r\n     */\r\n    Board.prototype.updatePosition = function(position, pathChanged) {\r\n\r\n      //If we have no grid size yet, use what's in the position\r\n      if (!this.width || !this.height) {\r\n        this.setSize(position.width, position.height);\r\n      }\r\n\r\n      //Remove markup if path changed\r\n      if (pathChanged) {\r\n        this.removeAll('markup');\r\n      }\r\n\r\n      //Set new stones and markup grids\r\n      this.setAll('stones', position.stones);\r\n      this.setAll('markup', position.markup);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state (list of objects per layer)\r\n     */\r\n    Board.prototype.getState = function(layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          return this.layers[layer].getAll();\r\n        }\r\n        return null;\r\n      }\r\n\r\n      //All layers\r\n      var state = {};\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          var grid = this.layers[layer].getAll();\r\n          if (grid && !grid.isEmpty()) {\r\n            state[layer] = grid;\r\n          }\r\n        }\r\n      }\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the board state from given state object\r\n     */\r\n    Board.prototype.restoreState = function(state, layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          this.layers[layer].setAll(state);\r\n        }\r\n        return;\r\n      }\r\n\r\n      //All layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].removeAll();\r\n          if (state[layer]) {\r\n            this.layers[layer].setAll(state[layer]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing control\r\n     ***/\r\n\r\n    /**\r\n     * Clear the whole board\r\n     */\r\n    Board.prototype.clear = function(layer) {\r\n\r\n      //Just clearing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Clear the layer\r\n        this.layers[layer].clear();\r\n        return;\r\n      }\r\n\r\n      //Static? One clear is enough\r\n      if (this.static) {\r\n        this.layers.stones.clear();\r\n        return;\r\n      }\r\n\r\n      //Clear all layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].clear();\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Redraw everything or just a single layer\r\n     */\r\n    Board.prototype.redraw = function(layer) {\r\n\r\n      //The board can only be redrawn when there is a grid size and a draw size\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Just redrawing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Redraw the layer\r\n        this.layers[layer].redraw();\r\n        return;\r\n      }\r\n\r\n      //Clear the board first\r\n      this.clear();\r\n\r\n      //Now draw all layers again in the correct order\r\n      for (var i = 0; i < this.layerOrder.length; i++) {\r\n        layer = this.layerOrder[i];\r\n        this.layers[layer].draw();\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing helpers\r\n     ***/\r\n\r\n    /**\r\n     * Called after a board size change, draw size change, section change or margin change\r\n     */\r\n    Board.prototype.resized = function() {\r\n\r\n      //Determine the new grid\r\n      this.grid = {\r\n        xLeft: 0 + this.section.left,\r\n        xRight: this.width - 1 - this.section.right,\r\n        yTop: 0 + this.section.top,\r\n        yBot: this.height - 1 - this.section.bottom\r\n      };\r\n\r\n      //Only redraw when there is sensible data\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Determine number of cells horizontall and vertically\r\n      //The margin is a factor of the cell size, so let's add it to the number of cells\r\n      var noCellsHor = this.width + this.margin;\r\n      var noCellsVer = this.height + this.margin;\r\n\r\n      //Are we cutting off parts of the grid? Add half a cell of draw size\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff[side]) {\r\n          if (side === 'top' || side === 'bottom') {\r\n            noCellsVer += 0.5;\r\n          }\r\n          else {\r\n            noCellsHor += 0.5;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Determine cell size now\r\n      this.cellSize = Math.floor(Math.min(\r\n        this.drawWidth / noCellsHor,\r\n        this.drawHeight / noCellsVer\r\n      ));\r\n\r\n      //Determine actual grid draw size (taking off the margin again)\r\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\r\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\r\n\r\n      //Determine draw margins\r\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\r\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\r\n\r\n      //Redraw\r\n      this.redraw();\r\n    };\r\n\r\n    /**\r\n     * Get the current cell size\r\n     */\r\n    Board.prototype.getCellSize = function() {\r\n      return this.cellSize;\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsX = function(gridX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsY = function(gridY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridX = function(absX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridY = function(absY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Check if given grid coordinates are on board\r\n     */\r\n    Board.prototype.isOnBoard = function(gridX, gridY) {\r\n      return (\r\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\r\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\r\n      );\r\n    };\r\n\r\n    //Return object\r\n    return Board;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\r\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\r\n * a small rectangular area on the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('DefaultClearHandler', function() {\r\n\r\n  /**\r\n   * Clear handler definition\r\n   *\r\n   * All external handlers are called from the context of the layer that contains the object.\r\n   * First parameter is the canvas2d context, second parameter is the object itself.\r\n   */\r\n  return function(context, obj) {\r\n\r\n    //No context?\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(obj.x);\r\n    var y = this.board.getAbsY(obj.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Clear rectangle the size of the stone radius\r\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\r\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\r\n * stone color values for the game position class. It has built in validation of coordinates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Grid.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.GridChanges.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\r\n\r\n  /**\r\n   * Helper to convert a value at given coordinates to an object\r\n   */\r\n  function toObject(x, y, valueKey) {\r\n\r\n    //Create coordinates object\r\n    var obj = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Already an object?\r\n    if (typeof this.grid[x][y] === 'object') {\r\n      return angular.extend(obj, this.grid[x][y]);\r\n    }\r\n\r\n    //Not an object, set value with given value key and return\r\n    obj[valueKey] = this.grid[x][y];\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardGrid(width, height, emptyValue) {\r\n\r\n    //Initialize size and grid array\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.grid = [];\r\n    this.emptyValue = null;\r\n\r\n    //Set empty value if given\r\n    if (typeof emptyValue !== 'undefined') {\r\n      this.emptyValue = emptyValue;\r\n    }\r\n\r\n    //Size given? Set it\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a value\r\n   */\r\n  BoardGrid.prototype.set = function(x, y, value) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unset a value\r\n   */\r\n  BoardGrid.prototype.unset = function(x, y) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = this.emptyValue;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if we have a non null value on the coordinates\r\n   */\r\n  BoardGrid.prototype.has = function(x, y) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\r\n  };\r\n\r\n  /**\r\n   * Check if we have a specific value on the coordinates\r\n   */\r\n  BoardGrid.prototype.is = function(x, y, value) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\r\n  };\r\n\r\n  /**\r\n   * Get a value, or an object with coordinates and the value in the given value key\r\n   */\r\n  BoardGrid.prototype.get = function(x, y, valueKey) {\r\n\r\n    //Validate\r\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\r\n      return this.emptyValue;\r\n    }\r\n\r\n    //Return as is?\r\n    if (!valueKey) {\r\n      return this.grid[x][y];\r\n    }\r\n\r\n    //Return as object\r\n    return toObject.call(this, x, y, valueKey);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Mass operations\r\n   ***/\r\n\r\n  /**\r\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\r\n   * and the value in the given value key will be returned.\r\n   */\r\n  BoardGrid.prototype.all = function(valueKey) {\r\n\r\n    //Just get the grid?\r\n    if (!valueKey) {\r\n      return this.grid;\r\n    }\r\n\r\n    //Initialize objects list\r\n    var objects = [];\r\n\r\n    //Loop coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          objects.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return objects list\r\n    return objects;\r\n  };\r\n\r\n  /**\r\n   * Check if there is anything\r\n   */\r\n  BoardGrid.prototype.isEmpty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Populate the whole grid with a given value\r\n   */\r\n  BoardGrid.prototype.populate = function(value) {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = value;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Empty the grid\r\n   */\r\n  BoardGrid.prototype.empty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clone ourselves\r\n   */\r\n  BoardGrid.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newGrid = new BoardGrid();\r\n\r\n    //Manually set vars for maximum efficiency\r\n    newGrid.grid = angular.copy(this.grid);\r\n    newGrid.emptyValue = this.emptyValue;\r\n    newGrid.width = this.width;\r\n    newGrid.height = this.height;\r\n\r\n    //Return\r\n    return newGrid;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Comparison\r\n   ***/\r\n\r\n  /**\r\n   * Checks if a given grid is the same as the current grid\r\n   */\r\n  BoardGrid.prototype.isSameAs = function(grid) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== grid.width || this.height !== grid.height) {\r\n      return false;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== grid[x][y]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    //No differences found\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Compares this position with another position and return change object\r\n   */\r\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\r\n\r\n    //Initialize board grid changes object\r\n    var changes = new BoardGridChanges();\r\n\r\n    //Must have the same size\r\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\r\n      console.warn('Trying to compare grids of a different size');\r\n      return changes;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n\r\n        //Something to add?\r\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\r\n        }\r\n\r\n        //Something to remove?\r\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.remove.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return changes grid\r\n    return changes;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to validate coordinates (first param can be an object)\r\n   */\r\n  BoardGrid.prototype.isOnGrid = function(x, y) {\r\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\r\n  };\r\n\r\n  /**\r\n   * Helper to set the empty value\r\n   */\r\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\r\n    this.emptyValue = emptyValue;\r\n  };\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  BoardGrid.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Create grid array\r\n    this.grid = [];\r\n    for (var x = 0; x < this.width; x++) {\r\n      this.grid[x] = [];\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the grid size object\r\n   */\r\n  BoardGrid.prototype.getSize = function() {\r\n    return {width: this.width, height: this.height};\r\n  };\r\n\r\n  //Return\r\n  return BoardGrid;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\r\n * grids. It simply keeps track of what was added and what was removed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.GridChanges.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGridChanges', function() {\r\n\r\n  /**\r\n   * Helper to subtract sets\r\n   */\r\n  function setSubtract(a, b) {\r\n    var n = [];\r\n    var q;\r\n    for (var i = 0; i < a.length; i++) {\r\n      q = true;\r\n      for (var j in b) {\r\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\r\n          q = false;\r\n          break;\r\n        }\r\n      }\r\n      if (q) {\r\n        n.push(a[i]);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /**\r\n   * Grid changes constructor\r\n   */\r\n  return function() {\r\n\r\n    /**\r\n     * Containers\r\n     */\r\n    this.add = [];\r\n    this.remove = [];\r\n\r\n    /**\r\n     * Concatenation helper\r\n     */\r\n    this.concat = function(newChanges) {\r\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\r\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\r\n    };\r\n\r\n    /**\r\n     * Check if there are changes\r\n     */\r\n    this.has = function() {\r\n      return !!(this.add.length || this.remove.length);\r\n    };\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\r\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\r\n * for drawing itself as well as its objects onto the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardLayer(board, context) {\r\n\r\n    //Remember board reference and 2d canvas context\r\n    this.board = board;\r\n    this.context = context;\r\n\r\n    //Initialize grid for board objects\r\n    this.grid = new BoardGrid();\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Generic grid and object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set grid size\r\n   */\r\n  BoardLayer.prototype.setSize = function(width, height) {\r\n\r\n    //Note: since this method is usually only called upon a global board resize,\r\n    //which also triggers the redraw method for layers, the layer is not cleared\r\n    //here, as it will happen anyway during the redraw cycle.\r\n\r\n    //Set it in the grid (removing all objects in the process)\r\n    this.grid.setSize(width, height);\r\n  };\r\n\r\n  /**\r\n   * Get all items\r\n   */\r\n  BoardLayer.prototype.getAll = function() {\r\n    return this.grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Set all items at once\r\n   */\r\n  BoardLayer.prototype.setAll = function(grid) {\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  BoardLayer.prototype.removeAll = function() {\r\n    this.clear();\r\n    this.grid.empty();\r\n  };\r\n\r\n  /**\r\n   * Add a single item\r\n   */\r\n  BoardLayer.prototype.add = function(x, y, value) {\r\n    this.clearCell(x, y);\r\n    this.grid.set(x, y, value);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Remove a single item\r\n   */\r\n  BoardLayer.prototype.remove = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.grid.unset(x, y);\r\n  };\r\n\r\n  /**\r\n   * Get an item\r\n   */\r\n  BoardLayer.prototype.get = function(x, y) {\r\n    return this.grid.get(x, y);\r\n  };\r\n\r\n  /**\r\n   * Check if there is an item\r\n   */\r\n  BoardLayer.prototype.has = function(x, y) {\r\n    return this.grid.has(x, y);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Generic drawing methods\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  BoardLayer.prototype.draw = function() {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\r\n   */\r\n  BoardLayer.prototype.clear = function() {\r\n    if (this.context) {\r\n      this.context.clearRect(\r\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  BoardLayer.prototype.redraw = function() {\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\r\n    //Clearing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Redraw cell\r\n   */\r\n  BoardLayer.prototype.redrawCell = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Set the canvas2d context\r\n   */\r\n  BoardLayer.prototype.setContext = function(context) {\r\n    this.context = context;\r\n  };\r\n\r\n  /**\r\n   * Get the canvas2d context\r\n   */\r\n  BoardLayer.prototype.getContext = function() {\r\n    return this.context;\r\n  };\r\n\r\n  //Return\r\n  return BoardLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardObject :: Base class for drawing board objects\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.DefaultClearHandler.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var BoardObject = {\r\n\r\n    /**\r\n     * Draw method\r\n     */\r\n    draw: function(/*obj*/) {\r\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear method\r\n     */\r\n    clear: function(obj) {\r\n      DefaultClearHandler.call(this, this.context, obj);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return BoardObject;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.ShellPattern.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShellPattern', function() {\r\n\r\n  /**\r\n   * Helper to draw a shell line\r\n   */\r\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\r\n\r\n    //Initialize\r\n    ctx.shadowBlur = 2;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = (radius / 30) * this.thickness;\r\n    ctx.beginPath();\r\n\r\n    //Lower radius\r\n    radius -= Math.max(1, ctx.lineWidth);\r\n\r\n    //Determine coordinates\r\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\r\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\r\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\r\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\r\n\r\n    //Math magic\r\n    var m, angle;\r\n    if (x2 > x1) {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m);\r\n    }\r\n    else if (x2 === x1) {\r\n      angle = Math.PI / 2;\r\n    }\r\n    else {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m) - Math.PI;\r\n    }\r\n\r\n    //Curvature factor\r\n    var c = this.factor * radius;\r\n    var dx = Math.sin(angle) * c;\r\n    var dy = Math.cos(angle) * c;\r\n\r\n    //Curvature coordinates\r\n    var bx1 = x1 + dx;\r\n    var by1 = y1 - dy;\r\n    var bx2 = x2 + dx;\r\n    var by2 = y2 - dy;\r\n\r\n    //Draw shell stroke\r\n    ctx.moveTo(x1, y1);\r\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Shell pattern drawer\r\n   */\r\n  return function(ctx, x, y, radius, angle, strokeStyle) {\r\n\r\n    //Initialize start and end angle\r\n    var startAngle = angle;\r\n    var endAngle = angle;\r\n\r\n    //Loop lines\r\n    for (var i = 0; i < this.lines.length; i++) {\r\n      startAngle += this.lines[i];\r\n      endAngle -= this.lines[i];\r\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\r\n    }\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\r\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\r\n * use static values or dynamic values depending on other properties, like the grid cell size.\r\n * Using the provider, the theme can be configured globally at application launch.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Theme.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\r\n\r\n  /**\r\n   * Default theme\r\n   */\r\n  var defaultTheme = {\r\n\r\n    //Board\r\n    board: {\r\n\r\n      //Board margin factor\r\n      margin: 0.25\r\n    },\r\n\r\n    //Stones\r\n    stone: {\r\n\r\n      //Stone style can be shell, glass, mono, or specify a custom handler service\r\n      style: 'shell',\r\n      shadow: true,\r\n      radius: function(cellSize) {\r\n        return Math.floor(cellSize / 2);\r\n      },\r\n\r\n      //Shell stones\r\n      shell: {\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#111';\r\n          }\r\n          return '#BFBFBA';\r\n        },\r\n        stroke: 'rgba(128,128,128,0.15)',\r\n        types: [\r\n          {\r\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\r\n            factor: 0.15,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\r\n            factor: 0.1,\r\n            thickness: 1.5\r\n          },\r\n          {\r\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\r\n            factor: 0.05,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\r\n            factor: 0.1,\r\n            thickness: 2\r\n          }\r\n        ]\r\n      },\r\n\r\n      //Mono stones\r\n      mono: {\r\n        lineWidth: 1,\r\n        lineColor: function() {\r\n          return '#000';\r\n        },\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#000';\r\n          }\r\n          return '#fff';\r\n        }\r\n      },\r\n\r\n      //Mini stones\r\n      mini: {\r\n        scale: 0.5,\r\n        alpha: 1\r\n      },\r\n\r\n      //Faded stones\r\n      faded: {\r\n        scale: 1,\r\n        alpha: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return 0.3;\r\n          }\r\n          return 0.4;\r\n        }\r\n      }\r\n    },\r\n\r\n    //Shadows\r\n    shadow: {\r\n\r\n      //Shadow gradient colors\r\n      color: 'rgba(40,30,20,0.5)',\r\n\r\n      //Shadow size\r\n      size: function(cellSize) {\r\n        return Math.floor(cellSize / 20);\r\n      },\r\n\r\n      //Shadow blur size\r\n      blur: function(cellSize) {\r\n        return cellSize / 20;\r\n      },\r\n\r\n      //Shadow offset\r\n      offsetX: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      },\r\n      offsetY: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      }\r\n    },\r\n\r\n    //Markup\r\n    markup: {\r\n\r\n      //Standard color\r\n      color: function(stoneColor) {\r\n        if (stoneColor === StoneColor.B) {\r\n          return 'rgba(255,255,255,0.9)';\r\n        }\r\n        return 'rgba(0,0,0,0.9)';\r\n      },\r\n\r\n      //Line width\r\n      lineWidth: function(cellSize) {\r\n        return Math.max(1, Math.floor(cellSize / 16));\r\n      },\r\n\r\n      //Triangle\r\n      triangle: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Square\r\n      square: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Cricle\r\n      circle: {\r\n        scale: 0.55\r\n      },\r\n\r\n      //Mark\r\n      mark: {\r\n        lineCap: 'square',\r\n        scale: 0.75\r\n      },\r\n\r\n      //Last\r\n      last: {\r\n        scale: 0.7\r\n      },\r\n\r\n      //Smiley\r\n      smiley: {\r\n        lineCap: 'round',\r\n        scale: 0.85\r\n      },\r\n\r\n      //Label\r\n      label: {\r\n        font: 'Arial'\r\n      },\r\n\r\n      //Variation markup\r\n      variation: {\r\n        type: MarkupTypes.LABEL,\r\n        text: function(i) {\r\n          return String.fromCharCode(65 + i);\r\n        },\r\n        color: 'rgba(86,114,30,0.9)'\r\n      },\r\n\r\n      //Solution paths markup\r\n      solution: {\r\n        valid: {\r\n          type: MarkupTypes.SELECT,\r\n          text: null,\r\n          color: 'rgba(86,114,30,1)',\r\n          scale: 0.5\r\n        },\r\n        invalid: {\r\n          type: MarkupTypes.MARK,\r\n          text: null,\r\n          color: 'rgba(237,9,15,1)',\r\n          scale: 0.3\r\n        }\r\n      }\r\n    },\r\n\r\n    //Grid\r\n    grid: {\r\n\r\n      //Line properties\r\n      lineColor: 'rgba(60,40,15,1)',\r\n      lineWidth: function(cellSize) {\r\n        if (cellSize > 60) {\r\n          return 2;\r\n        }\r\n        else if (cellSize > 50) {\r\n          return 1.5;\r\n        }\r\n        return 1;\r\n      },\r\n      lineCap: 'square',\r\n\r\n      //Star points\r\n      star: {\r\n\r\n        //Color and radius\r\n        color: 'rgba(60,40,15,1)',\r\n        radius: function(cellSize) {\r\n          if (cellSize > 50) {\r\n            return Math.floor((cellSize / 16) + 1);\r\n          }\r\n          else if (cellSize > 30) {\r\n            return 3;\r\n          }\r\n          else if (cellSize > 15) {\r\n            return 2;\r\n          }\r\n          else if (cellSize > 5) {\r\n            return 1.5;\r\n          }\r\n          return 1;\r\n        },\r\n\r\n        //Locations\r\n        points: function(width, height) {\r\n\r\n          //19x19\r\n          if (width === height && width === 19) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\r\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\r\n            ];\r\n          }\r\n\r\n          //13x13\r\n          if (width === height && width === 13) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }\r\n            ];\r\n          }\r\n\r\n          //9x9\r\n          if (width === height && width === 9) {\r\n            return [\r\n              { x: 4, y: 4}, { x: 2, y: 2},\r\n              { x: 2, y: 6}, { x: 6, y: 2},\r\n              { x: 6, y: 6}\r\n            ];\r\n          }\r\n\r\n          //No star points\r\n          return [];\r\n        }\r\n      }\r\n    },\r\n\r\n    //Coordinates\r\n    coordinates: {\r\n\r\n      //Color\r\n      color: 'rgba(101,69,37,0.5)',\r\n\r\n      //Board margin factor when showing coordinates\r\n      margin: 1.25,\r\n\r\n      //Vertical coordinates style\r\n      vertical: {\r\n        font: 'Arial',\r\n        style: 'numbers',\r\n        inverse: true,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      },\r\n\r\n      //Horizontal coordinates style\r\n      horizontal: {\r\n        font: 'Arial',\r\n        style: 'letters',\r\n        inverse: false,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Set global default theme\r\n   */\r\n  this.setTheme = function(theme) {\r\n    if (theme) {\r\n      defaultTheme = angular.merge(defaultTheme, theme);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = function() {\r\n\r\n    /**\r\n     * Board theme constructor\r\n     */\r\n    function BoardTheme(theme) {\r\n\r\n      //Remember the given instance theme settings and (re)set the theme\r\n      this.instanceTheme = theme;\r\n      this.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the theme to defaults\r\n     */\r\n    BoardTheme.prototype.reset = function() {\r\n\r\n      //Use default theme as a base\r\n      this.theme = angular.copy(defaultTheme);\r\n\r\n      //Add any instance theme properties\r\n      if (this.instanceTheme) {\r\n        angular.merge(this.theme, this.instanceTheme);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get a theme property\r\n     */\r\n    BoardTheme.prototype.get = function(property) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Can't find the property?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          console.warn('Could not find theme property', property);\r\n          return null;\r\n        }\r\n\r\n        //Advance further in the object\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Found what we're looking for\r\n      if (typeof prop !== 'function') {\r\n        return prop;\r\n      }\r\n\r\n      //Prepare arguments\r\n      var args = [];\r\n      if (arguments.length > 1) {\r\n        for (var a = 1; a < arguments.length; a++) {\r\n          args.push(arguments[a]);\r\n        }\r\n      }\r\n\r\n      //Call function\r\n      return prop.apply(this, args);\r\n    };\r\n\r\n    /**\r\n     * Change a theme property dynamically (accepts handler function as value)\r\n     */\r\n    BoardTheme.prototype.set = function(property, value) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Time to set?\r\n        if ((i + 1) === path.length) {\r\n          prop[path[i]] = value;\r\n          break;\r\n        }\r\n\r\n        //Not set?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          prop[path[i]] = {};\r\n        }\r\n\r\n        //Move on\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\r\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\r\n     */\r\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\r\n\r\n      //If no linewidth specified, use the grid line width as a reference\r\n      //to make sure stuff is aligned to the grid\r\n      if (typeof lineWidth === 'undefined') {\r\n        lineWidth = this.get('grid.lineWidth');\r\n      }\r\n\r\n      //Return a translation for uneven widths\r\n      return (lineWidth % 2) * 0.5;\r\n    };\r\n\r\n    //Return\r\n    return BoardTheme;\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Game :: This class represents a game record or a game that is being played/edited. The class\r\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\r\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\r\n * The class also keeps a stack of all board positions in memory and can validate moves to make\r\n * sure they are not repeating or suicide.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Path.Service',\r\n  'ngGo.Game.Node.Service',\r\n  'ngGo.Game.Position.Service',\r\n  'ngGo.Kifu.Blank.Service',\r\n  'ngGo.Kifu.Parser.Service',\r\n  'ngGo.Errors.InvalidDataError.Service',\r\n  'ngGo.Errors.InvalidPositionError.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('Game', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default size of board\r\n    defaultSize: 0,\r\n\r\n    //Default komi and handicap\r\n    defaultKomi: 0,\r\n    defaultHandicap: 0,\r\n\r\n    //Remember last selected variation when traversing nodes\r\n    rememberPath: true,\r\n\r\n    //Check for repeating positions? (KO / ALL / empty)\r\n    checkRepeat: 'KO',\r\n\r\n    //Allow suicide?\r\n    allowSuicide: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\r\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\r\n    KifuBlank, InvalidDataError, InvalidPositionError\r\n  ) {\r\n\r\n    /*****************************************************************************\r\n     * General helpers\r\n     ***/\r\n\r\n    /**\r\n     * Validate the info we have to make sure the properties exist\r\n     */\r\n    function validateInfo() {\r\n\r\n      //Set board info if not set\r\n      if (!this.info.board) {\r\n        this.info.board = {};\r\n      }\r\n\r\n      //Set game info if not set\r\n      if (!this.info.game) {\r\n        this.info.game = {};\r\n      }\r\n\r\n      //Set defaults\r\n      if (typeof this.info.board.width === 'undefined') {\r\n        this.info.board.width = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.board.height === 'undefined') {\r\n        this.info.board.height = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.game.komi === 'undefined') {\r\n        this.info.game.komi = this.config.defaultKomi;\r\n      }\r\n      if (typeof this.info.game.handicap === 'undefined') {\r\n        this.info.game.handicap = this.config.defaultHandicap;\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Node navigation helpers\r\n     ***/\r\n\r\n    /**\r\n     * Navigate to the next node\r\n     */\r\n    function nextNode(i) {\r\n\r\n      //Check if we have children\r\n      if (this.node.children.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      //Remembered the path we took earlier?\r\n      if (i === undefined) {\r\n        i = this.node.rememberedPath;\r\n      }\r\n\r\n      //Determine which child node to process\r\n      i = i || 0;\r\n      if (i === -1) {\r\n        i = 0;\r\n      }\r\n\r\n      //Validate\r\n      if (i >= this.node.children.length || !this.node.children[i]) {\r\n        return false;\r\n      }\r\n\r\n      //Advance path\r\n      this.path.advance(i);\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.children[i];\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the previous node\r\n     */\r\n    function previousNode() {\r\n\r\n      //No parent node?\r\n      if (!this.node.parent) {\r\n        return false;\r\n      }\r\n\r\n      //Retreat path\r\n      this.path.retreat();\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.parent;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the first node\r\n     */\r\n    function firstNode() {\r\n\r\n      //Reset path\r\n      this.path.reset();\r\n\r\n      //Set node pointer back to root\r\n      this.node = this.root;\r\n\r\n      //Set the initial turn depending on handicap\r\n      //Can be overwritten by game record instructions\r\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Position history helpers\r\n     ***/\r\n\r\n    /**\r\n     * Clear the position history and initialize with a blank position\r\n     */\r\n    function initializeHistory() {\r\n\r\n      //Already at beginning?\r\n      if (this.history.length === 1) {\r\n        return;\r\n      }\r\n\r\n      //Clear positions stack and create new blank position\r\n      this.history = [];\r\n      this.history.push(new GamePosition());\r\n\r\n      //Set board size if we have the info\r\n      if (this.info.board) {\r\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add position to stack. If position isn't specified current position is\r\n     * cloned and stacked. Pointer of actual position is moved to the new position.\r\n     */\r\n    function pushPosition(newPosition) {\r\n\r\n      //Position not given?\r\n      if (!newPosition) {\r\n        newPosition = this.position.clone();\r\n      }\r\n\r\n      //Push\r\n      this.history.push(newPosition);\r\n      return newPosition;\r\n    }\r\n\r\n    /**\r\n     * Remove current position from stack\r\n     */\r\n    function popPosition() {\r\n\r\n      //Nothing left?\r\n      if (this.history.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      //Get old position\r\n      return this.history.pop();\r\n    }\r\n\r\n    /**\r\n     * Replace the current position in the stack\r\n     */\r\n    function replacePosition(newPosition) {\r\n      if (newPosition) {\r\n        this.history.pop();\r\n        this.history.push(newPosition);\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Execution helpers\r\n     ***/\r\n\r\n    /**\r\n     * Execute the current node\r\n     */\r\n    function executeNode() {\r\n\r\n      //Remember last selected node if we have a parent\r\n      if (this.node.parent) {\r\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\r\n      }\r\n\r\n      //Initialize new position\r\n      var i;\r\n      var newPosition = this.position.clone();\r\n\r\n      //Handle moves\r\n      if (this.node.isMove()) {\r\n        if (this.node.move.pass) {\r\n          newPosition.setTurn(-this.node.move.color);\r\n        }\r\n        else {\r\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\r\n        }\r\n      }\r\n\r\n      //Handle turn instructions\r\n      if (this.node.turn) {\r\n        newPosition.setTurn(this.node.turn);\r\n      }\r\n\r\n      //Handle setup instructions\r\n      if (this.node.setup) {\r\n        for (i in this.node.setup) {\r\n          if (this.node.setup.hasOwnProperty(i)) {\r\n            newPosition.stones.set(\r\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Handle markup\r\n      if (this.node.markup) {\r\n        for (i in this.node.markup) {\r\n          if (this.node.markup.hasOwnProperty(i)) {\r\n            newPosition.markup.set(\r\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Push the new position into the history now\r\n      pushPosition.call(this, newPosition);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Game class\r\n     ***/\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Game(data, config) {\r\n\r\n      //Extend config\r\n      this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n      //Define property getter/setter for position\r\n      Object.defineProperty(this, 'position', {\r\n\r\n        //Getter returns the last position from the stack\r\n        get: function() {\r\n          return this.history[this.history.length - 1];\r\n        },\r\n\r\n        //Setter adds a new position to the stack\r\n        set: function(newPosition) {\r\n          this.history[this.history.length] = newPosition;\r\n        }\r\n      });\r\n\r\n      //Load data\r\n      if (data) {\r\n        this.load(data);\r\n      }\r\n      else {\r\n        this.init();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Initialize\r\n     */\r\n    Game.prototype.init = function() {\r\n\r\n      //Info properties\r\n      this.info = {};\r\n\r\n      //The rood node and pointer to the current node\r\n      this.root = null;\r\n      this.node = null;\r\n\r\n      //Game path\r\n      this.path = new GamePath();\r\n\r\n      //JGF record we loaded from\r\n      this.jgf = null;\r\n\r\n      //Positions history stack\r\n      this.history = [];\r\n    };\r\n\r\n    /**\r\n     * Load game record data\r\n     */\r\n    Game.prototype.load = function(data) {\r\n\r\n      //Initialize\r\n      this.init();\r\n\r\n      //Try to load game record data\r\n      try {\r\n        this.fromData(data);\r\n      }\r\n      catch (errorCode) {\r\n\r\n        //Just initialize our history with a blank position\r\n        initializeHistory.call(this);\r\n\r\n        //Wrap error code in error object\r\n        throw new InvalidDataError(errorCode);\r\n      }\r\n\r\n      //Go to the first move\r\n      this.first();\r\n    };\r\n\r\n    /**\r\n     * Reload game record\r\n     */\r\n    Game.prototype.reload = function() {\r\n      if (this.jgf) {\r\n        this.load(this.jgf);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if we managed to load a valid game record\r\n     */\r\n    Game.prototype.isLoaded = function() {\r\n      return this.root !== null;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game cloning and conversion\r\n     ***/\r\n\r\n    /**\r\n     * Clone this game\r\n     */\r\n    Game.prototype.clone = function() {\r\n\r\n      //Create new kifu object and get properties\r\n      var clone = new Game();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy all properties\r\n      for (var p = 0; p < props.length; p++) {\r\n        clone[p] = angular.copy(this[p]);\r\n      }\r\n\r\n      //Return clone\r\n      return clone;\r\n    };\r\n\r\n    /**\r\n     * Load from an unknown data source\r\n     */\r\n    Game.prototype.fromData = function(data) {\r\n\r\n      //No data, can't do much\r\n      if (!data) {\r\n        throw ngGo.error.NO_DATA;\r\n      }\r\n\r\n      //String given, could be stringified JGF, an SGF or GIB file\r\n      if (typeof data === 'string') {\r\n        var c = data.charAt(0);\r\n        if (c === '(') {\r\n          return this.fromSgf(data);\r\n        }\r\n        else if (c === '{' || c === '[') {\r\n          return this.fromJgf(data);\r\n        }\r\n        else if (c === '\\\\') {\r\n          return this.fromGib(data);\r\n        }\r\n        else {\r\n          throw ngGo.error.UNKNOWN_DATA;\r\n        }\r\n      }\r\n\r\n      //Object given? Probably a JGF object\r\n      else if (typeof data === 'object') {\r\n        this.fromJgf(data);\r\n      }\r\n\r\n      //Something else?\r\n      else {\r\n        throw ngGo.error.UNKNOWN_DATA;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Load from GIB data\r\n     */\r\n    Game.prototype.fromGib = function(gib) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.gib2jgf(gib);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_GIB;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from SGF data\r\n     */\r\n    Game.prototype.fromSgf = function(sgf) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.sgf2jgf(sgf);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_SGF;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from JGF data\r\n     */\r\n    Game.prototype.fromJgf = function(jgf) {\r\n\r\n      //Parse jgf string\r\n      if (typeof jgf === 'string') {\r\n        try {\r\n          jgf = angular.fromJson(jgf);\r\n        }\r\n        catch (error) {\r\n          throw ngGo.error.INVALID_JGF_JSON;\r\n        }\r\n      }\r\n\r\n      //If array given, convert to object with only tree\r\n      if (angular.isArray(jgf)) {\r\n        jgf = {\r\n          tree: jgf\r\n        };\r\n      }\r\n\r\n      //Parse tree string\r\n      if (typeof jgf.tree === 'string') {\r\n        if (jgf.tree.charAt(0) === '[') {\r\n          try {\r\n            jgf.tree = angular.fromJson(jgf.tree);\r\n          }\r\n          catch (error) {\r\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\r\n          }\r\n        }\r\n        else {\r\n          jgf.tree = [];\r\n        }\r\n      }\r\n\r\n      //Copy all properties except moves tree\r\n      for (var i in jgf) {\r\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\r\n          this.info[i] = angular.copy(jgf[i]);\r\n        }\r\n      }\r\n\r\n      //Validate info\r\n      validateInfo.call(this);\r\n\r\n      //Create root node\r\n      this.root = new GameNode();\r\n\r\n      //Tree given? Load all the moves\r\n      if (jgf.tree) {\r\n        this.root.fromJgf(jgf.tree);\r\n      }\r\n\r\n      //Remember JGF\r\n      this.jgf = jgf;\r\n    };\r\n\r\n    /**\r\n     * Convert to SGF\r\n     */\r\n    Game.prototype.toSgf = function() {\r\n      return KifuParser.jgf2sgf(this.toJgf());\r\n    };\r\n\r\n    /**\r\n     * Convert to JGF (optionally stringified)\r\n     */\r\n    Game.prototype.toJgf = function(stringify) {\r\n\r\n      //Initialize JGF and get properties\r\n      var jgf = KifuBlank.jgf();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy properties\r\n      for (var p = 0; p < props.length; p++) {\r\n\r\n        //Skip root\r\n        if (p === 'root') {\r\n          continue;\r\n        }\r\n\r\n        //Already present on JGF object? Extend\r\n        if (jgf[p]) {\r\n          jgf[p] = angular.extend(jgf[p], this[p]);\r\n        }\r\n\r\n        //Otherwise copy\r\n        else {\r\n          jgf[p] = angular.copy(this[p]);\r\n        }\r\n      }\r\n\r\n      //Build tree\r\n      jgf.tree = this.root.toJgf();\r\n\r\n      //Return\r\n      return stringify ? angular.toJson(jgf) : jgf;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Getters\r\n     ***/\r\n\r\n    /**\r\n     * Get current node\r\n     */\r\n    Game.prototype.getNode = function() {\r\n      return this.node;\r\n    };\r\n\r\n    /**\r\n     * Get nodes array for currently remembered path\r\n     */\r\n    Game.prototype.getNodes = function() {\r\n\r\n      //Initialize node to process\r\n      var node = this.root;\r\n      var nodes = [node];\r\n\r\n      //Process children\r\n      while (node) {\r\n        node = node.getChild(node.rememberedPath);\r\n        if (node) {\r\n          nodes.push(node);\r\n        }\r\n      }\r\n\r\n      //Return nodes\r\n      return nodes;\r\n    };\r\n\r\n    /**\r\n     * Get node for a certain move\r\n     */\r\n    Game.prototype.getMoveNode = function(move) {\r\n      var nodes = this.getMoveNodes(move, move);\r\n      return nodes.length ? nodes[0] : null;\r\n    };\r\n\r\n    /**\r\n     * Get move nodes restricted by given move numbers\r\n     */\r\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\r\n\r\n      //Get all nodes for the current path\r\n      var nodes = this.getNodes();\r\n\r\n      //Use sensible defaults if no from/to moves given\r\n      fromMove = fromMove || 1;\r\n      toMove = toMove || nodes.length;\r\n\r\n      //Filter\r\n      return nodes.filter(function(node) {\r\n        if (node.isMove()) {\r\n          var move = node.getMoveNumber();\r\n          return (move >= fromMove && move <= toMove);\r\n        }\r\n        return false;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Get current move number\r\n     */\r\n    Game.prototype.getMove = function() {\r\n      if (this.node) {\r\n        return this.node.getMoveNumber();\r\n      }\r\n      return 0;\r\n    };\r\n\r\n    /**\r\n     * Get the number of moves in the main branch\r\n     */\r\n    Game.prototype.getMoveCount = function() {\r\n      var moveNodes = this.getMoveNodes();\r\n      return moveNodes.length;\r\n    };\r\n\r\n    /**\r\n     * Get the move variation for given coordinates\r\n     */\r\n    Game.prototype.getMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.getMoveVariation(x, y);\r\n      }\r\n      return -1;\r\n    };\r\n\r\n    /**\r\n     * Get the current game position\r\n     */\r\n    Game.prototype.getPosition = function() {\r\n      return this.position;\r\n    };\r\n\r\n    /**\r\n     * Get the game path\r\n     */\r\n    Game.prototype.getPath = function(clone) {\r\n      if (clone) {\r\n        return this.path.clone();\r\n      }\r\n      return this.path;\r\n    };\r\n\r\n    /**\r\n     * Clone the current game path\r\n     */\r\n    Game.prototype.clonePath = function() {\r\n      return this.path.clone();\r\n    };\r\n\r\n    /**\r\n     * Get the game path to a certain named node\r\n     */\r\n    Game.prototype.getPathToNode = function(nodeName) {\r\n      return GamePath.findNode(nodeName, this.root);\r\n    };\r\n\r\n    /**\r\n     * Get the game komi\r\n     */\r\n    Game.prototype.getKomi = function() {\r\n      var komi = this.get('game.komi', 0);\r\n      return parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Set the game komi\r\n     */\r\n    Game.prototype.setKomi = function(komi) {\r\n      if (typeof komi === 'undefined') {\r\n        komi = this.config.defaultKomi;\r\n      }\r\n      this.info.game.komi = parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Get the game name\r\n     */\r\n    Game.prototype.getName = function() {\r\n      return this.get('game.name', '');\r\n    };\r\n\r\n    /**\r\n     * Get the game result\r\n     */\r\n    Game.prototype.getResult = function() {\r\n      return this.get('game.result', '');\r\n    };\r\n\r\n    /**\r\n     * Get the player turn for this position\r\n     */\r\n    Game.prototype.getTurn = function() {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return StoneColor.B;\r\n      }\r\n\r\n      //Get from position\r\n      return this.position.getTurn();\r\n    };\r\n\r\n    /**\r\n     * Set the player turn for the current position\r\n     */\r\n    Game.prototype.setTurn = function(color) {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return;\r\n      }\r\n\r\n      //Set in position\r\n      this.position.setTurn(color);\r\n    };\r\n\r\n    /**\r\n     * Get the total capture count up to the current position\r\n     */\r\n    Game.prototype.getCaptureCount = function() {\r\n\r\n      //Initialize\r\n      var captures = {};\r\n      captures[StoneColor.B] = 0;\r\n      captures[StoneColor.W] = 0;\r\n\r\n      //Loop all positions and increment capture count\r\n      for (var i = 0; i < this.history.length; i++) {\r\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\r\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\r\n      }\r\n\r\n      //Return\r\n      return captures;\r\n    };\r\n\r\n    /**\r\n     * Get an info property\r\n     */\r\n    Game.prototype.get = function(property, defaultValue) {\r\n\r\n      //Must have a property\r\n      if (!property) {\r\n        return;\r\n      }\r\n\r\n      //The item's property in the object is given by dot separated strings\r\n      if (typeof property === 'string') {\r\n        property = property.split('.');\r\n      }\r\n\r\n      //Initialize object we're getting info from\r\n      var obj = this.info;\r\n      var key;\r\n\r\n      //Loop the properties\r\n      for (var p = 0; p < property.length; p++) {\r\n\r\n        //Get actual key\r\n        key = property[p];\r\n\r\n        //Last key reached? Done, get value\r\n        if ((p + 1) === property.length) {\r\n          if (typeof obj[key] === 'undefined') {\r\n            return defaultValue;\r\n          }\r\n          return obj[key];\r\n        }\r\n\r\n        //Must be object container\r\n        if (typeof obj[key] !== 'object') {\r\n          console.warn('Game info property', key, 'is not an object');\r\n          return defaultValue;\r\n        }\r\n\r\n        //Move up in tree\r\n        obj = obj[key];\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Checkers\r\n     ***/\r\n\r\n    /**\r\n     * Check if coordinates are on the board\r\n     */\r\n    Game.prototype.isOnBoard = function(x, y) {\r\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\r\n    };\r\n\r\n    /**\r\n     * Check if given coordinates are one of the next child node coordinates\r\n     */\r\n    Game.prototype.isMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.isMoveVariation(x, y);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Check if a given position is repeating within this game\r\n     */\r\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\r\n\r\n      //Init\r\n      var stop;\r\n\r\n      //Check for ko only? (Last two positions)\r\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\r\n        stop = this.history.length - 2;\r\n      }\r\n\r\n      //Check all history?\r\n      else if (this.checkRepeat === 'ALL') {\r\n        stop = 0;\r\n      }\r\n\r\n      //Not repeating\r\n      else {\r\n        return false;\r\n      }\r\n\r\n      //Loop history of positions to check\r\n      for (var i = this.history.length - 2; i >= stop; i--) {\r\n        if (checkPosition.isSameAs(this.history[i])) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      //Not repeating\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Wrapper for validateMove() returning a boolean and catching any errors\r\n     */\r\n    Game.prototype.isValidMove = function(x, y, color) {\r\n      try {\r\n        this.validateMove(x, y, color);\r\n        return true;\r\n      }\r\n      catch (error) {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if a move is valid. If valid, the new game position object is returned.\r\n     * You can supply a pre-created position to use, or the current position is cloned.\r\n     */\r\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Something already here?\r\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\r\n      }\r\n\r\n      //Set color of move to make\r\n      color = color || this.position.getTurn();\r\n\r\n      //Determine position to use\r\n      newPosition = newPosition || this.position.clone();\r\n\r\n      //Place the stone\r\n      newPosition.stones.set(x, y, color);\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = newPosition.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created?\r\n        if (!newPosition.hasLiberties(x, y)) {\r\n\r\n          //Capture the group if it's allowed\r\n          if (this.allowSuicide) {\r\n            newPosition.captureGroup(x, y);\r\n          }\r\n\r\n          //Invalid move\r\n          else {\r\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Check history for repeating moves\r\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\r\n      }\r\n\r\n      //Set proper turn\r\n      newPosition.setTurn(-color);\r\n\r\n      //Move is valid\r\n      return newPosition;\r\n    };\r\n\r\n    /**\r\n     * Check if a stone (setup) placement is valid.\r\n     */\r\n    Game.prototype.validatePlacement = function(x, y, color, position) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Place the stone\r\n      position.stones.set(x, y, color);\r\n\r\n      //Empty spot? Don't need to check for captures\r\n      if (color === StoneColor.EMPTY) {\r\n        return;\r\n      }\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = position.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created? Capture it\r\n        if (!position.hasLiberties(x, y)) {\r\n          position.captureGroup(x, y);\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Stone and markup handling\r\n     ***/\r\n\r\n    /**\r\n     * Add a stone\r\n     */\r\n    Game.prototype.addStone = function(x, y, color) {\r\n\r\n      //Check if there's anything to do at all\r\n      if (this.position.stones.is(x, y, color)) {\r\n        return;\r\n      }\r\n\r\n      //Create temporary position\r\n      var tempPosition = this.position.clone();\r\n\r\n      //Validate placement on temp position\r\n      this.validatePlacement(x, y, color, tempPosition);\r\n\r\n      //No setup instructions container in this node?\r\n      if (typeof this.node.setup === 'undefined') {\r\n\r\n        //Is this a move node?\r\n        if (this.node.isMove()) {\r\n\r\n          //Clone our position\r\n          pushPosition.call(this);\r\n\r\n          //Create new node\r\n          var node = new GameNode();\r\n\r\n          //Append it to the current node and change the pointer\r\n          var i = node.appendTo(this.node);\r\n          this.node = node;\r\n\r\n          //Advance path to the added node index\r\n          this.path.advance(i);\r\n        }\r\n\r\n        //Create setup container in this node\r\n        this.node.setup = [];\r\n      }\r\n\r\n      //Replace current position\r\n      replacePosition.call(this, tempPosition);\r\n\r\n      //Add setup instructions to node\r\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\r\n    };\r\n\r\n    /**\r\n     * Add markup\r\n     */\r\n    Game.prototype.addMarkup = function(x, y, markup) {\r\n\r\n      //No markup instructions container in this node?\r\n      if (typeof this.node.markup === 'undefined') {\r\n        this.node.markup = [];\r\n      }\r\n\r\n      //Add markup to game position\r\n      this.position.markup.set(x, y, markup);\r\n\r\n      //Add markup instructions to node\r\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\r\n    };\r\n\r\n    /**\r\n     * Remove a stone\r\n     */\r\n    Game.prototype.removeStone = function(x, y) {\r\n\r\n      //Check if the stone is found in setup instructions\r\n      var foundInSetup = false;\r\n\r\n      //Remove from node setup instruction\r\n      if (typeof this.node.setup !== 'undefined') {\r\n        for (var i = 0; i < this.node.setup.length; i++) {\r\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\r\n\r\n            //Remove from node and unset in position\r\n            this.node.setup.splice(i, 1);\r\n            this.position.stones.unset(x, y);\r\n\r\n            //Mark as found\r\n            foundInSetup = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Not found in setup? Add as no stone color\r\n      if (!foundInSetup) {\r\n        this.addStone(x, y, StoneColor.EMPTY);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove markup\r\n     */\r\n    Game.prototype.removeMarkup = function(x, y) {\r\n\r\n      //Remove from node\r\n      if (typeof this.node.markup !== 'undefined') {\r\n        for (var i = 0; i < this.node.markup.length; i++) {\r\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\r\n            this.node.markup.splice(i, 1);\r\n            this.position.markup.unset(x, y);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if there is a stone at the given coordinates for the current position\r\n     */\r\n    Game.prototype.hasStone = function(x, y, color) {\r\n      if (typeof color !== 'undefined') {\r\n        return this.position.stones.is(x, y, color);\r\n      }\r\n      return this.position.stones.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Check if there is markup at the given coordinate for the current position\r\n     */\r\n    Game.prototype.hasMarkup = function(x, y, type) {\r\n      if (typeof type !== 'undefined') {\r\n        return this.position.markup.is(x, y, type);\r\n      }\r\n      return this.position.markup.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get stone on coordinates\r\n     */\r\n    Game.prototype.getStone = function(x, y) {\r\n      return this.position.stones.get(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get markup on coordinates\r\n     */\r\n    Game.prototype.getMarkup = function(x, y) {\r\n      return this.position.markup.get(x, y);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Move handling\r\n     ***/\r\n\r\n    /**\r\n     * Play move\r\n     */\r\n    Game.prototype.play = function(x, y, color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Validate move and get new position\r\n      var newPosition = this.validateMove(x, y, color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          x: x,\r\n          y: y,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n\r\n      //Valid move\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Play pass\r\n     */\r\n    Game.prototype.pass = function(color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Initialize new position and switch the turn\r\n      var newPosition = this.position.clone();\r\n      newPosition.setTurn(-color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          pass: true,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game tree navigation\r\n     ***/\r\n\r\n    /**\r\n     * Go to the next position\r\n     */\r\n    Game.prototype.next = function(i) {\r\n\r\n      //Object (node) given as parameter? Find index\r\n      if (typeof i === 'object') {\r\n        i = this.node.children.indexOf(i);\r\n      }\r\n\r\n      //Go to the next node\r\n      if (nextNode.call(this, i)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n          return true;\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      //Didn't go to next position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the previous position\r\n     */\r\n    Game.prototype.previous = function() {\r\n\r\n      //Go to the previous node\r\n      if (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        return true;\r\n      }\r\n\r\n      //Didn't go to previous position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the last position\r\n     */\r\n    Game.prototype.last = function() {\r\n\r\n      //Keep going to the next node until we reach the end\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the first position\r\n     */\r\n    Game.prototype.first = function() {\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      executeNode.call(this);\r\n    };\r\n\r\n    /**\r\n     * Go to position specified by a path object, a numeric move numer, or a node name string\r\n     */\r\n    Game.prototype.goto = function(target) {\r\n\r\n      //Must have a tree\r\n      if (this.root === null) {\r\n        return;\r\n      }\r\n\r\n      //Nothing given?\r\n      if (typeof target === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      //Function given? Call now\r\n      if (typeof target === 'function') {\r\n        target = target.call(this);\r\n      }\r\n\r\n      //Initialize path\r\n      var path;\r\n\r\n      //Simple move number? Convert to path object\r\n      if (typeof target === 'number') {\r\n        path = this.path.clone();\r\n        path.setMove(target);\r\n      }\r\n\r\n      //String? Named node\r\n      else if (typeof target === 'string') {\r\n\r\n        //Already here?\r\n        if (this.node.name === target) {\r\n          return;\r\n        }\r\n\r\n        //Find path to node\r\n        path = this.getPathToNode(target);\r\n        if (path === null) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Otherwise assume path object\r\n      else {\r\n        path = target;\r\n      }\r\n\r\n      //Already here?\r\n      if (this.path.compare(path)) {\r\n        return;\r\n      }\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      pushPosition.call(this);\r\n      executeNode.call(this);\r\n\r\n      //Loop path\r\n      var n = path.getMove();\r\n      for (var i = 0; i < n; i++) {\r\n\r\n        //Try going to the next node\r\n        if (!nextNode.call(this, path.nodeAt(i))) {\r\n          break;\r\n        }\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next fork\r\n     */\r\n    Game.prototype.nextFork = function() {\r\n\r\n      //Keep going to the next node until we reach one with multiple children\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Have multiple children?\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous fork\r\n     */\r\n    Game.prototype.previousFork = function() {\r\n\r\n      //Loop until we find a node with more than one child\r\n      while (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next move with comments\r\n     */\r\n    Game.prototype.nextComment = function() {\r\n\r\n      //Keep going to the next node until we find one with comments\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous move with comments\r\n     */\r\n    Game.prototype.previousComment = function() {\r\n\r\n      //Go back until we find a node with comments\r\n      while (previousNode.call(this)) {\r\n\r\n        //Pop the position\r\n        popPosition.call(this);\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state\r\n     */\r\n    Game.prototype.getState = function() {\r\n\r\n      //Can only create when we have a JGF and path\r\n      if (!this.jgf || !this.path) {\r\n        return null;\r\n      }\r\n\r\n      //Create state\r\n      var state = {\r\n        jgf: this.jgf,\r\n        path: this.path.clone()\r\n      };\r\n\r\n      //Return\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the game state\r\n     */\r\n    Game.prototype.restoreState = function(state) {\r\n\r\n      //Must have jgf and path\r\n      if (!state || !state.jgf || !state.path) {\r\n        return;\r\n      }\r\n\r\n      //Restore state\r\n      this.load(state.jgf);\r\n      this.goto(state.path);\r\n    };\r\n\r\n    //Return object\r\n    return Game;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameNode :: This class represents a single node in the game moves tree. It contains\r\n * properties like the x and y grid coordinates, the move played, board setup instructions,\r\n * markup, player turn and comments. The moves tree in the game record is represented by a\r\n * string of GameNodes, each with pointers to their parent and children. Each node can have\r\n * multiple children (move variations), but only one parent.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Node.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameNode', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /**\r\n   * Helper to construct a coordinates base object\r\n   */\r\n  function coordinatesObject(coords, baseObject) {\r\n    baseObject = baseObject || {};\r\n    if (coords === '' || coords === 'pass') {\r\n      baseObject.pass = true;\r\n    }\r\n    else {\r\n\r\n      //Backwards compatibility with SGF string coordinates in JGF\r\n      if (typeof coords === 'string') {\r\n        coords = convertCoordinates(coords);\r\n      }\r\n\r\n      //Append coordinates\r\n      baseObject.x = coords[0] * 1;\r\n      baseObject.y = coords[1] * 1;\r\n    }\r\n    return baseObject;\r\n  }\r\n\r\n  /**\r\n   * Convert a numeric color value (color constant) to a string\r\n   */\r\n  function toStringColor(color) {\r\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\r\n  }\r\n\r\n  /**\r\n   * Convert a string color value to a numeric color constant\r\n   */\r\n  function toColorConstant(color) {\r\n    if (color === 'B') {\r\n      return StoneColor.B;\r\n    }\r\n    else if (color === 'W') {\r\n      return StoneColor.W;\r\n    }\r\n    return StoneColor.E;\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Helpers for conversion between JGF / KIFU format\r\n   ***/\r\n\r\n  /**\r\n   * Convert move object to JGF format\r\n   */\r\n  function convertMoveToJgf(move) {\r\n\r\n    //Initialize JGF move object and determine color\r\n    var jgfMove = angular.copy(move);\r\n    var color = toStringColor(move.color);\r\n\r\n    //No color?\r\n    if (color === '') {\r\n      return null;\r\n    }\r\n\r\n    //Pass move?\r\n    if (move.pass === true) {\r\n      jgfMove[color] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      jgfMove[color] = [move.x, move.y];\r\n    }\r\n\r\n    //Delete coordinates and color\r\n    delete jgfMove.x;\r\n    delete jgfMove.y;\r\n    delete jgfMove.color;\r\n\r\n    //Return move\r\n    return jgfMove;\r\n  }\r\n\r\n  /**\r\n   * Convert move from JGF format\r\n   */\r\n  function convertMoveFromJgf(move) {\r\n\r\n    //Prepare color, coordinates\r\n    var color, coords;\r\n\r\n    //Check whose move it was\r\n    if (move.W) {\r\n      color = 'W';\r\n      coords = move.W;\r\n    }\r\n    else if (move.B) {\r\n      color = 'B';\r\n      coords = move.B;\r\n    }\r\n\r\n    //No coordinates?\r\n    if (!coords) {\r\n      return null;\r\n    }\r\n\r\n    //Return coordinates object\r\n    return coordinatesObject(coords, {\r\n      color: toColorConstant(color)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert setup object to JGF format\r\n   */\r\n  function convertSetupToJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var i, color;\r\n    var jgfSetup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in setup) {\r\n      if (setup.hasOwnProperty(i)) {\r\n\r\n        //Get color\r\n        color = toStringColor(setup[i].color) || 'E';\r\n\r\n        //Initialize array\r\n        if (typeof jgfSetup[color] === 'undefined') {\r\n          jgfSetup[color] = [];\r\n        }\r\n\r\n        //Add coordinates\r\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert setup from JGF format\r\n   */\r\n  function convertSetupFromJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var c, key, color;\r\n    var gameSetup = [];\r\n\r\n    //Loop setup\r\n    for (key in setup) {\r\n      if (setup.hasOwnProperty(key)) {\r\n\r\n        //Get color constant\r\n        color = toColorConstant(key);\r\n\r\n        //Loop coordinates\r\n        for (c in setup[key]) {\r\n          if (setup[key].hasOwnProperty(c)) {\r\n            gameSetup.push(coordinatesObject(setup[key][c], {\r\n              color: color\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup object to JGF format\r\n   */\r\n  function convertMarkupToJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var i, type;\r\n    var jgfMarkup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in markup) {\r\n      if (markup.hasOwnProperty(i)) {\r\n\r\n        //Get type\r\n        type = markup[i].type;\r\n\r\n        //Initialize array\r\n        if (typeof jgfMarkup[type] === 'undefined') {\r\n          jgfMarkup[type] = [];\r\n        }\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\r\n        }\r\n        else {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup from JGF format\r\n   */\r\n  function convertMarkupFromJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var l, type;\r\n    var gameMarkup = [];\r\n\r\n    //Loop markup types\r\n    for (type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          for (l = 0; l < markup[type].length; l++) {\r\n\r\n            //Validate\r\n            if (!angular.isArray(markup[type][l])) {\r\n              continue;\r\n            }\r\n\r\n            //SGF type coordinates?\r\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\r\n              var text = markup[type][l][1];\r\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\r\n              markup[type][l].push(text);\r\n            }\r\n\r\n            //Validate length\r\n            if (markup[type][l].length < 3) {\r\n              continue;\r\n            }\r\n\r\n            //Add to stack\r\n            gameMarkup.push(coordinatesObject(markup[type][l], {\r\n              type: type,\r\n              text: markup[type][l][2]\r\n            }));\r\n          }\r\n        }\r\n        else {\r\n\r\n          //Loop coordinates\r\n          for (l in markup[type]) {\r\n            if (markup[type].hasOwnProperty(l)) {\r\n              gameMarkup.push(coordinatesObject(markup[type][l], {\r\n                type: type\r\n              }));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert turn object to JGF format\r\n   */\r\n  function convertTurnToJgf(turn) {\r\n    switch (turn) {\r\n      case StoneColor.W:\r\n        return 'W';\r\n      case StoneColor.B:\r\n        return 'B';\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert turn from JGF format\r\n   */\r\n  function convertTurnFromJgf(turn) {\r\n    switch (turn) {\r\n      case 'W':\r\n        return StoneColor.W;\r\n      case 'B':\r\n        return StoneColor.B;\r\n      default:\r\n        return StoneColor.EMPTY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Conversions map\r\n   */\r\n  var conversionMap = {\r\n    toJgf: {\r\n      move: convertMoveToJgf,\r\n      setup: convertSetupToJgf,\r\n      markup: convertMarkupToJgf,\r\n      turn: convertTurnToJgf\r\n    },\r\n    fromJgf: {\r\n      move: convertMoveFromJgf,\r\n      setup: convertSetupFromJgf,\r\n      markup: convertMarkupFromJgf,\r\n      turn: convertTurnFromJgf\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameNode(properties, parent) {\r\n\r\n    //Set parent and children\r\n    this.parent = parent || null;\r\n    this.children = [];\r\n\r\n    //Save properties\r\n    if (properties) {\r\n      for (var key in properties) {\r\n        if (properties.hasOwnProperty(key)) {\r\n          this[key] = properties[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get node's child specified by index or null if doesn't exist\r\n   */\r\n  GameNode.prototype.getChild = function(i) {\r\n    i = i || 0;\r\n    if (this.children[i]) {\r\n      return this.children[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Get all the children\r\n   */\r\n  GameNode.prototype.getChildren = function() {\r\n    return this.children;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has any chilren\r\n   */\r\n  GameNode.prototype.hasChildren = function() {\r\n    return (this.children.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Get parent node\r\n   */\r\n  GameNode.prototype.getParent = function() {\r\n    return this.parent;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has more than one move variation\r\n   */\r\n  GameNode.prototype.hasMoveVariations = function() {\r\n\r\n    //Less than two child nodes?\r\n    if (this.children.length <= 1) {\r\n      return false;\r\n    }\r\n\r\n    //Loop children\r\n    var moveVariations = 0;\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations++;\r\n      }\r\n\r\n      //More than one move node present?\r\n      if (moveVariations > 1) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //No move variations\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Get all the move variation nodes\r\n   */\r\n  GameNode.prototype.getMoveVariations = function() {\r\n\r\n    //No child nodes?\r\n    if (this.children.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize\r\n    var moveVariations = [];\r\n\r\n    //Loop child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations.push(this.children[i]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return moveVariations;\r\n  };\r\n\r\n  /**\r\n   * Get the move variation for given coordinates\r\n   */\r\n  GameNode.prototype.getMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return -1;\r\n  };\r\n\r\n  /**\r\n   * Check if given coordinates are one of the next child node coordinates\r\n   */\r\n  GameNode.prototype.isMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if we have comments\r\n   */\r\n  GameNode.prototype.hasComments = function() {\r\n    return (this.comments && this.comments.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Check if this is a move node\r\n   */\r\n  GameNode.prototype.isMove = function() {\r\n    return !!this.move;\r\n  };\r\n\r\n  /**\r\n   * Get move number\r\n   */\r\n  GameNode.prototype.getMoveNumber = function() {\r\n\r\n    //Move node?\r\n    if (this.isMove()) {\r\n      if (this.parent) {\r\n        return this.parent.getMoveNumber() + 1;\r\n      }\r\n      return 1;\r\n    }\r\n\r\n    //Use parent move number if we have one\r\n    if (this.parent) {\r\n      return this.parent.getMoveNumber();\r\n    }\r\n\r\n    //No parent\r\n    return 0;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Node manipulation\r\n   ***/\r\n\r\n  /**\r\n   * Remove this node from its parent\r\n   */\r\n  GameNode.prototype.remove = function() {\r\n\r\n    //Can't remove if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found remove it\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1) {\r\n      this.parent.children.splice(i, 1);\r\n    }\r\n\r\n    //Clear parent reference\r\n    this.parent = null;\r\n  };\r\n\r\n  /**\r\n   * Move the node up in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveUp = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i > 0) {\r\n      var temp = this.parent.children[i - 1];\r\n      this.parent.children[i - 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Move the node down in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveDown = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\r\n      var temp = this.parent.children[i + 1];\r\n      this.parent.children[i + 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Append this node to another node\r\n   */\r\n  GameNode.prototype.appendTo = function(node) {\r\n\r\n    //Remove from existing parent\r\n    this.remove();\r\n\r\n    //Set new parent\r\n    this.parent = node;\r\n    node.children.push(this);\r\n    return node.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Append child node to this node.\r\n   */\r\n  GameNode.prototype.appendChild = function(node) {\r\n    node.parent = this;\r\n    this.children.push(node);\r\n    return this.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Insert another node after this one\r\n   */\r\n  GameNode.prototype.insertNode = function(node) {\r\n\r\n    //Loop our children and change parent node\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      this.children[i].parent = node;\r\n    }\r\n\r\n    //Merge children, set this node as the parent of given node\r\n    node.children = node.children.concat(this.children);\r\n    node.parent = this;\r\n\r\n    //Set given node as the child of this node\r\n    this.children = [node];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * JGF conversion\r\n   ***/\r\n\r\n  /**\r\n   * Build a Game Node from a given JGF tree\r\n   */\r\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\r\n\r\n    //Root JGF file given?\r\n    if (typeof jgf.tree !== 'undefined') {\r\n      return GameNode.fromJgf(jgf.tree, gameNode);\r\n    }\r\n\r\n    //Initialize helper vars\r\n    var variationNode, nextNode, i, j;\r\n\r\n    //Node to work with given? Otherwise, work with ourselves\r\n    gameNode = gameNode || this;\r\n\r\n    //Loop moves in the JGF tree\r\n    for (i = 0; i < jgf.length; i++) {\r\n\r\n      //Array? That means a variation branch\r\n      if (angular.isArray(jgf[i])) {\r\n\r\n        //Loop variation stacks\r\n        for (j = 0; j < jgf[i].length; j++) {\r\n\r\n          //Build the variation node\r\n          variationNode = new GameNode();\r\n          variationNode.fromJgf(jgf[i][j]);\r\n\r\n          //Append to working node\r\n          gameNode.appendChild(variationNode);\r\n        }\r\n      }\r\n\r\n      //Regular node\r\n      else {\r\n\r\n        //Get properties to copy\r\n        var properties = Object.getOwnPropertyNames(jgf[i]);\r\n\r\n        //Copy node properties\r\n        for (var key in properties) {\r\n          if (properties.hasOwnProperty(key)) {\r\n            var prop = properties[key];\r\n\r\n            //Conversion function present?\r\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\r\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\r\n            }\r\n            else if (typeof jgf[i][prop] === 'object') {\r\n              gameNode[prop] = angular.copy(jgf[i][prop]);\r\n            }\r\n            else {\r\n              gameNode[prop] = jgf[i][prop];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Next element is a regular node? Prepare new working node\r\n      //Otherwise, if there are no more nodes or if the next element is\r\n      //an array (e.g. variations), we keep our working node as the current one\r\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\r\n        nextNode = new GameNode();\r\n        gameNode.appendChild(nextNode);\r\n        gameNode = nextNode;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Convert this node to a JGF node container\r\n   */\r\n  GameNode.prototype.toJgf = function(container) {\r\n\r\n    //Initialize container to add nodes to\r\n    container = container || [];\r\n\r\n    //Initialize node and get properties\r\n    var node = {};\r\n    var properties = Object.getOwnPropertyNames(this);\r\n\r\n    //Copy node properties\r\n    for (var key in properties) {\r\n      if (properties.hasOwnProperty(key)) {\r\n        var prop = properties[key];\r\n\r\n        //Skip some properties\r\n        if (prop === 'parent' || prop === 'children') {\r\n          continue;\r\n        }\r\n\r\n        //Conversion function present?\r\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\r\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\r\n        }\r\n        else if (typeof this[prop] === 'object') {\r\n          node[prop] = angular.copy(this[prop]);\r\n        }\r\n        else {\r\n          node[prop] = this[prop];\r\n        }\r\n      }\r\n    }\r\n\r\n    //Add node to container\r\n    container.push(node);\r\n\r\n    //Variations present?\r\n    if (this.children.length > 1) {\r\n\r\n      //Create variations container\r\n      var variationsContainer = [];\r\n      container.push(variationsContainer);\r\n\r\n      //Loop child (variation) nodes\r\n      for (var i = 0; i < this.children.length; i++) {\r\n\r\n        //Create container for this variation\r\n        var variationContainer = [];\r\n        variationsContainer.push(variationContainer);\r\n\r\n        //Call child node converter\r\n        this.children[i].toJgf(variationContainer);\r\n      }\r\n    }\r\n\r\n    //Just one child?\r\n    else if (this.children.length === 1) {\r\n      this.children[0].toJgf(container);\r\n    }\r\n\r\n    //Return container\r\n    return container;\r\n  };\r\n\r\n  //Return object\r\n  return GameNode;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePath :: A simple class that keeps track of a path taken in a game.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Path.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePath', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePath() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Reset\r\n   */\r\n  GamePath.prototype.reset = function() {\r\n    this.move = 0;\r\n    this.path = {};\r\n    this.branches = 0;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Advance a move\r\n   */\r\n  GamePath.prototype.advance = function(i) {\r\n\r\n    //Different child variation chosen? Remember\r\n    if (i > 0) {\r\n      this.path[this.move] = 1;\r\n      this.branches++;\r\n    }\r\n\r\n    //Increment move\r\n    this.move++;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Retreat a move\r\n   */\r\n  GamePath.prototype.retreat = function() {\r\n\r\n    //At start?\r\n    if (this.move === 0) {\r\n      return;\r\n    }\r\n\r\n    //Delete path choice\r\n    if (this.path[this.move]) {\r\n      delete this.path[this.move];\r\n      this.branches--;\r\n    }\r\n\r\n    //Decrement move\r\n    this.move--;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Go to a specific move number\r\n   */\r\n  GamePath.prototype.setMove = function(no) {\r\n\r\n    //Less than our current move? We need to erase any paths above the move number\r\n    if (no < this.move) {\r\n      for (var i in this.path) {\r\n        if (i > no) {\r\n          delete this.path[i];\r\n          this.branches--;\r\n        }\r\n      }\r\n    }\r\n\r\n    //Set move number\r\n    this.move = no;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the move number\r\n   */\r\n  GamePath.prototype.getMove = function() {\r\n    return this.move;\r\n  };\r\n\r\n  /**\r\n   * Get the node choice at a specific move number\r\n   */\r\n  GamePath.prototype.nodeAt = function(no) {\r\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\r\n  };\r\n\r\n  /**\r\n   * Compare to another path\r\n   */\r\n  GamePath.prototype.compare = function(otherPath) {\r\n\r\n    //Invalid object?\r\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    //Different move number or path length?\r\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\r\n      return false;\r\n    }\r\n\r\n    //Check path\r\n    for (var i in this.path) {\r\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    //Same path!\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clone\r\n   */\r\n  GamePath.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newPath = new GamePath();\r\n\r\n    //Set vars\r\n    newPath.move = this.move;\r\n    newPath.branches = this.branches;\r\n    newPath.path = angular.copy(this.path);\r\n\r\n    //Return\r\n    return newPath;\r\n  };\r\n\r\n  /**\r\n   * Helper to find node name recursively\r\n   */\r\n  function findNodeName(node, nodeName, path) {\r\n\r\n    //Found in this node?\r\n    if (node.name && node.name === nodeName) {\r\n      return true;\r\n    }\r\n\r\n    //Loop children\r\n    for (var i = 0; i < node.children.length; i++) {\r\n\r\n      //Advance path\r\n      path.advance(i);\r\n\r\n      //Found in child node?\r\n      if (findNodeName(node.children[i], nodeName, path)) {\r\n        return true;\r\n      }\r\n\r\n      //Not found in this child node, retreat path\r\n      path.retreat();\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Static helper to create a path object to reach a certain node\r\n   */\r\n  GamePath.findNode = function(nodeName, rootNode) {\r\n\r\n    //Create new instance\r\n    var path = new GamePath();\r\n\r\n    //Find the node name\r\n    if (findNodeName(rootNode, nodeName, path)) {\r\n      return path;\r\n    }\r\n\r\n    //Not found\r\n    return null;\r\n  };\r\n\r\n  //Return\r\n  return GamePath;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\r\n * markup on the board in this position, as well as any captures that were made and which player's\r\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\r\n * compare changes to other positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Position.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePosition(width, height) {\r\n\r\n    //Initialize\r\n    this.error = 0;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.stones = new BoardGrid();\r\n    this.markup = new BoardGrid();\r\n    this.turn = StoneColor.B;\r\n\r\n    //Initialize captures\r\n    this.captures = {};\r\n    this.captures[StoneColor.B] = [];\r\n    this.captures[StoneColor.W] = [];\r\n\r\n    //Set empty value for stones grid\r\n    this.stones.whenEmpty(StoneColor.EMPTY);\r\n\r\n    //Set size\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  GamePosition.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Set in grids\r\n    this.stones.setSize(width, height);\r\n    this.markup.setSize(width, height);\r\n\r\n    //Empty the position\r\n    this.empty();\r\n  };\r\n\r\n  /**\r\n   * Clear the whole position\r\n   */\r\n  GamePosition.prototype.empty = function() {\r\n    this.stones.empty();\r\n    this.markup.empty();\r\n  };\r\n\r\n  /**\r\n   * Sets stone color at given coordinates.\r\n   */\r\n  GamePosition.prototype.setStone = function(x, y, color) {\r\n    this.stones.set(x, y, color);\r\n  };\r\n\r\n  /**\r\n   * Sets markup type at given coordinates.\r\n   */\r\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\r\n    this.markup.set(x, y, markup);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Liberties and capturing\r\n   ***/\r\n\r\n  /**\r\n   * Check if a group of given color has liberties, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\r\n\r\n    //Out of bounds? No liberties outside of the board\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize tested grid if needed\r\n    tested = tested || new BoardGrid(this.width, this.height);\r\n\r\n    //See what color is present on the coordinates\r\n    var color = this.stones.get(x, y);\r\n\r\n    //If no group color was given, use what's on the position\r\n    groupColor = groupColor || color;\r\n\r\n    //Already tested, or enemy stone? Not giving any liberties\r\n    if (tested.get(x, y) === true || color === -groupColor) {\r\n      return false;\r\n    }\r\n\r\n    //Empty? That's a liberty\r\n    if (color === StoneColor.EMPTY) {\r\n      return true;\r\n    }\r\n\r\n    //Mark this position as tested now\r\n    tested.set(x, y, true);\r\n\r\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\r\n    //If we get at least one true, we have a liberty\r\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\r\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\r\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\r\n        this.hasLiberties(x + 1, y, groupColor, tested);\r\n  };\r\n\r\n  /**\r\n   * Helper to capture adjacent groups\r\n   */\r\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    friendlyColor = friendlyColor || this.stones.get(x, y);\r\n\r\n    //Can't capture empty spots\r\n    if (friendlyColor === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Flag to see if we captured stuff\r\n    var captured = false;\r\n\r\n    //Check adjacent positions now, capturing stones in the process if possible\r\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n\r\n    //Return\r\n    return captured;\r\n  };\r\n\r\n  /**\r\n   * Helper if we can capture a certain group\r\n   */\r\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\r\n\r\n    //Out of bounds? Nothing to capture\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Empty spot? Can't capture\r\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //We need to have a stone of matching group color in order to be able to capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //There is a capturable stone, let's see if it has any liberties left\r\n    if (this.hasLiberties(x, y, enemyColor)) {\r\n      return false;\r\n    }\r\n\r\n    //No liberties left, the group is capturable. Capture if we want to\r\n    if (doCapture) {\r\n      this.captureGroup(x, y, enemyColor);\r\n    }\r\n\r\n    //Capturable\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a group of certain color, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //If no group color was given, use what's on the position\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //Stone at position does not match the given group color? Can't capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //Capture the stone\r\n    this.captureStone(x, y);\r\n\r\n    //Capture the rest of the group\r\n    this.captureGroup(x, y - 1, enemyColor);\r\n    this.captureGroup(x, y + 1, enemyColor);\r\n    this.captureGroup(x - 1, y, enemyColor);\r\n    this.captureGroup(x + 1, y, enemyColor);\r\n\r\n    //At least one stone was captured\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a stone at given coordinates\r\n   */\r\n  GamePosition.prototype.captureStone = function(x, y) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get color\r\n    var color = this.stones.get(x, y);\r\n\r\n    //Empty?\r\n    if (color === StoneColor.EMPTY) {\r\n      return;\r\n    }\r\n\r\n    //Ok, stone present, capture it\r\n    this.stones.set(x, y, StoneColor.EMPTY);\r\n    this.captures[color].push({x: x, y: y});\r\n  };\r\n\r\n  /**\r\n   * Set captures for a color (expects array with capture object coordinates)\r\n   */\r\n  GamePosition.prototype.setCaptures = function(color, captures) {\r\n    this.captures[color] = captures;\r\n  };\r\n\r\n  /**\r\n   * Get captures for a color\r\n   */\r\n  GamePosition.prototype.getCaptures = function(color) {\r\n    return this.captures[color] || [];\r\n  };\r\n\r\n  /**\r\n   * Get the capture count for a color (= the number of captures of the opposing color)\r\n   */\r\n  GamePosition.prototype.getCaptureCount = function(color) {\r\n    return this.captures[-color].length;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Turn control\r\n   ***/\r\n\r\n  /**\r\n   * Set color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.setTurn = function(color) {\r\n    this.turn = color;\r\n  };\r\n\r\n  /**\r\n   * Get color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.getTurn = function() {\r\n    return this.turn;\r\n  };\r\n\r\n  /**\r\n   * Switch the player turn on this position\r\n   */\r\n  GamePosition.prototype.switchTurn = function() {\r\n    this.turn = -this.turn;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Cloning and comparison\r\n   ***/\r\n\r\n  /**\r\n   * Clones the whole position except turn and captures\r\n   */\r\n  GamePosition.prototype.clone = function() {\r\n\r\n    //Create a new position\r\n    var newPosition = new GamePosition();\r\n\r\n    //Set vars manually for maximum efficiency\r\n    newPosition.turn = this.turn;\r\n    newPosition.width = this.width;\r\n    newPosition.height = this.height;\r\n    newPosition.stones = this.stones.clone();\r\n    newPosition.markup = new BoardGrid(this.width, this.height);\r\n\r\n    //Return\r\n    return newPosition;\r\n  };\r\n\r\n  /**\r\n   * Checks if a given position is the same as the current position\r\n   */\r\n  GamePosition.prototype.isSameAs = function(newPosition) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\r\n      return false;\r\n    }\r\n\r\n    //Compare the grids\r\n    return this.stones.isSameAs(newPosition.stones);\r\n  };\r\n\r\n  //Return\r\n  return GamePosition;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScore :: A simple class that contains a game score\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Score.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScore', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Helper to calculate the total points\r\n   */\r\n  function calcTotal() {\r\n    return parseInt(this.stones) + parseInt(this.territory) +\r\n      parseInt(this.captures) + parseInt(this.komi);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameScore() {\r\n\r\n    //Get self\r\n    var self = this;\r\n\r\n    //Setup score containers\r\n    this.black = {};\r\n    this.white = {};\r\n\r\n    //Initialize\r\n    this.reset();\r\n\r\n    //Add total handlers\r\n    this.black.total = function() {\r\n      return calcTotal.call(self.black);\r\n    };\r\n    this.white.total = function() {\r\n      return calcTotal.call(self.white);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the game score\r\n   */\r\n  GameScore.prototype.reset = function() {\r\n\r\n    //Get properties to loop\r\n    var props = ['stones', 'territory', 'captures', 'komi'];\r\n\r\n    //Score for black player\r\n    for (var i = 0; i < props.length; i++) {\r\n      this.black[props[i]] = 0;\r\n      this.white[props[i]] = 0;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the winner\r\n   */\r\n  GameScore.prototype.winner = function() {\r\n\r\n    //Get totals\r\n    var b = this.black.total();\r\n    var w = this.white.total();\r\n\r\n    //Determine winner\r\n    if (w > b) {\r\n      return StoneColor.W;\r\n    }\r\n    else if (b > w) {\r\n      return StoneColor.B;\r\n    }\r\n    return StoneColor.E;\r\n  };\r\n\r\n  //Return\r\n  return GameScore;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScorer :: This class is used to determine the score of a certain game position. It also\r\n * provides handling of manual adjustment of dead / living groups.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Scorer.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Score.Service',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Possible score states\r\n   */\r\n  var scoreState = {\r\n    UNKNOWN: StoneColor.EMPTY,\r\n    BLACK_STONE: StoneColor.B,\r\n    WHITE_STONE: StoneColor.W,\r\n    BLACK_CANDIDATE: StoneColor.B * 2,\r\n    WHITE_CANDIDATE: StoneColor.W * 2,\r\n    NEUTRAL: StoneColor.B * 3\r\n  };\r\n\r\n  /**\r\n   * Helper to set territory\r\n   */\r\n  function territorySet(x, y, candidateColor, boundaryColor) {\r\n\r\n    //Get color at given position\r\n    var posColor = this.stones.get(x, y);\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //If border reached, or a position which is already this color, or boundary color, can't set\r\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\r\n      return;\r\n    }\r\n\r\n    //Don't turn stones which are already this color into candidates, instead\r\n    //reset their color to what they were\r\n    if (origColor * 2 === candidateColor) {\r\n      this.stones.set(x, y, origColor);\r\n    }\r\n\r\n    //Otherwise, mark as candidate\r\n    else {\r\n      this.stones.set(x, y, candidateColor);\r\n    }\r\n\r\n    //Set adjacent squares\r\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\r\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\r\n  }\r\n\r\n  /**\r\n   * Helper to reset territory\r\n   */\r\n  function territoryReset(x, y) {\r\n\r\n    //Get original color from this position\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //Not on grid, or already this color?\r\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\r\n      return;\r\n    }\r\n\r\n    //Reset the color\r\n    this.stones.set(x, y, origColor);\r\n\r\n    //Set adjacent squares\r\n    territoryReset.call(this, x - 1, y);\r\n    territoryReset.call(this, x, y - 1);\r\n    territoryReset.call(this, x + 1, y);\r\n    territoryReset.call(this, x, y + 1);\r\n  }\r\n\r\n  /**\r\n   * Helper to determine score state\r\n   */\r\n  function determineScoreState() {\r\n\r\n    //Initialize vars\r\n    var change = true;\r\n    var curState, newState, adjacent, b, w, a, x, y;\r\n\r\n    //Loop while there is change\r\n    while (change) {\r\n\r\n      //Set to false\r\n      change = false;\r\n\r\n      //Go through the whole position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get current state at position\r\n          curState = this.stones.get(x, y);\r\n\r\n          //Unknown or candiates?\r\n          if (\r\n            curState === scoreState.UNKNOWN ||\r\n            curState === scoreState.BLACK_CANDIDATE ||\r\n            curState === scoreState.WHITE_CANDIDATE\r\n          ) {\r\n\r\n            //Get state in adjacent positions\r\n            adjacent = [\r\n              this.stones.get(x - 1, y),\r\n              this.stones.get(x, y - 1),\r\n              this.stones.get(x + 1, y),\r\n              this.stones.get(x, y + 1)\r\n            ];\r\n\r\n            //Reset\r\n            b = w = false;\r\n\r\n            //Loop adjacent squares\r\n            for (a = 0; a < 4; a++) {\r\n              if (\r\n                adjacent[a] === scoreState.BLACK_STONE ||\r\n                adjacent[a] === scoreState.BLACK_CANDIDATE\r\n              ) {\r\n                b = true;\r\n              }\r\n              else if (\r\n                adjacent[a] === scoreState.WHITE_STONE ||\r\n                adjacent[a] === scoreState.WHITE_CANDIDATE\r\n              ) {\r\n                w = true;\r\n              }\r\n              else if (adjacent[a] === scoreState.NEUTRAL) {\r\n                b = w = true;\r\n              }\r\n            }\r\n\r\n            //Determine new state\r\n            if (b && w) {\r\n              newState = scoreState.NEUTRAL;\r\n            }\r\n            else if (b) {\r\n              newState = scoreState.BLACK_CANDIDATE;\r\n            }\r\n            else if (w) {\r\n              newState = scoreState.WHITE_CANDIDATE;\r\n            }\r\n            else {\r\n              newState = false;\r\n            }\r\n\r\n            //Change?\r\n            if (newState !== false && newState !== curState) {\r\n              change = true;\r\n              this.stones.set(x, y, newState);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * this.game scorer class\r\n   */\r\n  var GameScorer = {\r\n\r\n    //Game to score\r\n    game: null,\r\n\r\n    //Score\r\n    score: null,\r\n\r\n    //Stones, captures and points grids\r\n    stones: null,\r\n    captures: null,\r\n    points: null,\r\n\r\n    /**\r\n     * Load a game to score\r\n     */\r\n    load: function(game) {\r\n\r\n      //Reset score\r\n      this.score = new GameScore();\r\n\r\n      //Remember\r\n      this.game = game;\r\n\r\n      //Clone position to work with\r\n      this.stones = this.game.position.stones.clone();\r\n\r\n      //Create grids\r\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n    },\r\n\r\n    /**\r\n     * Get the calculated score\r\n     */\r\n    getScore: function() {\r\n      return this.score;\r\n    },\r\n\r\n    /**\r\n     * Get the points grid\r\n     */\r\n    getPoints: function() {\r\n      return this.points;\r\n    },\r\n\r\n    /**\r\n     * Get the captures grid\r\n     */\r\n    getCaptures: function() {\r\n      return this.captures;\r\n    },\r\n\r\n    /**\r\n     * Run score calculation routine\r\n     */\r\n    calculate: function() {\r\n\r\n      //No game?\r\n      if (!this.game) {\r\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\r\n        return;\r\n      }\r\n\r\n      //Empty grids\r\n      this.points.empty();\r\n      this.captures.empty();\r\n\r\n      //Determine score state\r\n      determineScoreState.call(this);\r\n\r\n      //Get komi and captures\r\n      var komi = this.game.get('game.komi');\r\n      var captures = this.game.getCaptureCount();\r\n\r\n      //Reset score\r\n      this.score.reset();\r\n\r\n      //Set captures and komi\r\n      this.score.black.captures = captures[StoneColor.B];\r\n      this.score.white.captures = captures[StoneColor.W];\r\n      this.score.black.komi = komi < 0 ? komi : 0;\r\n      this.score.white.komi = komi > 0 ? komi : 0;\r\n\r\n      //Init helper vars\r\n      var x, y, state, color;\r\n\r\n      //Loop position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get state and color on original position\r\n          state = this.stones.get(x, y);\r\n          color = this.game.position.stones.get(x, y);\r\n\r\n          //Black stone\r\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\r\n            this.score.black.stones++;\r\n            continue;\r\n          }\r\n\r\n          //White stone\r\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\r\n            this.score.white.stones++;\r\n            continue;\r\n          }\r\n\r\n          //Black candidate\r\n          if (state === scoreState.BLACK_CANDIDATE) {\r\n            this.score.black.territory++;\r\n            this.points.set(x, y, StoneColor.B);\r\n\r\n            //White stone underneath?\r\n            if (color === StoneColor.W) {\r\n              this.score.black.captures++;\r\n              this.captures.set(x, y, StoneColor.W);\r\n            }\r\n            continue;\r\n          }\r\n\r\n          //White candidate\r\n          if (state === scoreState.WHITE_CANDIDATE) {\r\n            this.score.white.territory++;\r\n            this.points.set(x, y, StoneColor.W);\r\n\r\n            //Black stone underneath?\r\n            if (color === StoneColor.B) {\r\n              this.score.white.captures++;\r\n              this.captures.set(x, y, StoneColor.B);\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mark stones dead or alive\r\n     */\r\n    mark: function(x, y) {\r\n\r\n      //Get color of original position and state of the count position\r\n      var color = this.game.position.stones.get(x, y);\r\n      var state = this.stones.get(x, y);\r\n\r\n      //White stone\r\n      if (color === StoneColor.W) {\r\n\r\n        //Was white, mark it and any territory it's in as black's\r\n        if (state === scoreState.WHITE_STONE) {\r\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\r\n        }\r\n\r\n        //Was marked as not white, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n\r\n      //Black stone\r\n      else if (color === StoneColor.B) {\r\n\r\n        //Was black, mark it and any territory it's in as white's\r\n        if (state === scoreState.BLACK_STONE) {\r\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\r\n        }\r\n\r\n        //Was marked as not black, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return GameScorer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidDataError :: Error class to handle invalid data.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidDataError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidDataError(code) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidDataError';\r\n    this.message = 'Invalid data: ';\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.NO_DATA:\r\n        this.message += 'no data to process.';\r\n        break;\r\n      case ngGo.error.UNKNOWN_DATA:\r\n        this.message += 'unknown data format.';\r\n        break;\r\n      case ngGo.error.INVALID_GIB:\r\n        this.message += 'unable to parse GIB data.';\r\n        break;\r\n      case ngGo.error.INVALID_SGF:\r\n        this.message += 'unable to parse SGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_JSON:\r\n        this.message += 'unable to parse JGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_TREE_JSON:\r\n        this.message += 'unable to parse the JGF tree data.';\r\n        break;\r\n      default:\r\n        this.message += 'unable to parse the data.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidDataError.prototype = new Error();\r\n  InvalidDataError.prototype.constructor = InvalidDataError;\r\n\r\n  //Return object\r\n  return InvalidDataError;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidPositionError :: Error class to handle invalid moves.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidPositionError(code, x, y, color) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidPositionError';\r\n    this.message = 'Invalid position detected.';\r\n\r\n    //Add position data\r\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\r\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\r\n        ' stone on (' + x + ', ' + y + ')';\r\n    }\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\r\n        this.message += ', but these coordinates are not on the board.';\r\n        break;\r\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\r\n        this.message += ', but there is already a stone on those coordinates.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_SUICIDE:\r\n        this.message += ', but that would be suicide.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_REPEATING:\r\n        this.message += ', but this position already occured.';\r\n        break;\r\n      default:\r\n        this.message += '.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidPositionError.prototype = new Error();\r\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\r\n\r\n  //Return object\r\n  return InvalidPositionError;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Blank.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuBlank', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Blank JGF\r\n   */\r\n  var blankJgf = {\r\n    record: {\r\n      application: ngGo.name + ' v' + ngGo.version,\r\n      version: 1,\r\n      charset: 'UTF-8'\r\n    },\r\n    game: {\r\n      type: 'go',\r\n      players: [\r\n        {\r\n          color: 'black',\r\n          name: 'Black'\r\n        },\r\n        {\r\n          color: 'white',\r\n          name: 'White'\r\n        }\r\n      ]\r\n    },\r\n    board: {\r\n      width: 19,\r\n      height: 19\r\n    },\r\n    tree: []\r\n  };\r\n\r\n  /**\r\n   * Blank SGF\r\n   */\r\n  var blankSgf = {\r\n    AP: ngGo.name + ':' + ngGo.version,\r\n    CA: 'UTF-8',\r\n    FF: '4',\r\n    GM: '1',\r\n    SZ: '19',\r\n    PB: 'Black',\r\n    PW: 'White'\r\n  };\r\n\r\n  /**\r\n   * Blank JGF/SGF container\r\n   */\r\n  var KifuBlank = {\r\n\r\n    /**\r\n     * Get blank JGF\r\n     */\r\n    jgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankJgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    },\r\n\r\n    /**\r\n     * Get blank SGF\r\n     */\r\n    sgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankSgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = base[p];\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuBlank;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\r\n * constants used by the parsers to aid conversion.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parser.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\r\n])\r\n\r\n/**\r\n * SGF/JGF aliases constant for conversion between the two formats\r\n * Note: not all properties can be translated directly, so some are\r\n * not present here in this constant\r\n */\r\n.constant('sgfAliases', {\r\n\r\n  //Record properties\r\n  'AP': 'record.application',\r\n  'CA': 'record.charset',\r\n  'CP': 'record.copyright',\r\n  'SO': 'record.source',\r\n  'US': 'record.transcriber',\r\n  'AN': 'record.annotator',\r\n\r\n  //Game properties\r\n  'GM': 'game.type',\r\n  'GN': 'game.name',\r\n  'KM': 'game.komi',\r\n  'HA': 'game.handicap',\r\n  'RE': 'game.result',\r\n  'RU': 'game.rules',\r\n  'TM': 'game.time.main',\r\n  'OT': 'game.time.overtime',\r\n  'DT': 'game.dates',\r\n  'PC': 'game.location',\r\n  'EV': 'game.event',\r\n  'RO': 'game.round',\r\n  'ON': 'game.opening',\r\n  'GC': 'game.comment',\r\n\r\n  //Player info properties\r\n  'PB': 'name',\r\n  'PW': 'name',\r\n  'BT': 'team',\r\n  'WT': 'team',\r\n  'BR': 'rank',\r\n  'WR': 'rank',\r\n\r\n  //Node annotation\r\n  'N': 'name',\r\n  'C': 'comments',\r\n  'CR': 'circle',\r\n  'TR': 'triangle',\r\n  'SQ': 'square',\r\n  'MA': 'mark',\r\n  'SL': 'select',\r\n  'LB': 'label'\r\n})\r\n\r\n/**\r\n * SGF game definitions\r\n */\r\n.constant('sgfGames', {\r\n  1: 'go',\r\n  2: 'othello',\r\n  3: 'chess',\r\n  4: 'renju',\r\n  6: 'backgammon',\r\n  7: 'chinese chess',\r\n  8: 'shogi'\r\n})\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\r\n\r\n  /**\r\n   * Parser wrapper class\r\n   */\r\n  var KifuParser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    gib2jgf: function(gib, stringified) {\r\n      return Gib2Jgf.parse(gib, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    sgf2jgf: function(sgf, stringified) {\r\n      return Sgf2Jgf.parse(sgf, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    jgf2sgf: function(jgf) {\r\n      return Jgf2Sgf.parse(jgf);\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuParser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Directive', [\r\n  'ngGo.Board.Directive'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('player', ['Player', function(Player) {\r\n  return {\r\n    restrict: 'E',\r\n\r\n    /**\r\n     * Controller\r\n     */\r\n    controller: ['$scope', function($scope) {\r\n\r\n      //Set player in scope\r\n      if (!$scope.Player) {\r\n        $scope.Player = Player;\r\n      }\r\n    }],\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Link the element\r\n      Player.linkElement(element);\r\n\r\n      //Observe mode and tool attributes\r\n      attrs.$observe('mode', function(mode) {\r\n        Player.switchMode(mode);\r\n      });\r\n      attrs.$observe('tool', function(tool) {\r\n        Player.switchTool(tool);\r\n      });\r\n\r\n      //Observe other settings attributes\r\n      attrs.$observe('variationMarkup', function(attr) {\r\n        Player.setVariationMarkup(attr === 'true');\r\n      });\r\n      attrs.$observe('solutionPaths', function(attr) {\r\n        Player.toggleSolutionPaths(attr === 'true');\r\n      });\r\n      attrs.$observe('lastMoveMarker', function(attr) {\r\n        Player.setLastMoveMarker(attr);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Player :: This class brings the board to life and allows a user to interact with it. It\r\n * handles user input, controls objects going to the board, can load game records, and allows the\r\n * user to manipulate the board according to the current player mode.\r\n * Unless you want to display static positions, this is the class you'd use by default.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Service', [\r\n  'ngGo',\r\n  'ngGo.Player.Directive',\r\n  'ngGo.Player.Mode.Common.Service',\r\n  'ngGo.Board.Service',\r\n  'ngGo.Game.Service',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default mode/tool\r\n    mode: PlayerModes.REPLAY,\r\n    tool: PlayerTools.MOVE,\r\n\r\n    //Keys/scrollwheel navigation\r\n    arrowKeysNavigation: true,\r\n    scrollWheelNavigation: true,\r\n\r\n    //Last move marker, leave empty for none\r\n    lastMoveMarker: MarkupTypes.LAST,\r\n\r\n    //Indicate variations with markup on the board, and show\r\n    //successor node variations or current node variations\r\n    variationMarkup: true,\r\n    variationChildren: true,\r\n    variationSiblings: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\r\n\r\n    /**\r\n     * Helper to append board grid coordinatess to the broadcast event object\r\n     */\r\n    function processMouseEvent(broadcastEvent, mouseEvent) {\r\n\r\n      //Can only do this with a board and mouse event\r\n      if (!this.board || !mouseEvent) {\r\n        broadcastEvent.x = -1;\r\n        broadcastEvent.y = -1;\r\n        return;\r\n      }\r\n\r\n      //Init\r\n      var x = 0;\r\n      var y = 0;\r\n\r\n      //Set x\r\n      if (typeof mouseEvent.offsetX !== 'undefined') {\r\n        x = mouseEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.layerX;\r\n      }\r\n\r\n      //Set y\r\n      if (typeof mouseEvent.offsetY !== 'undefined') {\r\n        y = mouseEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.layerY;\r\n      }\r\n\r\n      //Apply pixel ratio factor\r\n      x *= (window.devicePixelRatio || 1);\r\n      y *= (window.devicePixelRatio || 1);\r\n\r\n      //Append coords\r\n      broadcastEvent.x = this.board.getGridX(x);\r\n      broadcastEvent.y = this.board.getGridY(y);\r\n\r\n      //Did we drag?\r\n      if (mouseEvent.drag) {\r\n        broadcastEvent.drag = mouseEvent.drag;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player class\r\n     */\r\n    var Player = {\r\n\r\n      //Player configuration\r\n      config: {},\r\n\r\n      //Board and game instances\r\n      board: null,\r\n      game: null,\r\n\r\n      //Available modes and tools\r\n      modes: {},\r\n      tools: [],\r\n\r\n      //Player mode and active tool\r\n      mode: '',\r\n      tool: '',\r\n\r\n      //Current path\r\n      path: null,\r\n\r\n      /**\r\n       * Initialization\r\n       */\r\n      init: function() {\r\n\r\n        //Unlink board instance, create new game\r\n        this.board = null;\r\n        this.game = new Game();\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Player mode and active tool\r\n        this.mode = '';\r\n        this.tool = '';\r\n\r\n        //Arrow keys / scroll wheel navigation\r\n        this.arrowKeysNavigation = false;\r\n        this.scrollWheelNavigation = false;\r\n\r\n        //Last move marker\r\n        this.lastMoveMarker = '';\r\n\r\n        //Variation markup\r\n        this.variationMarkup = false;\r\n        this.variationChildren = false;\r\n        this.variationSiblings = false;\r\n\r\n        //Restricted nodes\r\n        this.restrictNodeStart = null;\r\n        this.restrictNodeEnd = null;\r\n\r\n        //Parse config\r\n        this.parseConfig();\r\n      },\r\n\r\n      /**\r\n       * Link the player to a HTML element\r\n       */\r\n      linkElement: function(element) {\r\n\r\n        //Set element\r\n        this.element = element;\r\n\r\n        //Register document event\r\n        this.registerElementEvent('keydown', $document);\r\n\r\n        //Register element events\r\n        this.registerElementEvent('click');\r\n        this.registerElementEvent('mousedown');\r\n        this.registerElementEvent('mouseup');\r\n        this.registerElementEvent('mousemove');\r\n        this.registerElementEvent('mouseout');\r\n        this.registerElementEvent('mousewheel');\r\n        this.registerElementEvent('wheel');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Configuration\r\n       ***/\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.switchMode(this.config.mode);\r\n        this.switchTool(this.config.tool);\r\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\r\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\r\n        this.setLastMoveMarker(this.config.lastMoveMarker);\r\n        this.setVariationMarkup(\r\n          this.config.variationMarkup,\r\n          this.config.variationChildren,\r\n          this.config.variationSiblings\r\n        );\r\n\r\n        //Let the modes parse their config\r\n        for (var mode in this.modes) {\r\n          if (this.modes[mode].parseConfig) {\r\n            this.modes[mode].parseConfig.call(this, this.config);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set arrow keys navigation\r\n       */\r\n      setArrowKeysNavigation: function(arrowKeys) {\r\n        if (arrowKeys !== this.arrowKeysNavigation) {\r\n          this.arrowKeysNavigation = arrowKeys;\r\n          this.broadcast('settingChange', 'arrowKeysNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set scroll wheel navigation\r\n       */\r\n      setScrollWheelNavigation: function(scrollWheel) {\r\n        if (scrollWheel !== this.scrollWheelNavigation) {\r\n          this.scrollWheelNavigation = scrollWheel;\r\n          this.broadcast('settingChange', 'scrollWheelNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the last move marker\r\n       */\r\n      setLastMoveMarker: function(lastMoveMarker) {\r\n        if (lastMoveMarker !== this.lastMoveMarker) {\r\n          this.lastMoveMarker = lastMoveMarker;\r\n          this.broadcast('settingChange', 'lastMoveMarker');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set variation markup on the board\r\n       */\r\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\r\n\r\n        //One change event for these three settings\r\n        var change = false;\r\n\r\n        //Markup setting change?\r\n        if (variationMarkup !== this.variationMarkup) {\r\n          this.variationMarkup = variationMarkup;\r\n          change = true;\r\n        }\r\n\r\n        //Children setting change?\r\n        if (\r\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\r\n        ) {\r\n          this.variationChildren = variationChildren;\r\n          change = true;\r\n        }\r\n\r\n        //Siblings setting change?\r\n        if (\r\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\r\n        ) {\r\n          this.variationSiblings = variationSiblings;\r\n          change = true;\r\n        }\r\n\r\n        //Did anything change?\r\n        if (change) {\r\n          this.broadcast('settingChange', 'variationMarkup');\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Mode and tool handling\r\n       ***/\r\n\r\n      /**\r\n       * Register a player mode\r\n       */\r\n      registerMode: function(mode, PlayerMode) {\r\n\r\n        //Register the mode and let it parse the configuration\r\n        this.modes[mode] = PlayerMode;\r\n\r\n        //Parse config if we have a handler\r\n        if (this.modes[mode].parseConfig) {\r\n          this.modes[mode].parseConfig.call(this, this.config);\r\n        }\r\n\r\n        //Force switch the mode now, if it matches the initial mode\r\n        if (this.mode === mode) {\r\n          this.switchMode(this.mode, true);\r\n          this.switchTool(this.tool, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set available tools\r\n       */\r\n      setTools: function(tools) {\r\n        this.tools = tools || [PlayerTools.NONE];\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player mode\r\n       */\r\n      hasMode: function(mode) {\r\n        return this.modes[mode] ? true : false;\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player tool\r\n       */\r\n      hasTool: function(tool) {\r\n        return (this.tools.indexOf(tool) !== -1);\r\n      },\r\n\r\n      /**\r\n       * Switch player mode\r\n       */\r\n      switchMode: function(mode, force) {\r\n\r\n        //No change?\r\n        if (!force && (!mode || this.mode === mode)) {\r\n          return false;\r\n        }\r\n\r\n        //Broadcast mode exit\r\n        if (this.mode) {\r\n          this.broadcast('modeExit', this.mode);\r\n        }\r\n\r\n        //Set mode, reset tools and active tool\r\n        this.mode = mode;\r\n        this.tools = [];\r\n        this.tool = PlayerTools.NONE;\r\n\r\n        //Broadcast mode entry\r\n        this.broadcast('modeEnter', this.mode);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Switch player tool\r\n       */\r\n      switchTool: function(tool, force) {\r\n\r\n        //No change?\r\n        if (!force && (!tool || this.tool === tool)) {\r\n          return false;\r\n        }\r\n\r\n        //Validate tool switch (only when there is a mode)\r\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\r\n          return false;\r\n        }\r\n\r\n        //Change tool\r\n        this.tool = tool;\r\n        this.broadcast('toolSwitch', this.tool);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Save the full player state\r\n       */\r\n      saveState: function() {\r\n\r\n        //Save player state\r\n        this.playerState = {\r\n          mode: this.mode,\r\n          tool: this.tool,\r\n          restrictNodeStart: this.restrictNodeStart,\r\n          restrictNodeEnd: this.restrictNodeEnd\r\n        };\r\n\r\n        //Save game state\r\n        this.saveGameState();\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved player state\r\n       */\r\n      restoreState: function() {\r\n\r\n        //Must have player state\r\n        if (!this.playerState) {\r\n          return;\r\n        }\r\n\r\n        //Restore\r\n        this.switchMode(this.playerState.mode);\r\n        this.switchTool(this.playerState.tool);\r\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\r\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\r\n\r\n        //Restore game state\r\n        this.restoreGameState();\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game record handling\r\n       ***/\r\n\r\n      /**\r\n       * Load game record\r\n       */\r\n      load: function(data, allowPlayerConfig) {\r\n\r\n        //Try to load the game record data\r\n        try {\r\n          this.game.load(data);\r\n        }\r\n        catch (error) {\r\n          throw error;\r\n        }\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Parse configuration from JGF if allowed\r\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\r\n          this.parseConfig(this.game.get('settings'));\r\n        }\r\n\r\n        //Dispatch game loaded event\r\n        this.broadcast('gameLoaded', this.game);\r\n\r\n        //Board present?\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n\r\n        //Loaded ok\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Reload the existing game record\r\n       */\r\n      reload: function() {\r\n\r\n        //Must have game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reload game\r\n        this.game.reload();\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Save the current state\r\n       */\r\n      saveGameState: function() {\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.gameState = this.game.getState();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved state\r\n       */\r\n      restoreGameState: function() {\r\n\r\n        //Must have game and saved state\r\n        if (!this.game || !this.gameState) {\r\n          return;\r\n        }\r\n\r\n        //Restore state\r\n        this.game.restoreState(this.gameState);\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Navigation\r\n       ***/\r\n\r\n      /**\r\n       * Go to the next position\r\n       */\r\n      next: function(i) {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.next(i);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position\r\n       */\r\n      previous: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previous();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the last position\r\n       */\r\n      last: function() {\r\n        if (this.game) {\r\n          this.game.last();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the first position\r\n       */\r\n      first: function() {\r\n        if (this.game) {\r\n          this.game.first();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to a specific move number, tree path or named node\r\n       */\r\n      goto: function(target) {\r\n        if (this.game && target) {\r\n          this.game.goto(target);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the previous fork\r\n       */\r\n      previousFork: function() {\r\n        if (this.game) {\r\n          this.game.previousFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next fork\r\n       */\r\n      nextFork: function() {\r\n        if (this.game) {\r\n          this.game.nextFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next position with a comment\r\n       */\r\n      nextComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.nextComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position with a comment\r\n       */\r\n      previousComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previousComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restrict navigation to the current node\r\n       */\r\n      restrictNode: function(end) {\r\n\r\n        //Must have game and node\r\n        if (!this.game || !this.game.node) {\r\n          return;\r\n        }\r\n\r\n        //Restrict to current node\r\n        if (end) {\r\n          this.restrictNodeEnd = this.game.node;\r\n        }\r\n        else {\r\n          this.restrictNodeStart = this.game.node;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Process a new game position\r\n       */\r\n      processPosition: function() {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Get current node and game position\r\n        var node = this.game.getNode();\r\n        var path = this.game.getPath();\r\n        var position = this.game.getPosition();\r\n        var pathChanged = !path.compare(this.path);\r\n\r\n        //Update board\r\n        this.updateBoard(node, position, pathChanged);\r\n\r\n        //Path change?\r\n        if (pathChanged) {\r\n\r\n          //Copy new path and broadcast path change\r\n          this.path = path.clone();\r\n          this.broadcast('pathChange', node);\r\n\r\n          //Named node reached? Broadcast event\r\n          if (node.name) {\r\n            this.broadcast('reachedNode.' + node.name, node);\r\n          }\r\n        }\r\n\r\n        //Passed?\r\n        if (node.move && node.move.pass) {\r\n          this.broadcast('movePassed', node);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Show move numbers\r\n       */\r\n      showMoveNumbers: function(fromMove, toMove) {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Use sensible defaults if no from/to moves given\r\n        fromMove = fromMove || 1;\r\n        toMove = toMove || this.game.getMove();\r\n\r\n        //Get nodes for these moves\r\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\r\n        var move = fromMove;\r\n\r\n        //Loop nodes\r\n        angular.forEach(nodes, function(node) {\r\n          this.board.add('markup', node.move.x, node.move.y, {\r\n            type: MarkupTypes.LABEL,\r\n            text: move++\r\n          });\r\n        }, this);\r\n\r\n        //Redraw board markup\r\n        this.board.redraw('markup');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game handling\r\n       ***/\r\n\r\n      /**\r\n       * Start a new game\r\n       */\r\n      newGame: function() {\r\n        this.game = new Game();\r\n        this.processPosition();\r\n      },\r\n\r\n      /**\r\n       * Score the current game position\r\n       */\r\n      scoreGame: function() {\r\n\r\n        //Calculate score\r\n        GameScorer.calculate();\r\n\r\n        //Get score, points and captures\r\n        var score = GameScorer.getScore();\r\n        var points = GameScorer.getPoints();\r\n        var captures = GameScorer.getCaptures();\r\n\r\n        //Remove all markup, and set captures and points\r\n        this.board.layers.markup.removeAll();\r\n        this.board.layers.score.setAll(points, captures);\r\n\r\n        //Broadcast score\r\n        this.broadcast('scoreCalculated', score);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Board handling\r\n       ***/\r\n\r\n      /**\r\n       * Get the board\r\n       */\r\n      getBoard: function() {\r\n        return this.board;\r\n      },\r\n\r\n      /**\r\n       * Set the board\r\n       */\r\n      setBoard: function(Board) {\r\n\r\n        //Set the board\r\n        this.board = Board;\r\n\r\n        //Board ready\r\n        if (this.board) {\r\n          this.broadcast('boardReady', this.board);\r\n        }\r\n\r\n        //If a game has been loaded already, parse config and update the board\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Update the board\r\n       */\r\n      updateBoard: function(node, position, pathChanged) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Update board with new position\r\n        this.board.updatePosition(position, pathChanged);\r\n\r\n        //Mark last move\r\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\r\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\r\n        }\r\n\r\n        //Broadcast board update event\r\n        this.broadcast('boardUpdate', node);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Event handling\r\n       ***/\r\n\r\n      /**\r\n       * Register an element event\r\n       */\r\n      registerElementEvent: function(event, element) {\r\n\r\n        //Which element to use\r\n        if (typeof element === 'undefined' || !element.on) {\r\n          element = this.element;\r\n        }\r\n\r\n        //Remove any existing event listener and apply new one\r\n        //TODO: Namespacing events doesn't work with Angular's jqLite\r\n        element.off(event/* + '.ngGo.player'*/);\r\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\r\n      },\r\n\r\n      /**\r\n       * Event listener\r\n       */\r\n      on: function(type, listener, mode, $scope) {\r\n\r\n        //Must have valid listener\r\n        if (typeof listener !== 'function') {\r\n          console.warn('Listener is not a function:', listener);\r\n          return;\r\n        }\r\n\r\n        //Scope given as 3rd parameter?\r\n        if (mode && mode.$parent) {\r\n          $scope = mode;\r\n          mode = '';\r\n        }\r\n\r\n        //Multiple events?\r\n        if (type.indexOf(' ') !== -1) {\r\n          var types = type.split(' ');\r\n          for (var t = 0; t < types.length; t++) {\r\n            this.on(types[t], listener, mode, $scope);\r\n          }\r\n          return;\r\n        }\r\n\r\n        //Get self and determine scope to use\r\n        var self = this;\r\n        var scope = $scope || $rootScope;\r\n\r\n        //Create listener and return de-registration function\r\n        return scope.$on('ngGo.player.' + type, function() {\r\n\r\n          //Filter on mode\r\n          if (mode) {\r\n            if (\r\n              (typeof mode === 'string' && mode !== self.mode) ||\r\n              mode.indexOf(self.mode) === -1\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          //Inside a text field?\r\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\r\n            return;\r\n          }\r\n\r\n          //Append grid coordinates for mouse events\r\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\r\n            processMouseEvent.call(self, arguments[0], arguments[1]);\r\n          }\r\n\r\n          //Dragging? Prevent click events from firing\r\n          if (self.preventClickEvent && type === 'click') {\r\n            delete self.preventClickEvent;\r\n            return;\r\n          }\r\n          else if (type === 'mousedrag') {\r\n            self.preventClickEvent = true;\r\n          }\r\n\r\n          //Call listener\r\n          listener.apply(self, arguments);\r\n        });\r\n      },\r\n\r\n      /**\r\n       * Event broadcaster\r\n       */\r\n      broadcast: function(type, args) {\r\n\r\n        //Must have type\r\n        if (!type) {\r\n          return;\r\n        }\r\n\r\n        //Make sure we are in a digest cycle\r\n        if (!$rootScope.$$phase) {\r\n          $rootScope.$apply(function() {\r\n            $rootScope.$broadcast('ngGo.player.' + type, args);\r\n          });\r\n        }\r\n        else {\r\n          $rootScope.$broadcast('ngGo.player.' + type, args);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Initialize\r\n    Player.init();\r\n\r\n    //Return object\r\n    return Player;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\r\n * gridlines, starpoints and coordinates via the Coordinates class.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Coordinates.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\r\n\r\n  /**\r\n   * Helper for drawing starpoints\r\n   */\r\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\r\n\r\n    //Don't draw if it falls outsize of the board grid\r\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\r\n      return;\r\n    }\r\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\r\n      return;\r\n    }\r\n\r\n    //Get absolute coordinates and star point radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n\r\n    //Draw star point\r\n    this.context.beginPath();\r\n    this.context.fillStyle = starColor;\r\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GridLayer(board, context) {\r\n\r\n    //Set coordinates setting\r\n    this.coordinates = false;\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Show or hide the coordinates.\r\n   */\r\n  GridLayer.prototype.setCoordinates = function(show) {\r\n    this.coordinates = show;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Get all has nothing to return\r\n   */\r\n  GridLayer.prototype.getAll = function() {\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Set all has nothing to set\r\n   */\r\n  GridLayer.prototype.setAll = function(/*grid*/) {\r\n    return;\r\n  };\r\n\r\n  /**\r\n   * Remove all has nothing to remove\r\n   */\r\n  GridLayer.prototype.removeAll = function() {\r\n    return;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw method\r\n   */\r\n  GridLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Determine top x and y margin\r\n    var tx = this.board.drawMarginHor;\r\n    var ty = this.board.drawMarginVer;\r\n\r\n    //Get theme properties\r\n    var cellSize = this.board.getCellSize();\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\r\n    var lineCap = this.board.theme.get('grid.lineCap');\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Helper vars\r\n    var i, x, y;\r\n\r\n    //Draw vertical lines\r\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\r\n      x = this.board.getAbsX(i);\r\n      this.context.moveTo(x, ty);\r\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\r\n    }\r\n\r\n    //Draw horizontal lines\r\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\r\n      y = this.board.getAbsY(i);\r\n      this.context.moveTo(tx, y);\r\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\r\n    }\r\n\r\n    //Draw grid lines\r\n    this.context.stroke();\r\n\r\n    //Star points defined?\r\n    for (i = 0; i < starPoints.length; i++) {\r\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n\r\n    //Draw coordinates\r\n    if (this.coordinates) {\r\n      Coordinates.draw.call(this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Clear rectangle\r\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  /**\r\n   * Redraw a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', s);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n\r\n    //Determine draw coordinates\r\n    var x1 = (gridX === 0) ? x : x - r;\r\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\r\n    var y1 = (gridY === 0) ? y : y - r;\r\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Patch up grid lines\r\n    this.context.moveTo(x1, y);\r\n    this.context.lineTo(x2, y);\r\n    this.context.moveTo(x, y1);\r\n    this.context.lineTo(x, y2);\r\n    this.context.stroke();\r\n\r\n    //Check if we need to draw a star point here\r\n    for (var i in starPoints) {\r\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\r\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\r\n      }\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  //Return\r\n  return GridLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function HoverLayer(board, context) {\r\n\r\n    //Container for items to restore\r\n    this.restore = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add hover item\r\n   */\r\n  HoverLayer.prototype.add = function(x, y, hover) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Remove any previous item at this position\r\n    this.remove(x, y);\r\n\r\n    //Create hover object\r\n    hover.object = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Stones\r\n    if (hover.type === 'stones') {\r\n      hover.objectClass = StoneFaded;\r\n      hover.object.color = hover.value;\r\n    }\r\n\r\n    //Markup\r\n    else if (hover.type === 'markup') {\r\n      hover.objectClass = Markup;\r\n      if (typeof hover.value === 'object') {\r\n        hover.object = angular.extend(hover.object, hover.value);\r\n      }\r\n      else {\r\n        hover.object.type = hover.value;\r\n      }\r\n    }\r\n\r\n    //Unknown\r\n    else {\r\n      console.warn('Unknown hover type', hover.type);\r\n      return;\r\n    }\r\n\r\n    //Check if we need to hide something on layers underneath\r\n    if (this.board.has(hover.type, x, y)) {\r\n      this.restore.push({\r\n        x: x,\r\n        y: y,\r\n        layer: hover.type,\r\n        value: this.board.get(hover.type, x, y)\r\n      });\r\n      this.board.remove(hover.type, x, y);\r\n    }\r\n\r\n    //Add to stack\r\n    this.grid.set(x, y, hover);\r\n\r\n    //Draw item\r\n    if (hover.objectClass && hover.objectClass.draw) {\r\n      hover.objectClass.draw.call(this, hover.object);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove the hover object\r\n   */\r\n  HoverLayer.prototype.remove = function(x, y) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.has(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get object and clear it\r\n    var hover = this.grid.get(x, y);\r\n    if (hover.objectClass && hover.objectClass.clear) {\r\n      hover.objectClass.clear.call(this, hover.object);\r\n    }\r\n\r\n    //Other objects to restore?\r\n    for (var i = 0; i < this.restore.length; i++) {\r\n      if (this.restore[i].x === x && this.restore[i].y === y) {\r\n        this.board.add(\r\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n        );\r\n        this.restore.splice(i, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove all hover objects\r\n   */\r\n  HoverLayer.prototype.removeAll = function() {\r\n\r\n    //Anything to do?\r\n    if (this.grid.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    //Get all item as objects\r\n    var i;\r\n    var hover = this.grid.all('layer');\r\n\r\n    //Clear them\r\n    for (i = 0; i < hover.length; i++) {\r\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\r\n        hover[i].objectClass.clear.call(this, hover[i].object);\r\n      }\r\n    }\r\n\r\n    //Clear layer and empty grid\r\n    this.clear();\r\n    this.grid.empty();\r\n\r\n    //Restore objects on other layers\r\n    for (i = 0; i < this.restore.length; i++) {\r\n      this.board.add(\r\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n      );\r\n    }\r\n\r\n    //Clear restore array\r\n    this.restore = [];\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  HoverLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Loop objects and clear them\r\n    var hover = this.grid.all('hover');\r\n    for (var i = 0; i < hover.length; i++) {\r\n      if (hover.objectClass && hover.objectClass.draw) {\r\n        hover.objectClass.draw.call(this, hover.object);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return HoverLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function MarkupLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all markup at once\r\n   */\r\n  MarkupLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'type');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Markup.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Markup.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  MarkupLayer.prototype.removeAll = function() {\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Clear them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.clear.call(this, markup[i]);\r\n    }\r\n\r\n    //Empty the grid now\r\n    this.grid.empty();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  MarkupLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.draw.call(this, markup[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  MarkupLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  MarkupLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return MarkupLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ScoreLayer(board, context) {\r\n\r\n    //Points and captures\r\n    this.points = [];\r\n    this.captures = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set points and captures\r\n   */\r\n  ScoreLayer.prototype.setAll = function(points, captures) {\r\n\r\n    //Remove all existing stuff first\r\n    this.removeAll();\r\n\r\n    //Set new stuff\r\n    this.points = points.all('color');\r\n    this.captures = captures.all('color');\r\n\r\n    //Draw\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Remove all scoring\r\n   */\r\n  ScoreLayer.prototype.removeAll = function() {\r\n\r\n    //If there are captures, draw them back onto the stones layer\r\n    for (var i = 0; i < this.captures.length; i++) {\r\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\r\n    }\r\n\r\n    //Clear the layer\r\n    this.clear();\r\n\r\n    //Remove all stuff\r\n    this.points = [];\r\n    this.captures = [];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ScoreLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Init\r\n    var i;\r\n\r\n    //Draw captures first (removing stones from the stones layer)\r\n    for (i = 0; i < this.captures.length; i++) {\r\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\r\n      StoneFaded.draw.call(this, this.captures[i]);\r\n    }\r\n\r\n    //Draw points on top of it\r\n    for (i = 0; i < this.points.length; i++) {\r\n      StoneMini.draw.call(this, this.points[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ScoreLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneShadow.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ShadowLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add a stone\r\n   */\r\n  ShadowLayer.prototype.add = function(stone) {\r\n\r\n    //Don't add if no shadow\r\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\r\n      return;\r\n    }\r\n\r\n    //Already have a stone here?\r\n    if (this.grid.has(stone.x, stone.y)) {\r\n      return;\r\n    }\r\n\r\n    //Add to grid\r\n    this.grid.set(stone.x, stone.y, stone.color);\r\n\r\n    //Draw it if there is a context\r\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\r\n      StoneShadow.draw.call(this, stone);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove a stone\r\n   */\r\n  ShadowLayer.prototype.remove = function(stone) {\r\n\r\n    //Remove from grid\r\n    this.grid.unset(stone.x, stone.y);\r\n\r\n    //Redraw whole layer\r\n    this.redraw();\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ShadowLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get shadowsize from theme\r\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\r\n\r\n    //Apply shadow transformation\r\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      StoneShadow.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ShadowLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function StonesLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n\r\n    //Set empty value for grid\r\n    this.grid.whenEmpty(StoneColor.EMPTY);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all stones at once\r\n   */\r\n  StonesLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'color');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Stone.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Stone.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  StonesLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      Stone.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  StonesLayer.prototype.redraw = function() {\r\n\r\n    //Clear shadows layer\r\n    this.board.removeAll('shadow');\r\n\r\n    //Redraw ourselves\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  StonesLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  StonesLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StonesLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Coordinates :: This class is used for drawing board coordinates\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Coordinates.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Coordinates', function() {\r\n\r\n  //Kanji\r\n  var kanji = [\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', ''\r\n  ];\r\n\r\n  //Character codes\r\n  var aChar = 'A'.charCodeAt(0);\r\n  var aCharLc = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Coordinate generators\r\n   */\r\n  var coordinates = {\r\n\r\n    //Kanji coordinates\r\n    kanji: function(i) {\r\n      return kanji[i] || '';\r\n    },\r\n\r\n    //Numbers from 1\r\n    numbers: function(i) {\r\n      return i + 1;\r\n    },\r\n\r\n    //Capital letters from A\r\n    letters: function(i) {\r\n\r\n      //Initialize\r\n      var ch = '';\r\n\r\n      //Beyond Z? Prepend with A\r\n      if (i >= 25) {\r\n        ch = 'A';\r\n        i -= 25;\r\n      }\r\n\r\n      //The letter I is ommitted\r\n      if (i >= 8) {\r\n        i++;\r\n      }\r\n\r\n      //Return\r\n      return ch + String.fromCharCode(aChar + i);\r\n    },\r\n\r\n    //JGF coordinates (e.g. 0, 1, ...)\r\n    jgf: function(i) {\r\n      return i;\r\n    },\r\n\r\n    //SGF coordinates (e.g. a, b, ...)\r\n    sgf: function(i) {\r\n      var ch;\r\n      if (i < 26) {\r\n        ch = aCharLc + i;\r\n      }\r\n      else {\r\n        ch = aChar + i;\r\n      }\r\n      return String.fromCharCode(ch);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Coordinates object\r\n   */\r\n  var Coordinates = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function() {\r\n\r\n      //Can only draw when we have context and dimensions\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Get cell size\r\n      var cellSize = this.board.getCellSize();\r\n\r\n      //Get boundary coordinates\r\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\r\n      var xr = this.board.drawWidth - xl;\r\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\r\n      var yb = this.board.drawHeight - yt;\r\n\r\n      //Get theme properties\r\n      var fillStyle = this.board.theme.get('coordinates.color');\r\n      var vertical = {\r\n        font: this.board.theme.get('coordinates.vertical.font'),\r\n        size: this.board.theme.get('coordinates.vertical.size'),\r\n        style: this.board.theme.get('coordinates.vertical.style'),\r\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\r\n      };\r\n      var horizontal = {\r\n        font: this.board.theme.get('coordinates.horizontal.font'),\r\n        size: this.board.theme.get('coordinates.horizontal.size'),\r\n        style: this.board.theme.get('coordinates.horizontal.style'),\r\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\r\n      };\r\n\r\n      //Configure context\r\n      this.context.fillStyle = fillStyle;\r\n      this.context.textBaseline = 'middle';\r\n      this.context.textAlign = 'center';\r\n\r\n      //Helper vars\r\n      var i, j, x, y, ch;\r\n\r\n      //Draw vertical coordinates\r\n      for (i = 0; i < this.board.height; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (vertical.inverse) {\r\n          j = this.board.height - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof vertical.style === 'function') {\r\n          ch = vertical.style.call(this, j);\r\n        }\r\n        else if (coordinates[vertical.style]) {\r\n          ch = coordinates[vertical.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        y = this.board.getAbsY(i);\r\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\r\n        this.context.fillText(ch, xl, y);\r\n        this.context.fillText(ch, xr, y);\r\n      }\r\n\r\n      //Draw horizontal coordinates\r\n      for (i = 0; i < this.board.width; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (horizontal.inverse) {\r\n          j = this.board.width - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof horizontal.style === 'function') {\r\n          ch = horizontal.style.call(this, j);\r\n        }\r\n        else if (coordinates[horizontal.style]) {\r\n          ch = coordinates[horizontal.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        x = this.board.getAbsX(i);\r\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\r\n        this.context.fillText(ch, x, yt);\r\n        this.context.fillText(ch, x, yb);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Coordinates;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Markup :: This class is used for drawing markup\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Markup.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\r\n\r\n  /**\r\n   * Math constants\r\n   */\r\n  var cosPi4 = Math.cos(Math.PI / 4);\r\n  var cosPi6 = Math.cos(Math.PI / 6);\r\n\r\n  /**\r\n   * Triangle draw handler\r\n   */\r\n  function drawTriangle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y - r);\r\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.closePath();\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Square draw handler\r\n   */\r\n  function drawSquare(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw circle handler\r\n   */\r\n  function drawCircle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw mark handler\r\n   */\r\n  function drawMark(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - rcos, y - rcos);\r\n    this.context.lineTo(x + rcos, y + rcos);\r\n    this.context.moveTo(x + rcos, y - rcos);\r\n    this.context.lineTo(x - rcos, y + rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw select handler\r\n   */\r\n  function drawSelect(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Last move draw handler\r\n   */\r\n  function drawLast(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y);\r\n    this.context.lineTo(x + r, y);\r\n    this.context.lineTo(x, y + r);\r\n    this.context.closePath();\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw happy smiley handler\r\n   */\r\n  function drawHappySmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 8);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw sad smiley handler\r\n   */\r\n  function drawSadSmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw label\r\n   */\r\n  function drawLabel(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //First, clear grid square below for clarity\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.clearCell(markup.x, markup.y);\r\n    }\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.textBaseline = 'middle';\r\n    this.context.textAlign = 'center';\r\n\r\n    //Convert to text\r\n    if (typeof markup.text === 'number') {\r\n      markup.text = markup.text.toString();\r\n    }\r\n\r\n    //Determine font size\r\n    if (markup.text.length === 1) {\r\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\r\n    }\r\n    else if (markup.text.length === 2) {\r\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\r\n    }\r\n    else {\r\n      this.context.font = r + 'px ' + font;\r\n    }\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.fillText(markup.text, x, y, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Clear label\r\n   */\r\n  function clearLabel(markup) {\r\n\r\n    //No stone on location? Redraw the grid square, if we cleared it\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup class\r\n   */\r\n  var Markup = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Drawing depends on type\r\n      switch (markup.type) {\r\n\r\n        //Triangle\r\n        case MarkupTypes.TRIANGLE:\r\n          drawTriangle.call(this, markup);\r\n          break;\r\n\r\n        //Square\r\n        case MarkupTypes.SQUARE:\r\n          drawSquare.call(this, markup);\r\n          break;\r\n\r\n        //Circle\r\n        case MarkupTypes.CIRCLE:\r\n          drawCircle.call(this, markup);\r\n          break;\r\n\r\n        //Mark\r\n        case MarkupTypes.MARK:\r\n          drawMark.call(this, markup);\r\n          break;\r\n\r\n        //Select\r\n        case MarkupTypes.SELECT:\r\n          drawSelect.call(this, markup);\r\n          break;\r\n\r\n        //happy\r\n        case MarkupTypes.HAPPY:\r\n          drawHappySmiley.call(this, markup);\r\n          break;\r\n\r\n        //Sad\r\n        case MarkupTypes.SAD:\r\n          drawSadSmiley.call(this, markup);\r\n          break;\r\n\r\n        //Last move marker\r\n        case MarkupTypes.LAST:\r\n          drawLast.call(this, markup);\r\n          break;\r\n\r\n        //Label\r\n        case MarkupTypes.LABEL:\r\n          markup.text = markup.text || '';\r\n          drawLabel.call(this, markup);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear\r\n     */\r\n    clear: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, markup);\r\n\r\n      //Special handling for label\r\n      if (markup.type === MarkupTypes.LABEL) {\r\n        clearLabel.call(this, markup);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Markup;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Stone :: This class is used for drawing stones on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Stone.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service',\r\n  'ngGo.Board.ShellPattern.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\r\n\r\n  /**\r\n   * Shell random seed\r\n   */\r\n  var shellSeed;\r\n\r\n  /**\r\n   * Mono colored stones\r\n   */\r\n  function drawMono(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Don't draw shadow\r\n    stone.shadow = false;\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\r\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Configure context\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Draw outline\r\n    this.context.stroke();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Glass stones\r\n   */\r\n  function drawGlass(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Begin path\r\n    this.context.beginPath();\r\n\r\n    //Determine stone texture\r\n    if (color === StoneColor.W) {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#fff');\r\n      this.context.fillStyle.addColorStop(1, '#aaa');\r\n    }\r\n    else {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#666');\r\n      this.context.fillStyle.addColorStop(1, '#111');\r\n    }\r\n\r\n    //Complete drawing\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Slate and shell stones\r\n   */\r\n  function drawSlateShell(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Get random seed\r\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var shellTypes = this.board.theme.get('stone.shell.types');\r\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.fill();\r\n\r\n    //Shell stones\r\n    if (color === StoneColor.W) {\r\n\r\n      //Get random shell type\r\n      var type =\r\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\r\n\r\n      //Determine random angle\r\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\r\n      var angle = (2 / z) * (shellSeed % z);\r\n\r\n      //Draw shell pattern\r\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Slate stones\r\n    else {\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var Stone = {\r\n\r\n    /**\r\n     * Draw a stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Determine style of stone\r\n      var style = this.board.theme.get('stone.style');\r\n\r\n      //Draw using the appropriate handler\r\n      switch (style) {\r\n\r\n        //Slate and shell\r\n        case 'shell':\r\n          drawSlateShell.call(this, stone);\r\n          break;\r\n\r\n        //Glass stones\r\n        case 'glass':\r\n          drawGlass.call(this, stone);\r\n          break;\r\n\r\n        //Mono stones\r\n        case 'mono':\r\n          drawMono.call(this, stone);\r\n          break;\r\n\r\n        //Custom type\r\n        default:\r\n          var handler = $injector.get(style);\r\n          if (handler) {\r\n            handler.call(this, stone);\r\n          }\r\n      }\r\n\r\n      //Add shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.add(stone);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear a stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, stone);\r\n\r\n      //Remove shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.remove(stone);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Stone;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneFaded', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneFaded = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.faded.scale');\r\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneFaded;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\r\n * (for scoring).\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneMini.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneMini', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneMini = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.mini.scale');\r\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneMini;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneShadow :: This class is used for drawing stone shadows on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneShadow', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var StoneShadow = {\r\n\r\n    /**\r\n     * Draw a stone shadow\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\r\n\r\n      //Apply scaling factor?\r\n      if (stone.scale) {\r\n        r = Math.round(r * stone.scale);\r\n      }\r\n\r\n      //Get theme properties\r\n      var blur = this.board.theme.get('shadow.blur', s);\r\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\r\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\r\n      var shadowColor = this.board.theme.get('shadow.color');\r\n\r\n      //Configure context\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\r\n      );\r\n      this.context.fillStyle.addColorStop(0, shadowColor);\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n\r\n      //Draw shadow\r\n      this.context.beginPath();\r\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    },\r\n\r\n    /**\r\n     * Clear a stone shadow\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Note: this method is currently not in use due to the overlapping shadows\r\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\r\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\r\n      //appropriate either, so for now we will leave it at this.\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = this.board.theme.get('stone.radius', s);\r\n\r\n      //Clear a generous rectangle\r\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneShadow;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeCommon :: This class governs common event handling of the player shared by\r\n * various player modes. It's basically an abstract player mode and it can't be actively set.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Common.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Run block\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\r\n\r\n  /**\r\n   * Register common event handlers\r\n   */\r\n  Player.on('keydown', PlayerModeCommon.keyDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n}])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\r\n\r\n  /**\r\n   * Helper to build drag object\r\n   */\r\n  function dragObject(event) {\r\n\r\n    //Initialize drag object\r\n    var drag = {\r\n      start: {\r\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\r\n      },\r\n      stop: {\r\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\r\n      }\r\n    };\r\n\r\n    //Fix boundaries\r\n    if (drag.start.x < 0) {\r\n      drag.start.x = 0;\r\n    }\r\n    if (drag.start.y < 0) {\r\n      drag.start.y = 0;\r\n    }\r\n    if (drag.stop.x > this.board.width - 1) {\r\n      drag.stop.x = this.board.width - 1;\r\n    }\r\n    if (drag.stop.y > this.board.height - 1) {\r\n      drag.stop.y = this.board.height - 1;\r\n    }\r\n\r\n    //Return\r\n    return drag;\r\n  }\r\n\r\n  /**\r\n   * Normalize the mousewheel event helper\r\n   */\r\n  function normalizeMousewheelEvent(event) {\r\n\r\n    //Initialize vars\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n\r\n    //Old school scrollwheel delta\r\n    if ('detail' in event) {\r\n      deltaY = event.detail * -1;\r\n    }\r\n    if ('wheelDelta' in event) {\r\n      deltaY = event.wheelDelta;\r\n    }\r\n    if ('wheelDeltaY' in event) {\r\n      deltaY = event.wheelDeltaY;\r\n    }\r\n    if ('wheelDeltaX' in event) {\r\n      deltaX = event.wheelDeltaX * -1;\r\n    }\r\n\r\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\r\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n      deltaX = deltaY * -1;\r\n      deltaY = 0;\r\n    }\r\n\r\n    //New type wheel delta (WheelEvent)\r\n    if ('deltaY' in event) {\r\n      deltaY = event.deltaY * -1;\r\n    }\r\n    if ('deltaX' in event) {\r\n      deltaX = event.deltaX;\r\n    }\r\n\r\n    //Set in event (have to use different property name because of strict mode)\r\n    event.mouseWheelX = deltaX;\r\n    event.mouseWheelY = deltaY;\r\n\r\n    //Return\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Player extension\r\n   */\r\n  angular.extend(Player, {\r\n\r\n    /**\r\n     * Mouse coordinate helper vars\r\n     */\r\n    mouse: {\r\n\r\n      //Drag start\r\n      dragStart: null,\r\n\r\n      //Last grid coordinates\r\n      lastX: -1,\r\n      lastY: -1\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Player mode definition\r\n   */\r\n  var PlayerMode = {\r\n\r\n    /**\r\n     * Handler for keydown events\r\n     */\r\n    keyDown: function(event, keyboardEvent) {\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Switch key code\r\n      switch (keyboardEvent.keyCode) {\r\n\r\n        //ESC\r\n        case KeyCodes.ESC:\r\n\r\n          //Cancel drag event, and prevent click event as well\r\n          this.mouse.dragStart = null;\r\n          this.preventClickEvent = true;\r\n          break;\r\n\r\n        //Right arrow\r\n        case KeyCodes.RIGHT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Advance to the next move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\r\n              this.next();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Left arrow\r\n        case KeyCodes.LEFT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Go to the previous move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\r\n              this.previous();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Up arrow\r\n        case KeyCodes.UP:\r\n          break;\r\n\r\n        //Down arrow\r\n        case KeyCodes.DOWN:\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handler for mousewheel events\r\n     */\r\n    mouseWheel: function(event, mouseEvent) {\r\n\r\n      //Disabled or not using move tool?\r\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\r\n        return true;\r\n      }\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return true;\r\n      }\r\n\r\n      //Normalize mousewheel event\r\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\r\n\r\n      //Find delta\r\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\r\n\r\n      //Next move\r\n      if (delta < 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.next();\r\n      }\r\n\r\n      //Previous move\r\n      else if (delta > 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.previous();\r\n      }\r\n\r\n      //Don't scroll the window\r\n      if (delta !== 0) {\r\n        mouseEvent.preventDefault();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse out handler\r\n     */\r\n    mouseOut: function() {\r\n      if (this.board) {\r\n        this.board.removeAll('hover');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse move handler\r\n     */\r\n    mouseMove: function(event, mouseEvent) {\r\n\r\n      //Attach drag object to events\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n      }\r\n\r\n      //Nothing else to do?\r\n      if (!this.board || !this.board.layers.hover) {\r\n        return;\r\n      }\r\n\r\n      //Last coordinates are the same?\r\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\r\n        return;\r\n      }\r\n\r\n      //Remember last coordinates\r\n      this.mouse.lastX = event.x;\r\n      this.mouse.lastY = event.y;\r\n\r\n      //Broadcast hover event\r\n      this.broadcast('hover', mouseEvent);\r\n    },\r\n\r\n    /**\r\n     * Mouse down handler\r\n     */\r\n    mouseDown: function(event) {\r\n      this.mouse.dragStart = {\r\n        x: event.x,\r\n        y: event.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Mouse up handler\r\n     */\r\n    mouseUp: function(event, mouseEvent) {\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n        this.broadcast('mousedrag', mouseEvent);\r\n      }\r\n      this.mouse.dragStart = null;\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return PlayerMode;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\r\n * a game record and its board positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Edit.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Setup tools\r\n */\r\n.constant('SetupTools', {\r\n  BLACK: 'black',\r\n  WHITE: 'white',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Markup tools\r\n */\r\n.constant('MarkupTools', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy',\r\n  TEXT: 'text',\r\n  NUMBER: 'number',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\r\n\r\n  //Register event handlers\r\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\r\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\r\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\r\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\r\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\r\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\r\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeEdit', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\r\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\r\n  ) {\r\n\r\n    //Character codes\r\n    var aChar = 'A'.charCodeAt(0);\r\n    var aCharLc = 'a'.charCodeAt(0);\r\n\r\n    /**\r\n     * Update hover mark at specific coordinates\r\n     */\r\n    function updateHoverMark(x, y, isDrag) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Setup tool\r\n        case PlayerTools.SETUP:\r\n\r\n          //Clear tool\r\n          if (this.setupTool === SetupTools.CLEAR) {\r\n\r\n            //Stone present? Can remove it\r\n            if (this.game.hasStone(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Stone color tool\r\n          else {\r\n\r\n            //Add or overwrite stone if no stone present of the given color\r\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'stones',\r\n                value: this.setupToolColor()\r\n              });\r\n            }\r\n\r\n            //Stone present of same color? Can remove it if we're not dragging\r\n            else if (!isDrag) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Markup tool\r\n        case PlayerTools.MARKUP:\r\n\r\n          //Clear tool, or already markup in place?\r\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\r\n            if (this.game.hasMarkup(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Text or number\r\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: {\r\n                type: MarkupTypes.LABEL,\r\n                text: this.markupLabel\r\n              }\r\n            });\r\n          }\r\n\r\n          //Other markup\r\n          else {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: this.markupTool\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set markup\r\n     */\r\n    function setMarkup(x, y) {\r\n\r\n      //Already markup in place? Remove it first\r\n      if (this.game.hasMarkup(x, y)) {\r\n\r\n        //Check what markup there is\r\n        var markup = this.game.getMarkup(x, y);\r\n\r\n        //Label? Also remove from our labels list\r\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\r\n          var i = this.markupLabels.indexOf(markup.text);\r\n          if (i !== -1) {\r\n            this.markupLabels.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        //Remove from game\r\n        this.game.removeMarkup(x, y);\r\n        return;\r\n      }\r\n\r\n      //Clear tool used? Done\r\n      if (this.markupTool === MarkupTools.CLEAR) {\r\n        return;\r\n      }\r\n\r\n      //Text\r\n      else if (this.markupTool === MarkupTools.TEXT) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next text label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Number\r\n      else if (this.markupTool === MarkupTools.NUMBER) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next number label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Other markup\r\n      else {\r\n        this.game.addMarkup(x, y, this.markupTool);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set a stone\r\n     */\r\n    function setStone(x, y, isDrag) {\r\n\r\n      //Get the stone color\r\n      var color = this.setupToolColor();\r\n\r\n      //Trying to remove a stone\r\n      if (color === StoneColor.EMPTY) {\r\n        this.game.removeStone(x, y);\r\n      }\r\n\r\n      //Adding a stone\r\n      else {\r\n\r\n        //A stone there already of the same color? Just remove if not dragging\r\n        if (!isDrag && this.game.hasStone(x, y, color)) {\r\n          this.game.removeStone(x, y);\r\n          return;\r\n        }\r\n\r\n        //Any stone present?\r\n        else if (this.game.hasStone(x, y)) {\r\n          this.game.removeStone(x, y);\r\n        }\r\n\r\n        //Add stone now\r\n        this.game.addStone(x, y, color);\r\n      }\r\n\r\n      //Redraw markup\r\n      this.board.layers.markup.redrawCell(x, y);\r\n    }\r\n\r\n    /**\r\n     * Find all markup labels in current position\r\n     */\r\n    function findAllMarkupLabels() {\r\n\r\n      //Clear\r\n      this.markupLabels = [];\r\n\r\n      //Must have game\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get all markup from position\r\n      var markup = this.game.position.markup.all('type');\r\n      for (var i = 0; i < markup.length; i++) {\r\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\r\n          this.markupLabels.push(markup[i].text);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Active setup tool and markup tool\r\n      setupTool: SetupTools.BLACK,\r\n      markupTool: MarkupTools.TRIANGLE,\r\n\r\n      //Current markup labels on the board and current markup label\r\n      markupLabels: [],\r\n      markupLabel: '',\r\n\r\n      /**\r\n       * Set the setup tool\r\n       */\r\n      switchSetupTool: function(tool) {\r\n        this.setupTool = tool;\r\n      },\r\n\r\n      /**\r\n       * Set the markup tool\r\n       */\r\n      switchMarkupTool: function(tool) {\r\n        this.markupTool = tool;\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          this.determineMarkupLabel();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Conversion of setup tool to stone color\r\n       */\r\n      setupToolColor: function() {\r\n        switch (this.setupTool) {\r\n          case SetupTools.BLACK:\r\n            return StoneColor.B;\r\n          case SetupTools.WHITE:\r\n            return StoneColor.W;\r\n          default:\r\n            return StoneColor.EMPTY;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the new text markup label\r\n       */\r\n      setMarkupLabel: function(label) {\r\n        if (label) {\r\n          this.markupLabel = label;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Determine the new text markup label\r\n       */\r\n      determineMarkupLabel: function() {\r\n\r\n        //Clear\r\n        this.markupLabel = '';\r\n\r\n        //Check what tool we're using\r\n        switch (this.markupTool) {\r\n\r\n          //Text tool?\r\n          case MarkupTools.TEXT:\r\n            var i = 0;\r\n\r\n            //Loop while the label is present\r\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n\r\n              //A-Z\r\n              if (i < 26) {\r\n                this.markupLabel = String.fromCharCode(aChar + i);\r\n              }\r\n\r\n              //a-z\r\n              else if (i < 52) {\r\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\r\n              }\r\n\r\n              //AA, AB, AC, etc.\r\n              else {\r\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\r\n                  String.fromCharCode(aChar + (i % 26));\r\n              }\r\n\r\n              //Keep going\r\n              i++;\r\n            }\r\n            break;\r\n\r\n          //Number tool?\r\n          case MarkupTools.NUMBER:\r\n            this.markupLabel = 0;\r\n\r\n            //Loop while the label is present\r\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n              this.markupLabel++;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeEdit = {\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items\r\n        this.board.removeAll('hover');\r\n\r\n        //Single coordinate?\r\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //No dragging for labels\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //Loop area\r\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n            updateHoverMark.call(this, x, y, true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Keydown handler\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //TODO: tool switching via keyboard input\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Click handler\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        this.board.removeAll('hover');\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Try to play the move\r\n            if (!this.game.play(event.x, event.y)) {\r\n              return;\r\n            }\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Set stone and update board\r\n            setStone.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Set markup and update board\r\n            setMarkup.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Mouse drag handler\r\n       */\r\n      mouseDrag: function(event) {\r\n\r\n        //Initialize vars\r\n        var x, y;\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setStone.call(this, x, y, true);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Don't do this for labels\r\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n              break;\r\n            }\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setMarkup.call(this, x, y);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change\r\n       */\r\n      pathChange: function() {\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SETUP,\r\n          PlayerTools.MARKUP,\r\n          PlayerTools.SCORE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Find all markup labels in the current game position\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeEdit;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\r\n * through an existing game record without the ability to deviate from the tree or its variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Replay.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\r\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\r\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\r\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\r\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\r\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\r\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\r\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\r\n\r\n  //Register the mode\r\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeReplay', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Auto play delay\r\n    autoPlayDelay: 1000\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show move variations on the board\r\n     */\r\n    function showMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n\r\n        //Auto variation markup should never overwrite existing markup\r\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\r\n          continue;\r\n        }\r\n\r\n        //Add to board\r\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n          type: this.board.theme.get('markup.variation.type'),\r\n          text: this.board.theme.get('markup.variation.text', i),\r\n          color: this.board.theme.get('markup.variation.color')\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide move variations from the board\r\n     */\r\n    function hideMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) move variations on the board\r\n     */\r\n    function drawMoveVariations(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get the current node\r\n      var node = this.game.getNode();\r\n      var variations;\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      //Child variations?\r\n      if (this.variationChildren && node.hasMoveVariations()) {\r\n        variations = node.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n\r\n      //Sibling variations?\r\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\r\n        variations = node.parent.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Auto play vars\r\n      autoPlaying: false,\r\n      autoPlayDelay: 1000,\r\n      autoPlayPromise: null,\r\n\r\n      /**\r\n       * Set auto play delay\r\n       */\r\n      setAutoPlayDelay: function(delay) {\r\n        if (this.autoPlayDelay !== delay) {\r\n          this.autoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'autoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Start auto play with a given delay\r\n       */\r\n      start: function(delay) {\r\n\r\n        //Not in replay mode or already auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Already auto playing, no game or no move children?\r\n        if (!this.game || !this.game.node.hasChildren()) {\r\n          return;\r\n        }\r\n\r\n        //Get self\r\n        var self = this;\r\n\r\n        //Determine delay\r\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\r\n\r\n        //Switch tool\r\n        this.switchTool(PlayerTools.NONE);\r\n\r\n        //Create interval\r\n        this.autoPlaying = true;\r\n        this.autoPlayPromise = $interval(function() {\r\n\r\n          //Advance to the next node\r\n          self.next(0, true);\r\n\r\n          //Ran out of children?\r\n          if (!self.game.node.hasChildren()) {\r\n            self.stop();\r\n          }\r\n        }, delay);\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStarted', this.game.node);\r\n      },\r\n\r\n      /**\r\n       * Stop auto play\r\n       */\r\n      stop: function() {\r\n\r\n        //Not in replay mode or not auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Cancel interval\r\n        if (this.autoPlayPromise) {\r\n          $interval.cancel(this.autoPlayPromise);\r\n        }\r\n\r\n        //Clear flags\r\n        this.autoPlayPromise = null;\r\n        this.autoPlaying = false;\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStopped', this.game.node);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeReplay = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'variationMarkup') {\r\n          drawMoveVariations.call(this, this.variationMarkup);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Check if we clicked a move variation, advance to the next position if so\r\n            if (this.game.isMoveVariation(event.x, event.y)) {\r\n              this.next(this.game.getMoveVariation(event.x, event.y));\r\n            }\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeReplay.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SCORE,\r\n          PlayerTools.NONE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Stop auto playing\r\n        if (this.autoPlaying) {\r\n          this.stop();\r\n        }\r\n\r\n        //Hide move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, false);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeReplay;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\r\n * go problems and finding the right move or variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Solve.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\r\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\r\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\r\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\r\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\r\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\r\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\r\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Player color\r\n    playerColor: StoneColor.B,\r\n\r\n    //Show solution paths\r\n    solutionPaths: false,\r\n\r\n    //Auto play settings\r\n    solveAutoPlay: true,\r\n    solveAutoPlayDelay: 500\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\r\n\r\n    /**\r\n     * Check if we can make a move\r\n     */\r\n    function canMakeMove() {\r\n\r\n      //We can make a move when...\r\n\r\n      //...there is no auto play going on\r\n      if (!this.solveAutoPlay) {\r\n        return true;\r\n      }\r\n\r\n      //...we solved the puzzle already\r\n      if (this.problemSolved) {\r\n        return true;\r\n      }\r\n\r\n      //...we are off path\r\n      if (this.problemOffPath) {\r\n        return true;\r\n      }\r\n\r\n      //...it's our turn\r\n      if (this.game.getTurn() === this.playerColor) {\r\n        return true;\r\n      }\r\n\r\n      //Otherwise, we can't make a move\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show solution paths\r\n     */\r\n    function showSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        if (variations[i].solution === true) {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.valid.type'),\r\n            text: this.board.theme.get('markup.solution.valid.text', i),\r\n            scale: this.board.theme.get('markup.solution.valid.scale'),\r\n            color: this.board.theme.get('markup.solution.valid.color')\r\n          });\r\n        }\r\n        else {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.invalid.type'),\r\n            text: this.board.theme.get('markup.solution.invalid.text', i),\r\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\r\n            color: this.board.theme.get('markup.solution.invalid.color')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide solution paths\r\n     */\r\n    function hideSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) solution paths\r\n     */\r\n    function drawSolutionPaths(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get node and variations\r\n      var node = this.game.getNode();\r\n      var variations = node.getMoveVariations();\r\n\r\n      //When showing, make sure it's not during the auto solver's move\r\n      if (show && !this.problemSolved && this.solveAutoPlay) {\r\n        if (this.game.getTurn() !== this.playerColor) {\r\n          hideSolutionPaths.call(this, variations);\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Call helper\r\n      if (show) {\r\n        showSolutionPaths.call(this, variations);\r\n      }\r\n      else {\r\n        hideSolutionPaths.call(this, variations);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Solved and off-path flags\r\n      problemSolved: false,\r\n      problemOffPath: false,\r\n\r\n      //Problem start path\r\n      problemStartPath: null,\r\n\r\n      //The player color\r\n      playerColor: 0,\r\n\r\n      //Solution paths\r\n      solutionPaths: false,\r\n\r\n      //Auto play vars\r\n      solveAutoPlay: true,\r\n      solveAutoPlayDelay: 500,\r\n\r\n      //Navigation blocked flag\r\n      solveNavigationBlocked: false,\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlay: function(autoPlay) {\r\n        if (this.solveAutoPlay !== autoPlay) {\r\n          this.solveAutoPlay = autoPlay;\r\n          this.broadcast('settingChange', 'solveAutoPlay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlayDelay: function(delay) {\r\n        if (this.solveAutoPlayDelay !== delay) {\r\n          this.solveAutoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set player color\r\n       */\r\n      setPlayerColor: function(color) {\r\n        if (this.playerColor !== color) {\r\n          this.playerColor = color;\r\n          this.broadcast('settingChange', 'playerColor');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Get player color\r\n       */\r\n      getPlayerColor: function(asOnBoard) {\r\n        if (asOnBoard && this.board) {\r\n          return this.board.colorMultiplier * this.playerColor;\r\n        }\r\n        return this.playerColor;\r\n      },\r\n\r\n      /**\r\n       * Toggle solution paths\r\n       */\r\n      toggleSolutionPaths: function(solutionPaths) {\r\n\r\n        //Toggle if not given\r\n        if (typeof solutionPaths === 'undefined') {\r\n          solutionPaths = !this.solutionPaths;\r\n        }\r\n\r\n        //Change?\r\n        if (solutionPaths !== this.solutionPaths) {\r\n          this.solutionPaths = solutionPaths;\r\n          this.broadcast('settingChange', 'solutionPaths');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Auto play next move\r\n       */\r\n      autoPlayNext: function(immediately) {\r\n\r\n        //Must have game and children\r\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\r\n          return;\r\n        }\r\n\r\n        //Init vars\r\n        var children = [];\r\n        var self = this;\r\n        var i;\r\n\r\n        //When picking a child node, we always prefer to pick a valid solution\r\n        for (i = 0; i < this.game.node.children.length; i++) {\r\n          if (this.game.node.children[i].solution) {\r\n            children.push(this.game.node.children[i]);\r\n          }\r\n        }\r\n\r\n        //No solution nodes? Just use all nodes then.\r\n        if (children.length === 0) {\r\n          children = this.game.node.children;\r\n        }\r\n\r\n        //Pick a random child node\r\n        i = Math.floor(Math.random() * children.length);\r\n\r\n        //No delay?\r\n        if (immediately || !this.solveAutoPlayDelay) {\r\n          this.next(children[i]);\r\n          return;\r\n        }\r\n\r\n        //Block navigation and run the timeout\r\n        this.solveNavigationBlocked = true;\r\n        $timeout(function() {\r\n\r\n          //Move to next move and unblock navigation\r\n          self.next(children[i]);\r\n          self.solveNavigationBlocked = false;\r\n\r\n        }, this.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Start solving from the current game node\r\n       */\r\n      solve: function() {\r\n\r\n        //Must have a game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return false;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Remember problem start path\r\n        this.problemStartPath = this.game.getPath(true);\r\n\r\n        //Restrict start of navigation to the current node\r\n        this.restrictNode();\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restart the problem\r\n       */\r\n      restartProblem: function() {\r\n\r\n        //Must be in solve mode, must have game\r\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Go back to the start path\r\n        if (this.problemStartPath) {\r\n          this.goto(this.problemStartPath);\r\n        }\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeSolve = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.toggleSolutionPaths(this.config.solutionPaths);\r\n        this.setPlayerColor(this.config.playerColor);\r\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\r\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'solutionPaths') {\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n        }\r\n\r\n        //Player color changed?\r\n        if (setting === 'playerColor') {\r\n\r\n          //Draw (or hide) solution paths\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n\r\n          //Make an auto play move if it's not our turn\r\n          if (\r\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\r\n          ) {\r\n            this.autoPlayNext(true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this, event.x, event.y);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for keydown events\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //Right arrow\r\n          case KeyCodes.RIGHT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\r\n\r\n                //Go forward one move if solved\r\n                if (this.problemSolved) {\r\n                  this.next();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n\r\n          //Left arrow\r\n          case KeyCodes.LEFT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked and not reached the start?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\r\n\r\n                //Go back one move\r\n                this.previous();\r\n\r\n                //Go back one more if this is not the player's turn and if\r\n                //the problem hasn't been solved yet\r\n                if (\r\n                  !this.problemSolved && this.solveAutoPlay &&\r\n                  this.game.getTurn() === -this.playerColor\r\n                ) {\r\n                  this.previous();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //A valid variation\r\n        if (this.game.isMoveVariation(event.x, event.y)) {\r\n\r\n          //Get the node\r\n          var i = this.game.getMoveVariation(event.x, event.y);\r\n\r\n          //Advance to the next position and get the next node\r\n          this.next(i);\r\n          var node = this.game.getNode();\r\n\r\n          //No children left? Check if we solved it or not\r\n          if (node.children.length === 0) {\r\n            if (node.solution === true) {\r\n              this.problemSolved = true;\r\n              this.broadcast('solutionFound', node);\r\n            }\r\n            else {\r\n              this.broadcast('solutionWrong', node);\r\n            }\r\n          }\r\n\r\n          //Auto-play next move?\r\n          else if (!this.problemSolved && this.solveAutoPlay) {\r\n            this.autoPlayNext();\r\n          }\r\n        }\r\n\r\n        //Unknown variation, try to play\r\n        else if (this.game.play(event.x, event.y)) {\r\n          this.problemOffPath = true;\r\n          this.processPosition();\r\n          this.broadcast('solutionOffPath', this.game.getNode());\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Draw solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Hide any solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, false);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeSolve;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\r\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions\r\n   */\r\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\r\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\r\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\r\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\r\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\r\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\r\n\r\n  /**\r\n   * Player parser function\r\n   */\r\n  function parsePlayer(jgf, match) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\r\n\r\n    //Create player object\r\n    var player = {\r\n      color: color,\r\n      name: match[2],\r\n      rank: match[3].toLowerCase()\r\n    };\r\n\r\n    //Check if player of this color already exists, if so, overwrite\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p] = player;\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, push\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, match) {\r\n    jgf.game.komi = parseFloat(match[1] / 10);\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, match) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Push date\r\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\r\n  }\r\n\r\n  /**\r\n   * Result parser function\r\n   */\r\n  function parseResult(jgf, match) {\r\n\r\n    //Winner color\r\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\r\n    result += '+';\r\n\r\n    //Win condition\r\n    if (match[2].match(/res/i)) {\r\n      result += 'R';\r\n    }\r\n    else if (match[2].match(/time/i)) {\r\n      result += 'T';\r\n    }\r\n    else {\r\n      result += match[2];\r\n    }\r\n\r\n    //Set in JGF\r\n    jgf.game.result = result;\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, match) {\r\n\r\n    //Determine player color\r\n    var color = match[2];\r\n    if (color === 1) {\r\n      color = 'B';\r\n    }\r\n    else if (color === 2) {\r\n      color = 'W';\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (false) {\r\n\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[color] = [match[3] * 1, match[4] * 1];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    parse: function(gib, stringified) {\r\n\r\n      //Get new JGF object\r\n      var jgf = KifuBlank.jgf();\r\n\r\n      //Initialize\r\n      var match;\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find player information\r\n      while ((match = regPlayer.exec(gib))) {\r\n        parsePlayer(jgf, match);\r\n      }\r\n\r\n      //Find komi\r\n      if ((match = regKomi.exec(gib))) {\r\n        parseKomi(jgf, match);\r\n      }\r\n\r\n      //Find game date\r\n      if ((match = regDate.exec(gib))) {\r\n        parseDate(jgf, match);\r\n      }\r\n\r\n      //Find game result\r\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\r\n        parseResult(jgf, match);\r\n      }\r\n\r\n      //Find moves\r\n      while ((match = regMove.exec(gib))) {\r\n\r\n        //Create new node\r\n        node = {};\r\n\r\n        //Parse move\r\n        parseMove(jgf, node, match);\r\n\r\n        //Push node to container\r\n        container.push(node);\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Flip SGF alias map and create JGF alias map\r\n   */\r\n  var jgfAliases = {};\r\n  for (var sgfProp in sgfAliases) {\r\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\r\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert to SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to escape SGF info\r\n   */\r\n  function escapeSgf(text) {\r\n    if (typeof text === 'string') {\r\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\r\n    }\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Helper to write an SGF group\r\n   */\r\n  function writeGroup(prop, values, output, escape) {\r\n    if (values.length) {\r\n      output.sgf += prop;\r\n      for (var i = 0; i < values.length; i++) {\r\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser\r\n   */\r\n  function parseMove(move, output) {\r\n\r\n    //Determine and validate color\r\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\r\n    if (color === '') {\r\n      return;\r\n    }\r\n\r\n    //Determine move\r\n    var coords = (move[color] === 'pass') ? '' : move[color];\r\n\r\n    //Append to SGF\r\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\r\n  }\r\n\r\n  /**\r\n   * Setup parser\r\n   */\r\n  function parseSetup(setup, output) {\r\n\r\n    //Loop colors\r\n    for (var color in setup) {\r\n      if (setup.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < setup[color].length; i++) {\r\n          setup[color][i] = convertCoordinates(setup[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('A' + color, setup[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Score parser\r\n   */\r\n  function parseScore(score, output) {\r\n\r\n    //Loop colors\r\n    for (var color in score) {\r\n      if (score.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < score[color].length; i++) {\r\n          score[color][i] = convertCoordinates(score[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('T' + color, score[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser\r\n   */\r\n  function parseMarkup(markup, output) {\r\n\r\n    //Loop markup types\r\n    for (var type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n        var i;\r\n\r\n        //Label type has the label text appended to the coords\r\n        if (type === 'label') {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\r\n          }\r\n        }\r\n        else {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]);\r\n          }\r\n        }\r\n\r\n        //Convert type\r\n        if (typeof jgfAliases[type] !== 'undefined') {\r\n          type = jgfAliases[type];\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup(type, markup[type], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser\r\n   */\r\n  function parseTurn(turn, output) {\r\n    output.sgf += 'PL[' + turn + ']';\r\n  }\r\n\r\n  /**\r\n   * Comments parser\r\n   */\r\n  function parseComments(comments, output) {\r\n\r\n    //Determine key\r\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\r\n\r\n    //Flatten comment objects\r\n    var flatComments = [];\r\n    for (var c = 0; c < comments.length; c++) {\r\n      if (typeof comments[c] === 'string') {\r\n        flatComments.push(comments[c]);\r\n      }\r\n      else if (comments[c].comment) {\r\n        flatComments.push(comments[c].comment);\r\n      }\r\n    }\r\n\r\n    //Write as group\r\n    writeGroup(key, flatComments, output, true);\r\n  }\r\n\r\n  /**\r\n   * Node name parser\r\n   */\r\n  function parseNodeName(nodeName, output) {\r\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\r\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\r\n  }\r\n\r\n  /**\r\n   * Game parser\r\n   */\r\n  function parseGame(game) {\r\n\r\n    //Loop SGF game definitions\r\n    for (var i in sgfGames) {\r\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Application parser\r\n   */\r\n  function parseApplication(application) {\r\n    var parts = application.split(' v');\r\n    if (parts.length > 1) {\r\n      return parts[0] + ':' + parts[1];\r\n    }\r\n    return application;\r\n  }\r\n\r\n  /**\r\n   * Player instructions parser\r\n   */\r\n  function parsePlayer(player, rootProperties) {\r\n\r\n    //Variation handling\r\n    var st = 0;\r\n    if (!player.variationMarkup) {\r\n      st += 2;\r\n    }\r\n    if (player.variationSiblings) {\r\n      st += 1;\r\n    }\r\n\r\n    //Set in root properties\r\n    rootProperties.ST = st;\r\n  }\r\n\r\n  /**\r\n   * Board parser\r\n   */\r\n  function parseBoard(board, rootProperties) {\r\n\r\n    //Both width and height should be given\r\n    if (board.width && board.height) {\r\n\r\n      //Same dimensions?\r\n      if (board.width === board.height) {\r\n        rootProperties.SZ = board.width;\r\n      }\r\n\r\n      //Different dimensions are not supported by SGF, but OGS uses the\r\n      //format w:h, so we will stick with that for anyone who supports it.\r\n      else {\r\n        rootProperties.SZ = board.width + ':' + board.height;\r\n      }\r\n    }\r\n\r\n    //Otherwise, check if only width or height were given at least\r\n    else if (board.width) {\r\n      rootProperties.SZ = board.width;\r\n    }\r\n    else if (board.height) {\r\n      rootProperties.SZ = board.height;\r\n    }\r\n\r\n    //Can't determine size\r\n    else {\r\n      rootProperties.SZ = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Players parser\r\n   */\r\n  function parsePlayers(players, rootProperties) {\r\n\r\n    //Loop players\r\n    for (var p = 0; p < players.length; p++) {\r\n\r\n      //Validate color\r\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\r\n        continue;\r\n      }\r\n\r\n      //Get SGF color\r\n      var color = (players[p].color === 'black') ? 'B' : 'W';\r\n\r\n      //Name given?\r\n      if (players[p].name) {\r\n        rootProperties['P' + color] = players[p].name;\r\n      }\r\n\r\n      //Rank given?\r\n      if (players[p].rank) {\r\n        rootProperties[color + 'R'] = players[p].rank;\r\n      }\r\n\r\n      //Team given?\r\n      if (players[p].team) {\r\n        rootProperties[color + 'T'] = players[p].team;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Node properties\r\n    'move': parseMove,\r\n    'setup': parseSetup,\r\n    'score': parseScore,\r\n    'markup': parseMarkup,\r\n    'turn': parseTurn,\r\n    'comments': parseComments,\r\n    'name': parseNodeName,\r\n\r\n    //Info properties\r\n    'record.application': parseApplication,\r\n    'player': parsePlayer,\r\n    'board': parseBoard,\r\n    'game.type': parseGame,\r\n    'game.players': parsePlayers\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Parser functions\r\n   ***/\r\n\r\n  /**\r\n   * Helper to write a JGF tree to SGF\r\n   */\r\n  function writeTree(tree, output) {\r\n\r\n    //Loop nodes in the tree\r\n    for (var i = 0; i < tree.length; i++) {\r\n      var node = tree[i];\r\n\r\n      //Array? That means a variation\r\n      if (angular.isArray(node)) {\r\n        for (var j = 0; j < node.length; j++) {\r\n          output.sgf += '(\\n;';\r\n          writeTree(node[j], output);\r\n          output.sgf += '\\n)';\r\n        }\r\n\r\n        //Continue\r\n        continue;\r\n      }\r\n\r\n      //Loop node properties\r\n      for (var key in node) {\r\n        if (node.hasOwnProperty(key)) {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n            parsingMap[key](node[key], output);\r\n            continue;\r\n          }\r\n\r\n          //Other object, can't handle it\r\n          if (typeof node[key] === 'object') {\r\n            continue;\r\n          }\r\n\r\n          //Anything else, append it\r\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //More to come?\r\n      if ((i + 1) < tree.length) {\r\n        output.sgf += '\\n;';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to extract all SGF root properties from a JGF object\r\n   */\r\n  function extractRootProperties(jgf, rootProperties, key) {\r\n\r\n    //Initialize key\r\n    if (typeof key === 'undefined') {\r\n      key = '';\r\n    }\r\n\r\n    //Loop properties of jgf node\r\n    for (var subKey in jgf) {\r\n      if (jgf.hasOwnProperty(subKey)) {\r\n\r\n        //Skip SGF signature (as we keep our own)\r\n        if (subKey === 'sgf') {\r\n          continue;\r\n        }\r\n\r\n        //Build jgf key\r\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\r\n\r\n        //If the item is an object, handle separately\r\n        if (typeof jgf[subKey] === 'object') {\r\n\r\n          //Handler for this object present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\r\n          }\r\n\r\n          //Otherwise, just flatten and call this function recursively\r\n          else {\r\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Check if it's a known key, if so, append the value to the root\r\n        var value;\r\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            value = parsingMap[jgfKey](jgf[subKey]);\r\n          }\r\n          else {\r\n            value = escapeSgf(jgf[subKey]);\r\n          }\r\n\r\n          //Set in root properties\r\n          rootProperties[jgfAliases[jgfKey]] = value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    parse: function(jgf) {\r\n\r\n      //String given?\r\n      if (typeof jgf === 'string') {\r\n        jgf = angular.fromJson(jgf);\r\n      }\r\n\r\n      //Must have moves tree\r\n      if (!jgf.tree) {\r\n        console.error('No moves tree in JGF object');\r\n        return;\r\n      }\r\n\r\n      //Initialize output (as object, so it remains a reference) and root properties container\r\n      var output = {sgf: '(\\n;'};\r\n      var root = angular.copy(jgf);\r\n      var rootProperties = KifuBlank.sgf();\r\n\r\n      //The first node of the JGF tree is the root node, and it can contain comments,\r\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\r\n      //and attach it to the root\r\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\r\n        root = angular.extend(root, jgf.tree[0]);\r\n        delete root.root;\r\n        delete jgf.tree[0];\r\n      }\r\n\r\n      //Set root properties\r\n      delete root.tree;\r\n      extractRootProperties(root, rootProperties);\r\n\r\n      //Write root properties\r\n      for (var key in rootProperties) {\r\n        if (rootProperties[key]) {\r\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //Write game tree\r\n      writeTree(jgf.tree, output);\r\n\r\n      //Close SGF and return\r\n      output.sgf += ')';\r\n      return output.sgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions for SGF data\r\n   */\r\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\r\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\r\n  var regProperty = /[A-Z]+/;\r\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Application parser function (doesn't overwrite existing signature)\r\n   */\r\n  function parseApp(jgf, node, key, value) {\r\n    if (!jgf.record.application) {\r\n      var app = value[0].split(':');\r\n      if (app.length > 1) {\r\n        jgf.record.application = app[0] + ' v' + app[1];\r\n      }\r\n      else {\r\n        jgf.record.application = app[0];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SGF format parser\r\n   */\r\n  function parseSgfFormat() {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Game type parser function\r\n   */\r\n  function parseGame(jgf, node, key, value) {\r\n    var game = value[0];\r\n    if (typeof sgfGames[game] !== 'undefined') {\r\n      jgf.game.type = sgfGames[game];\r\n    }\r\n    else {\r\n      jgf.game.type = value[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, key, value) {\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\r\n      node.move[key] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[key] = convertCoordinates(value[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Comment parser function\r\n   */\r\n  function parseComment(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Node name parser function\r\n   */\r\n  function parseNodeName(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value[0];\r\n  }\r\n\r\n  /**\r\n   * Board setup parser function\r\n   */\r\n  function parseSetup(jgf, node, key, value) {\r\n\r\n    //Initialize setup container on node\r\n    if (typeof node.setup === 'undefined') {\r\n      node.setup = {};\r\n    }\r\n\r\n    //Remove \"A\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Initialize setup container of this type\r\n    if (typeof node.setup[key] === 'undefined') {\r\n      node.setup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.setup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scoring parser function\r\n   */\r\n  function parseScore(jgf, node, key, value) {\r\n\r\n    //Initialize score container on node\r\n    if (typeof node.score === 'undefined') {\r\n      node.score = {\r\n        B: [],\r\n        W: []\r\n      };\r\n    }\r\n\r\n    //Remove \"T\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.score[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser function\r\n   */\r\n  function parseTurn(jgf, node, key, value) {\r\n    node.turn = value[0];\r\n  }\r\n\r\n  /**\r\n   * Label parser function\r\n   */\r\n  function parseLabel(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n\r\n      //Split off coordinates and add label contents\r\n      var coords = convertCoordinates(value[i].substr(0, 2));\r\n      coords.push(value[i].substr(3));\r\n\r\n      //Add to node\r\n      node.markup[key].push(coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser function\r\n   */\r\n  function parseMarkup(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.markup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Size parser function\r\n   */\r\n  function parseSize(jgf, node, key, value) {\r\n\r\n    //Initialize board container\r\n    if (typeof jgf.board === 'undefined') {\r\n      jgf.board = {};\r\n    }\r\n\r\n    //Add size property (can be width:height or just a single size)\r\n    var size = value[0].split(':');\r\n    if (size.length > 1) {\r\n      jgf.board.width = parseInt(size[0]);\r\n      jgf.board.height = parseInt(size[1]);\r\n    }\r\n    else {\r\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, node, key, value) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Explode dates\r\n    var dates = value[0].split(',');\r\n    for (var d = 0; d < dates.length; d++) {\r\n      jgf.game.dates.push(dates[d]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, node, key, value) {\r\n    jgf.game.komi = parseFloat(value[0]);\r\n  }\r\n\r\n  /**\r\n   * Variations handling parser function\r\n   */\r\n  function parseVariations(jgf, node, key, value) {\r\n\r\n    //Initialize display property\r\n    if (typeof jgf.player === 'undefined') {\r\n      jgf.player = {};\r\n    }\r\n\r\n    //Initialize variation display settings\r\n    jgf.player.variationMarkup = false;\r\n    jgf.player.variationChildren = false;\r\n    jgf.player.variationSiblings = false;\r\n\r\n    //Parse as integer\r\n    var st = parseInt(value[0]);\r\n\r\n    //Determine what we want (see SGF specs for details)\r\n    switch (st) {\r\n      case 0:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 1:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n      case 2:\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 3:\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Player info parser function\r\n   */\r\n  function parsePlayer(jgf, node, key, value) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Check if player of this color already exists\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p][key] = value[0];\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, initialize\r\n    var player = {color: color};\r\n    player[key] = value[0];\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Parsing function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Application, game type, board size, komi, date\r\n    'AP': parseApp,\r\n    'FF': parseSgfFormat,\r\n    'GM': parseGame,\r\n    'SZ': parseSize,\r\n    'KM': parseKomi,\r\n    'DT': parseDate,\r\n\r\n    //Variations handling\r\n    'ST': parseVariations,\r\n\r\n    //Player info handling\r\n    'PB': parsePlayer,\r\n    'PW': parsePlayer,\r\n    'BT': parsePlayer,\r\n    'WT': parsePlayer,\r\n    'BR': parsePlayer,\r\n    'WR': parsePlayer,\r\n\r\n    //Moves\r\n    'B': parseMove,\r\n    'W': parseMove,\r\n\r\n    //Node annotation\r\n    'C': parseComment,\r\n    'N': parseNodeName,\r\n\r\n    //Board setup\r\n    'AB': parseSetup,\r\n    'AW': parseSetup,\r\n    'AE': parseSetup,\r\n    'PL': parseTurn,\r\n    'TW': parseScore,\r\n    'TB': parseScore,\r\n\r\n    //Markup\r\n    'CR': parseMarkup,\r\n    'SQ': parseMarkup,\r\n    'TR': parseMarkup,\r\n    'MA': parseMarkup,\r\n    'SL': parseMarkup,\r\n    'LB': parseLabel\r\n  };\r\n\r\n  /**\r\n   * These properties need a node object\r\n   */\r\n  var needsNode = [\r\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\r\n  ];\r\n\r\n  /*****************************************************************************\r\n   * Parser helpers\r\n   ***/\r\n\r\n  /**\r\n   * Set info in the JGF tree at a certain position\r\n   */\r\n  function setInfo(jgf, position, value) {\r\n\r\n    //Position given must be an array\r\n    if (typeof position !== 'object') {\r\n      return;\r\n    }\r\n\r\n    //Initialize node to attach value to\r\n    var node = jgf;\r\n    var key;\r\n\r\n    //Loop the position\r\n    for (var p = 0; p < position.length; p++) {\r\n\r\n      //Get key\r\n      key = position[p];\r\n\r\n      //Last key reached? Done\r\n      if ((p + 1) === position.length) {\r\n        break;\r\n      }\r\n\r\n      //Create container if not set\r\n      if (typeof node[key] !== 'object') {\r\n        node[key] = {};\r\n      }\r\n\r\n      //Move up in tree\r\n      node = node[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    parse: function(sgf, stringified) {\r\n\r\n      //Get new JGF object (with SGF node as a base)\r\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\r\n\r\n      //Initialize\r\n      var stack = [];\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find sequence of elements\r\n      var sequence = sgf.match(regSequence);\r\n\r\n      //Loop sequence items\r\n      for (var i = 0; i < sequence.length; i++) {\r\n\r\n        //Push stack if new variation found\r\n        if (sequence[i] === '(') {\r\n\r\n          //First encounter, this defines the main tree branch, so skip\r\n          if (i === 0 || i === '0') {\r\n            continue;\r\n          }\r\n\r\n          //Push the current container to the stack\r\n          stack.push(container);\r\n\r\n          //Create variation container if it doesn't exist yet\r\n          if (!angular.isArray(container[container.length - 1])) {\r\n            container.push([]);\r\n          }\r\n\r\n          //Use variation container\r\n          container = container[container.length - 1];\r\n\r\n          //Now create moves container\r\n          container.push([]);\r\n          container = container[container.length - 1];\r\n          continue;\r\n        }\r\n\r\n        //Grab last container from stack if end of variation reached\r\n        else if (sequence[i] === ')') {\r\n          if (stack.length) {\r\n            container = stack.pop();\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Make array of properties within this sequence\r\n        var properties = sequence[i].match(regNode) || [];\r\n\r\n        //Loop them\r\n        for (var j = 0; j < properties.length; j++) {\r\n\r\n          //Get property's key and separate values\r\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\r\n          var values = properties[j].match(regValues);\r\n\r\n          //Remove additional braces [ and ]\r\n          for (var k = 0; k < values.length; k++) {\r\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\r\n          }\r\n\r\n          //SGF parser present for this key? Call it, and we're done\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n\r\n            //Does this type of property need a node?\r\n            if (needsNode.indexOf(key) !== -1) {\r\n\r\n              //If no node object present, create a new node\r\n              //For moves, always a new node is created\r\n              if (!node || key === 'B' || key === 'W') {\r\n                node = {};\r\n                container.push(node);\r\n              }\r\n            }\r\n\r\n            //Apply parsing function on node\r\n            parsingMap[key](jgf, node, key, values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF parser present, we continue with regular property handling\r\n\r\n          //If there is only one value, simplify array\r\n          if (values.length === 1) {\r\n            values = values[0];\r\n          }\r\n\r\n          //SGF alias known? Then this is an info element and we handle it accordingly\r\n          if (typeof sgfAliases[key] !== 'undefined') {\r\n\r\n            //The position in the JGF object is represented by dot separated strings\r\n            //in the sgfAliases array. Split the position and use the setInfo helper\r\n            //to set the info on the JGF object\r\n            setInfo(jgf, sgfAliases[key].split('.'), values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF alias present either, just append the data\r\n\r\n          //Save in node\r\n          if (node) {\r\n            node[key] = values;\r\n          }\r\n\r\n          //Save in root\r\n          else {\r\n            jgf[key] = values;\r\n          }\r\n        }\r\n\r\n        //Reset node, unless this was the root node\r\n        if (node && !node.root) {\r\n          node = null;\r\n        }\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","/**\n * ng-go - v1.3.1.1 - 28-8-2016\n * https://github.com/cookwu/ngGo\n *\n * Copyright (c) 2016 Cook Wu <cookwu@webaker.net>\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n/**\r\n * ngGo\r\n *\r\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\r\n * refactored to fit the Angular framework, as well as having been linted, properly commented\r\n * and generally cleaned up.\r\n *\r\n * Copyright (c) 2013 Jan Prokop (WGo)\r\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify, merge,\r\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\r\n * to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo', [])\r\n\r\n/**\r\n * ngGo constants\r\n */\r\n.constant('ngGo', {\r\n  name: 'ngGo',\r\n  version: '1.3.1',\r\n  error: {\r\n\r\n    //Position errors\r\n    POSITION_OUT_OF_BOUNDS: 1,\r\n    POSITION_ALREADY_HAS_STONE: 2,\r\n    POSITION_IS_SUICIDE: 3,\r\n    POSITION_IS_REPEATING: 4,\r\n\r\n    //Data loading errors\r\n    NO_DATA: 5,\r\n    UNKNOWN_DATA: 6,\r\n    INVALID_SGF: 7,\r\n    INVALID_GIB: 8,\r\n    INVALID_JGF_JSON: 9,\r\n    INVALID_JGF_TREE_JSON: 10\r\n  }\r\n})\r\n\r\n/**\r\n * Stone colors\r\n */\r\n.constant('StoneColor', {\r\n  E: 0,\r\n  EMPTY: 0,\r\n  B: 1,\r\n  BLACK: 1,\r\n  W: -1,\r\n  WHITE: -1\r\n})\r\n\r\n/**\r\n * Markup types\r\n */\r\n.constant('MarkupTypes', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  LABEL: 'label',\r\n  LAST: 'last',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy'\r\n})\r\n\r\n/**\r\n * Player modes\r\n */\r\n.constant('PlayerModes', {\r\n  PLAY: 'play',\r\n  REPLAY: 'replay',\r\n  EDIT: 'edit',\r\n  SOLVE: 'solve'\r\n})\r\n\r\n/**\r\n * Player tools\r\n */\r\n.constant('PlayerTools', {\r\n  NONE: 'none',\r\n  MOVE: 'move',\r\n  SCORE: 'score',\r\n  SETUP: 'setup',\r\n  MARKUP: 'markup'\r\n})\r\n\r\n/**\r\n * Key codes\r\n */\r\n.constant('KeyCodes', {\r\n  LEFT: 37,\r\n  RIGHT: 39,\r\n  UP: 38,\r\n  DOWN: 40,\r\n  ESC: 27,\r\n  ENTER: 13,\r\n  SPACE: 32,\r\n  TAB: 9,\r\n  SHIFT: 16,\r\n  CTRL: 17,\r\n  ALT: 18,\r\n  HOME: 36,\r\n  END: 35,\r\n  PAGEUP: 33,\r\n  PAGEDOWN: 34\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Directive', [\r\n  'ngGo.Board.Service'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('board', ['$window', 'Board', function($window, Board) {\r\n\r\n  //Get pixel ratio\r\n  var pixelRatio = window.devicePixelRatio || 1;\r\n\r\n  /**\r\n   * Helper to create a layer canvas\r\n   */\r\n  function createLayerCanvas(name) {\r\n\r\n    //Create canvas element and get context\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    //Scale context depending on pixel ratio\r\n    if (pixelRatio > 1) {\r\n      context.scale(pixelRatio, pixelRatio);\r\n    }\r\n\r\n    //Set class\r\n    canvas.className = name;\r\n\r\n    //Set initial canvas width/height based on our own size\r\n    canvas.width = this.clientWidth * pixelRatio;\r\n    canvas.height = this.clientHeight * pixelRatio;\r\n\r\n    //Append to element now and return context\r\n    this.appendChild(canvas);\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Helper to determine draw size\r\n   */\r\n  function determineDrawSize(scope, availableWidth, availableHeight) {\r\n\r\n    //Init vars\r\n    var drawWidth, drawHeight, cellSize;\r\n\r\n    //Stretch available height to width if zero\r\n    if (availableHeight === 0 && availableWidth > 0) {\r\n      availableHeight = availableWidth;\r\n    }\r\n\r\n    //Grid size known?\r\n    if (scope.Board.width && scope.Board.height) {\r\n\r\n      //Determine smallest cell size\r\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\r\n\r\n      //Set draw size\r\n      drawWidth = Math.floor(cellSize * scope.Board.width);\r\n      drawHeight = Math.floor(cellSize * scope.Board.height);\r\n    }\r\n\r\n    //Otherwise, use the lesser of the available width/height\r\n    else {\r\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\r\n    }\r\n\r\n    //Broadcast new size if changed\r\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\r\n      scope.lastDrawWidth = drawWidth;\r\n      scope.lastDrawHeight = drawHeight;\r\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\r\n      return true;\r\n    }\r\n\r\n    //No change\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Directive\r\n   */\r\n  return {\r\n    restrict: 'E',\r\n    scope: {\r\n      instance: '&'\r\n    },\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Init vars\r\n      var i, context, layer, playerElement;\r\n      var parent = element.parent();\r\n      var sizingElement = element[0];\r\n      var existingInstance = true;\r\n\r\n      //Remember last draw width/height\r\n      scope.lastDrawWidth = 0;\r\n      scope.lastDrawHeight = 0;\r\n\r\n      //Get board instance\r\n      scope.Board = scope.instance();\r\n\r\n      //Function given?\r\n      if (typeof scope.Board === 'function') {\r\n        scope.Board = scope.Board();\r\n      }\r\n\r\n      //Instantiate board if not present in scope\r\n      if (!scope.Board) {\r\n        existingInstance = false;\r\n        scope.Board = new Board();\r\n      }\r\n\r\n      //Link element\r\n      scope.Board.linkElement(element);\r\n\r\n      //Find player element\r\n      if (parent[0].tagName === 'PLAYER') {\r\n        playerElement = parent;\r\n        sizingElement = parent.parent()[0];\r\n      }\r\n\r\n      //Listen for board drawsize events\r\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\r\n\r\n        //First set the new dimensions on the canvas elements\r\n        var canvas = element.find('canvas');\r\n        for (i = 0; i < canvas.length; i++) {\r\n          canvas[i].width = width * pixelRatio;\r\n          canvas[i].height = height * pixelRatio;\r\n        }\r\n\r\n        //Set on the element if we're using a player element and if there is a size\r\n        if (playerElement || attrs.forceSize === 'true') {\r\n          element.css({width: width + 'px', height: height + 'px'});\r\n        }\r\n\r\n        //Next set it on the board itself\r\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\r\n      });\r\n\r\n      //Determine initial draw size\r\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n\r\n      //On window resize, determine the draw size again\r\n      angular.element($window).on('resize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On manual resize, determine draw size again\r\n      scope.$on('ngGo.board.determineDrawSize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On board grid resize, determine the draw size again\r\n      scope.$on('ngGo.board.resize', function(event, board) {\r\n\r\n        //Only relevent if this was our own board\r\n        if (board !== scope.Board) {\r\n          return;\r\n        }\r\n\r\n        //If the draw size didn't change, the draw size event won't be triggered.\r\n        //However, that means we should call the resized() method now manually because\r\n        //it won't be called with the setDrawSize() call.\r\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\r\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\r\n          scope.Board.resized();\r\n        }\r\n      });\r\n\r\n      //Static board\r\n      if (attrs.static && attrs.static === 'true') {\r\n\r\n        //Add static class and make the board static\r\n        element.addClass('static');\r\n        scope.Board.makeStatic();\r\n\r\n        //Create single canvas and link to all relevant layer service classes\r\n        context = createLayerCanvas.call(element[0], 'static');\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Dynamic board\r\n      else {\r\n\r\n        //Create individual layer canvasses and link the canvas context to the layer service class\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          context = createLayerCanvas.call(element[0], layer);\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Observe the board size attribute\r\n      attrs.$observe('size', function(size) {\r\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\r\n          size = size.split('x');\r\n          scope.Board.setSize(size[0], size[1]);\r\n        }\r\n        else {\r\n          scope.Board.setSize(size, size);\r\n        }\r\n      });\r\n\r\n      //Observe the coordinates attribute\r\n      attrs.$observe('coordinates', function(attr) {\r\n        scope.Board.toggleCoordinates(attr === 'true');\r\n      });\r\n\r\n      //Observe the cutoff attribute\r\n      attrs.$observe('cutoff', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.setCutoff(attr.split(','));\r\n        }\r\n      });\r\n\r\n      //Observe color multiplier\r\n      attrs.$observe('colorMultiplier', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.swapColors(attr);\r\n        }\r\n      });\r\n\r\n      //Link board to player if present in parent scope\r\n      if (scope.$parent.Player) {\r\n        scope.$parent.Player.setBoard(scope.Board);\r\n      }\r\n\r\n      //Redraw board if we had an existing instance (it might contain data)\r\n      if (existingInstance) {\r\n        scope.Board.redraw();\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\r\n * and is used for placing and removing objects on the board. The class has helpers to figure out\r\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\r\n * responsible for drawing all layers on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Directive',\r\n  'ngGo.Board.Theme.Service',\r\n  'ngGo.Board.Layer.GridLayer.Service',\r\n  'ngGo.Board.Layer.ShadowLayer.Service',\r\n  'ngGo.Board.Layer.StonesLayer.Service',\r\n  'ngGo.Board.Layer.MarkupLayer.Service',\r\n  'ngGo.Board.Layer.ScoreLayer.Service',\r\n  'ngGo.Board.Layer.HoverLayer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.Stone.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Board', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Width and height\r\n    width: 0,\r\n    height: 0,\r\n\r\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\r\n    cutoff: [],\r\n\r\n    //Section of board to display\r\n    section: {top: 0, right: 0, bottom: 0, left: 0},\r\n\r\n    //Show coordinates?\r\n    coordinates: false,\r\n\r\n    //Color multiplier (use -1 to swap colors)\r\n    colorMultiplier: 1\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\r\n\r\n    /**\r\n     * Board constructor\r\n     */\r\n    function Board(config) {\r\n\r\n      //Initialize board\r\n      this.init();\r\n\r\n      //Parse config\r\n      this.parseConfig(config || {});\r\n    }\r\n\r\n    /**\r\n     * Initialize board\r\n     */\r\n    Board.prototype.init = function() {\r\n\r\n      //Remove everything\r\n      this.removeAll();\r\n\r\n      //Set board theme\r\n      this.theme = new BoardTheme();\r\n\r\n      //Initialize board draw dimensions in pixels\r\n      this.cellSize = 0;\r\n      this.drawWidth = 0;\r\n      this.drawHeight = 0;\r\n      this.drawMarginHor = 0;\r\n      this.drawMarginVer = 0;\r\n      this.gridDrawWidth = 0;\r\n      this.gridDrawHeight = 0;\r\n\r\n      //Set layer order\r\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\r\n\r\n      //Initialize layers\r\n      this.layers = {};\r\n      for (var l = 0; l < this.layerOrder.length; l++) {\r\n        var layer = this.layerOrder[l];\r\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\r\n        var LayerClass = $injector.get(layerClass);\r\n        this.layers[layer] = new LayerClass(this);\r\n      }\r\n\r\n      //Static board flag\r\n      this.static = false;\r\n\r\n      //Get margin from theme\r\n      this.margin = this.theme.get('board.margin');\r\n\r\n      //Color multiplier (to allow color swapping)\r\n      this.colorMultiplier = 1;\r\n\r\n      //Turn off coordinates\r\n      this.coordinates = false;\r\n      this.layers.grid.setCoordinates(false);\r\n\r\n      //Initialize grid size\r\n      this.width = 0;\r\n      this.height = 0;\r\n\r\n      //Initialize cutoff\r\n      this.cutoff = {\r\n        top: false,\r\n        left: false,\r\n        right: false,\r\n        bottom: false\r\n      };\r\n\r\n      //Initialize section\r\n      this.section = {\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Link the board to a HTML element\r\n     */\r\n    Board.prototype.linkElement = function(element) {\r\n      this.element = element;\r\n    };\r\n\r\n    /**\r\n     * Make this board static (one canvas layer, only grid, stones and markup)\r\n     */\r\n    Board.prototype.makeStatic = function() {\r\n      this.static = true;\r\n      this.layerOrder = ['grid', 'stones', 'markup'];\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Configuration\r\n     ***/\r\n\r\n    /**\r\n     * Parse config instructions\r\n     */\r\n    Board.prototype.parseConfig = function(config) {\r\n\r\n      //Validate\r\n      if (typeof config !== 'object') {\r\n        return;\r\n      }\r\n\r\n      //Extend from default config\r\n      config = angular.extend({}, defaultConfig, config);\r\n\r\n      //Process settigns\r\n      this.toggleCoordinates(config.coordinates);\r\n      this.swapColors(config.colorMultiplier);\r\n      this.setCutoff(config.cutoff);\r\n      this.setSection(config.section);\r\n      this.setSize(config.width, config.height);\r\n    };\r\n\r\n    /**\r\n     * Set margin\r\n     */\r\n    Board.prototype.setMargin = function(margin) {\r\n\r\n      //Reset when not defined\r\n      if (typeof margin === 'undefined') {\r\n        margin = this.theme.get('board.margin');\r\n      }\r\n\r\n      //Set margin if changed\r\n      if (this.margin !== margin) {\r\n        this.margin = margin;\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set grid cut-off\r\n     */\r\n    Board.prototype.setCutoff = function(cutoff) {\r\n\r\n      //Nothing given? Reset cutoff\r\n      if (!cutoff || !angular.isArray(cutoff)) {\r\n        cutoff = [];\r\n      }\r\n\r\n      //Init\r\n      var changes = false;\r\n\r\n      //Check if there's a change\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff.hasOwnProperty(side)) {\r\n          if (cutoff.indexOf(side) !== -1) {\r\n            if (!this.cutoff[side]) {\r\n              this.cutoff[side] = true;\r\n              changes = true;\r\n            }\r\n          }\r\n          else {\r\n            if (this.cutoff[side]) {\r\n              this.cutoff[side] = false;\r\n              changes = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Trigger resized if there were changes\r\n      if (changes) {\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set section of the board to be displayed\r\n     */\r\n    Board.prototype.setSection = function(section) {\r\n\r\n      //Nothing given?\r\n      if (!section || typeof section !== 'object') {\r\n        return this;\r\n      }\r\n\r\n      //Expand on default\r\n      section = angular.extend({\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      }, section);\r\n\r\n      //No changes?\r\n      if (\r\n        this.section.top === section.top && this.section.bottom === section.bottom &&\r\n        this.section.left === section.left && this.section.right === section.right\r\n      ) {\r\n        return this;\r\n      }\r\n\r\n      //Set section and call resized handler\r\n      this.section = section;\r\n      this.resized();\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set board size. This will clear the board objects.\r\n     */\r\n    Board.prototype.setSize = function(width, height) {\r\n\r\n      //Check what's given\r\n      width = parseInt(width || height || 0);\r\n      height = parseInt(height || width || 0);\r\n\r\n      //Invalid?\r\n      if (isNaN(width) || isNaN(height)) {\r\n        return;\r\n      }\r\n\r\n      //Changing?\r\n      if (width !== this.width || height !== this.height) {\r\n\r\n        //Remember size\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        //Set size in layers\r\n        for (var layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].setSize(width, height);\r\n          }\r\n        }\r\n\r\n        //Broadcast event (no call to resized, as that is handled in the directive)\r\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set new draw size\r\n     */\r\n    Board.prototype.setDrawSize = function(width, height) {\r\n      if (width !== this.drawWidth || height !== this.drawHeight) {\r\n        this.drawWidth = width;\r\n        this.drawHeight = height;\r\n        this.resized();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Toggle the coordinates\r\n     */\r\n    Board.prototype.toggleCoordinates = function(show) {\r\n\r\n      //Set or toggle\r\n      if (typeof show !== 'undefined') {\r\n        this.coordinates = show;\r\n      }\r\n      else {\r\n        this.coordinates = !this.coordinates;\r\n      }\r\n\r\n      //Set in grid layer\r\n      this.layers.grid.setCoordinates(this.coordinates);\r\n\r\n      //Set the proper board margin\r\n      if (this.coordinates) {\r\n        this.setMargin(this.theme.get('coordinates.margin'));\r\n      }\r\n      else {\r\n        this.setMargin(this.theme.get('board.margin'));\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Swap colors on the board\r\n     */\r\n    Board.prototype.swapColors = function(multiplier) {\r\n\r\n      //Multiplier not given? Set to inverse of current value\r\n      if (typeof multiplier === 'undefined') {\r\n        multiplier = -this.colorMultiplier;\r\n      }\r\n      else {\r\n        multiplier = parseInt(multiplier);\r\n        if (isNaN(multiplier)) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //No change?\r\n      if (multiplier === this.colorMultiplier) {\r\n        return;\r\n      }\r\n\r\n      //Set new value\r\n      this.colorMultiplier = multiplier;\r\n\r\n      //For static board, redraw the whole thing\r\n      if (this.static) {\r\n        this.redraw();\r\n      }\r\n\r\n      //For a dynamic board, only these layers\r\n      else {\r\n        this.redraw('stones');\r\n        this.redraw('markup');\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Theme handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the current theme object\r\n     */\r\n    Board.prototype.getTheme = function() {\r\n      return this.theme;\r\n    };\r\n\r\n    /**\r\n     * Set the theme object\r\n     */\r\n    Board.prototype.setTheme = function(theme) {\r\n      this.theme = theme;\r\n      return this;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Object handling\r\n     ***/\r\n\r\n    /**\r\n     * Add an object to a board layer\r\n     */\r\n    Board.prototype.add = function(layer, x, y, value) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].add(x, y, value);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove an object from a board layer\r\n     */\r\n    Board.prototype.remove = function(layer, x, y) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].remove(x, y);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get something from a board layer\r\n     */\r\n    Board.prototype.get = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].get(x, y));\r\n    };\r\n\r\n    /**\r\n     * Check if we have something at given coordinates for a given layer\r\n     */\r\n    Board.prototype.has = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].has(x, y));\r\n    };\r\n\r\n    /**\r\n     * Set all objects (grid) for a given layer\r\n     */\r\n    Board.prototype.setAll = function(layer, grid) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].setAll(grid);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove all objects from the board, optionally for a given layer\r\n     */\r\n    Board.prototype.removeAll = function(layer) {\r\n      if (layer) {\r\n        if (typeof this.layers[layer] !== 'undefined') {\r\n          this.layers[layer].removeAll();\r\n        }\r\n      }\r\n      else {\r\n        for (layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].removeAll();\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Position handling\r\n     ***/\r\n\r\n    /**\r\n     * Update the board with a new position\r\n     */\r\n    Board.prototype.updatePosition = function(position, pathChanged) {\r\n\r\n      //If we have no grid size yet, use what's in the position\r\n      if (!this.width || !this.height) {\r\n        this.setSize(position.width, position.height);\r\n      }\r\n\r\n      //Remove markup if path changed\r\n      if (pathChanged) {\r\n        this.removeAll('markup');\r\n      }\r\n\r\n      //Set new stones and markup grids\r\n      this.setAll('stones', position.stones);\r\n      this.setAll('markup', position.markup);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state (list of objects per layer)\r\n     */\r\n    Board.prototype.getState = function(layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          return this.layers[layer].getAll();\r\n        }\r\n        return null;\r\n      }\r\n\r\n      //All layers\r\n      var state = {};\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          var grid = this.layers[layer].getAll();\r\n          if (grid && !grid.isEmpty()) {\r\n            state[layer] = grid;\r\n          }\r\n        }\r\n      }\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the board state from given state object\r\n     */\r\n    Board.prototype.restoreState = function(state, layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          this.layers[layer].setAll(state);\r\n        }\r\n        return;\r\n      }\r\n\r\n      //All layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].removeAll();\r\n          if (state[layer]) {\r\n            this.layers[layer].setAll(state[layer]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing control\r\n     ***/\r\n\r\n    /**\r\n     * Clear the whole board\r\n     */\r\n    Board.prototype.clear = function(layer) {\r\n\r\n      //Just clearing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Clear the layer\r\n        this.layers[layer].clear();\r\n        return;\r\n      }\r\n\r\n      //Static? One clear is enough\r\n      if (this.static) {\r\n        this.layers.stones.clear();\r\n        return;\r\n      }\r\n\r\n      //Clear all layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].clear();\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Redraw everything or just a single layer\r\n     */\r\n    Board.prototype.redraw = function(layer) {\r\n\r\n      //The board can only be redrawn when there is a grid size and a draw size\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Just redrawing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Redraw the layer\r\n        this.layers[layer].redraw();\r\n        return;\r\n      }\r\n\r\n      //Clear the board first\r\n      this.clear();\r\n\r\n      //Now draw all layers again in the correct order\r\n      for (var i = 0; i < this.layerOrder.length; i++) {\r\n        layer = this.layerOrder[i];\r\n        this.layers[layer].draw();\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing helpers\r\n     ***/\r\n\r\n    /**\r\n     * Called after a board size change, draw size change, section change or margin change\r\n     */\r\n    Board.prototype.resized = function() {\r\n\r\n      //Determine the new grid\r\n      this.grid = {\r\n        xLeft: 0 + this.section.left,\r\n        xRight: this.width - 1 - this.section.right,\r\n        yTop: 0 + this.section.top,\r\n        yBot: this.height - 1 - this.section.bottom\r\n      };\r\n\r\n      //Only redraw when there is sensible data\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Determine number of cells horizontall and vertically\r\n      //The margin is a factor of the cell size, so let's add it to the number of cells\r\n      var noCellsHor = this.width + this.margin;\r\n      var noCellsVer = this.height + this.margin;\r\n\r\n      //Are we cutting off parts of the grid? Add half a cell of draw size\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff[side]) {\r\n          if (side === 'top' || side === 'bottom') {\r\n            noCellsVer += 0.5;\r\n          }\r\n          else {\r\n            noCellsHor += 0.5;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Determine cell size now\r\n      this.cellSize = Math.floor(Math.min(\r\n        this.drawWidth / noCellsHor,\r\n        this.drawHeight / noCellsVer\r\n      ));\r\n\r\n      //Determine actual grid draw size (taking off the margin again)\r\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\r\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\r\n\r\n      //Determine draw margins\r\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\r\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\r\n\r\n      //Redraw\r\n      this.redraw();\r\n    };\r\n\r\n    /**\r\n     * Get the current cell size\r\n     */\r\n    Board.prototype.getCellSize = function() {\r\n      return this.cellSize;\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsX = function(gridX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsY = function(gridY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridX = function(absX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridY = function(absY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Check if given grid coordinates are on board\r\n     */\r\n    Board.prototype.isOnBoard = function(gridX, gridY) {\r\n      return (\r\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\r\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\r\n      );\r\n    };\r\n\r\n    //Return object\r\n    return Board;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\r\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\r\n * a small rectangular area on the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('DefaultClearHandler', function() {\r\n\r\n  /**\r\n   * Clear handler definition\r\n   *\r\n   * All external handlers are called from the context of the layer that contains the object.\r\n   * First parameter is the canvas2d context, second parameter is the object itself.\r\n   */\r\n  return function(context, obj) {\r\n\r\n    //No context?\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(obj.x);\r\n    var y = this.board.getAbsY(obj.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Clear rectangle the size of the stone radius\r\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\r\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\r\n * stone color values for the game position class. It has built in validation of coordinates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Grid.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.GridChanges.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\r\n\r\n  /**\r\n   * Helper to convert a value at given coordinates to an object\r\n   */\r\n  function toObject(x, y, valueKey) {\r\n\r\n    //Create coordinates object\r\n    var obj = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Already an object?\r\n    if (typeof this.grid[x][y] === 'object') {\r\n      return angular.extend(obj, this.grid[x][y]);\r\n    }\r\n\r\n    //Not an object, set value with given value key and return\r\n    obj[valueKey] = this.grid[x][y];\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardGrid(width, height, emptyValue) {\r\n\r\n    //Initialize size and grid array\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.grid = [];\r\n    this.emptyValue = null;\r\n\r\n    //Set empty value if given\r\n    if (typeof emptyValue !== 'undefined') {\r\n      this.emptyValue = emptyValue;\r\n    }\r\n\r\n    //Size given? Set it\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a value\r\n   */\r\n  BoardGrid.prototype.set = function(x, y, value) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unset a value\r\n   */\r\n  BoardGrid.prototype.unset = function(x, y) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = this.emptyValue;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if we have a non null value on the coordinates\r\n   */\r\n  BoardGrid.prototype.has = function(x, y) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\r\n  };\r\n\r\n  /**\r\n   * Check if we have a specific value on the coordinates\r\n   */\r\n  BoardGrid.prototype.is = function(x, y, value) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\r\n  };\r\n\r\n  /**\r\n   * Get a value, or an object with coordinates and the value in the given value key\r\n   */\r\n  BoardGrid.prototype.get = function(x, y, valueKey) {\r\n\r\n    //Validate\r\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\r\n      return this.emptyValue;\r\n    }\r\n\r\n    //Return as is?\r\n    if (!valueKey) {\r\n      return this.grid[x][y];\r\n    }\r\n\r\n    //Return as object\r\n    return toObject.call(this, x, y, valueKey);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Mass operations\r\n   ***/\r\n\r\n  /**\r\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\r\n   * and the value in the given value key will be returned.\r\n   */\r\n  BoardGrid.prototype.all = function(valueKey) {\r\n\r\n    //Just get the grid?\r\n    if (!valueKey) {\r\n      return this.grid;\r\n    }\r\n\r\n    //Initialize objects list\r\n    var objects = [];\r\n\r\n    //Loop coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          objects.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return objects list\r\n    return objects;\r\n  };\r\n\r\n  /**\r\n   * Check if there is anything\r\n   */\r\n  BoardGrid.prototype.isEmpty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Populate the whole grid with a given value\r\n   */\r\n  BoardGrid.prototype.populate = function(value) {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = value;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Empty the grid\r\n   */\r\n  BoardGrid.prototype.empty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clone ourselves\r\n   */\r\n  BoardGrid.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newGrid = new BoardGrid();\r\n\r\n    //Manually set vars for maximum efficiency\r\n    newGrid.grid = angular.copy(this.grid);\r\n    newGrid.emptyValue = this.emptyValue;\r\n    newGrid.width = this.width;\r\n    newGrid.height = this.height;\r\n\r\n    //Return\r\n    return newGrid;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Comparison\r\n   ***/\r\n\r\n  /**\r\n   * Checks if a given grid is the same as the current grid\r\n   */\r\n  BoardGrid.prototype.isSameAs = function(grid) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== grid.width || this.height !== grid.height) {\r\n      return false;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== grid[x][y]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    //No differences found\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Compares this position with another position and return change object\r\n   */\r\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\r\n\r\n    //Initialize board grid changes object\r\n    var changes = new BoardGridChanges();\r\n\r\n    //Must have the same size\r\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\r\n      console.warn('Trying to compare grids of a different size');\r\n      return changes;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n\r\n        //Something to add?\r\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\r\n        }\r\n\r\n        //Something to remove?\r\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.remove.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return changes grid\r\n    return changes;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to validate coordinates (first param can be an object)\r\n   */\r\n  BoardGrid.prototype.isOnGrid = function(x, y) {\r\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\r\n  };\r\n\r\n  /**\r\n   * Helper to set the empty value\r\n   */\r\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\r\n    this.emptyValue = emptyValue;\r\n  };\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  BoardGrid.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Create grid array\r\n    this.grid = [];\r\n    for (var x = 0; x < this.width; x++) {\r\n      this.grid[x] = [];\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the grid size object\r\n   */\r\n  BoardGrid.prototype.getSize = function() {\r\n    return {width: this.width, height: this.height};\r\n  };\r\n\r\n  //Return\r\n  return BoardGrid;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\r\n * grids. It simply keeps track of what was added and what was removed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.GridChanges.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGridChanges', function() {\r\n\r\n  /**\r\n   * Helper to subtract sets\r\n   */\r\n  function setSubtract(a, b) {\r\n    var n = [];\r\n    var q;\r\n    for (var i = 0; i < a.length; i++) {\r\n      q = true;\r\n      for (var j in b) {\r\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\r\n          q = false;\r\n          break;\r\n        }\r\n      }\r\n      if (q) {\r\n        n.push(a[i]);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /**\r\n   * Grid changes constructor\r\n   */\r\n  return function() {\r\n\r\n    /**\r\n     * Containers\r\n     */\r\n    this.add = [];\r\n    this.remove = [];\r\n\r\n    /**\r\n     * Concatenation helper\r\n     */\r\n    this.concat = function(newChanges) {\r\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\r\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\r\n    };\r\n\r\n    /**\r\n     * Check if there are changes\r\n     */\r\n    this.has = function() {\r\n      return !!(this.add.length || this.remove.length);\r\n    };\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\r\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\r\n * for drawing itself as well as its objects onto the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardLayer(board, context) {\r\n\r\n    //Remember board reference and 2d canvas context\r\n    this.board = board;\r\n    this.context = context;\r\n\r\n    //Initialize grid for board objects\r\n    this.grid = new BoardGrid();\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Generic grid and object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set grid size\r\n   */\r\n  BoardLayer.prototype.setSize = function(width, height) {\r\n\r\n    //Note: since this method is usually only called upon a global board resize,\r\n    //which also triggers the redraw method for layers, the layer is not cleared\r\n    //here, as it will happen anyway during the redraw cycle.\r\n\r\n    //Set it in the grid (removing all objects in the process)\r\n    this.grid.setSize(width, height);\r\n  };\r\n\r\n  /**\r\n   * Get all items\r\n   */\r\n  BoardLayer.prototype.getAll = function() {\r\n    return this.grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Set all items at once\r\n   */\r\n  BoardLayer.prototype.setAll = function(grid) {\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  BoardLayer.prototype.removeAll = function() {\r\n    this.clear();\r\n    this.grid.empty();\r\n  };\r\n\r\n  /**\r\n   * Add a single item\r\n   */\r\n  BoardLayer.prototype.add = function(x, y, value) {\r\n    this.clearCell(x, y);\r\n    this.grid.set(x, y, value);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Remove a single item\r\n   */\r\n  BoardLayer.prototype.remove = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.grid.unset(x, y);\r\n  };\r\n\r\n  /**\r\n   * Get an item\r\n   */\r\n  BoardLayer.prototype.get = function(x, y) {\r\n    return this.grid.get(x, y);\r\n  };\r\n\r\n  /**\r\n   * Check if there is an item\r\n   */\r\n  BoardLayer.prototype.has = function(x, y) {\r\n    return this.grid.has(x, y);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Generic drawing methods\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  BoardLayer.prototype.draw = function() {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\r\n   */\r\n  BoardLayer.prototype.clear = function() {\r\n    if (this.context) {\r\n      this.context.clearRect(\r\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  BoardLayer.prototype.redraw = function() {\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\r\n    //Clearing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Redraw cell\r\n   */\r\n  BoardLayer.prototype.redrawCell = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Set the canvas2d context\r\n   */\r\n  BoardLayer.prototype.setContext = function(context) {\r\n    this.context = context;\r\n  };\r\n\r\n  /**\r\n   * Get the canvas2d context\r\n   */\r\n  BoardLayer.prototype.getContext = function() {\r\n    return this.context;\r\n  };\r\n\r\n  //Return\r\n  return BoardLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardObject :: Base class for drawing board objects\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.DefaultClearHandler.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var BoardObject = {\r\n\r\n    /**\r\n     * Draw method\r\n     */\r\n    draw: function(/*obj*/) {\r\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear method\r\n     */\r\n    clear: function(obj) {\r\n      DefaultClearHandler.call(this, this.context, obj);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return BoardObject;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.ShellPattern.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShellPattern', function() {\r\n\r\n  /**\r\n   * Helper to draw a shell line\r\n   */\r\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\r\n\r\n    //Initialize\r\n    ctx.shadowBlur = 2;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = (radius / 30) * this.thickness;\r\n    ctx.beginPath();\r\n\r\n    //Lower radius\r\n    radius -= Math.max(1, ctx.lineWidth);\r\n\r\n    //Determine coordinates\r\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\r\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\r\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\r\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\r\n\r\n    //Math magic\r\n    var m, angle;\r\n    if (x2 > x1) {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m);\r\n    }\r\n    else if (x2 === x1) {\r\n      angle = Math.PI / 2;\r\n    }\r\n    else {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m) - Math.PI;\r\n    }\r\n\r\n    //Curvature factor\r\n    var c = this.factor * radius;\r\n    var dx = Math.sin(angle) * c;\r\n    var dy = Math.cos(angle) * c;\r\n\r\n    //Curvature coordinates\r\n    var bx1 = x1 + dx;\r\n    var by1 = y1 - dy;\r\n    var bx2 = x2 + dx;\r\n    var by2 = y2 - dy;\r\n\r\n    //Draw shell stroke\r\n    ctx.moveTo(x1, y1);\r\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Shell pattern drawer\r\n   */\r\n  return function(ctx, x, y, radius, angle, strokeStyle) {\r\n\r\n    //Initialize start and end angle\r\n    var startAngle = angle;\r\n    var endAngle = angle;\r\n\r\n    //Loop lines\r\n    for (var i = 0; i < this.lines.length; i++) {\r\n      startAngle += this.lines[i];\r\n      endAngle -= this.lines[i];\r\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\r\n    }\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\r\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\r\n * use static values or dynamic values depending on other properties, like the grid cell size.\r\n * Using the provider, the theme can be configured globally at application launch.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Theme.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\r\n\r\n  /**\r\n   * Default theme\r\n   */\r\n  var defaultTheme = {\r\n\r\n    //Board\r\n    board: {\r\n\r\n      //Board margin factor\r\n      margin: 0.25\r\n    },\r\n\r\n    //Stones\r\n    stone: {\r\n\r\n      //Stone style can be shell, glass, mono, or specify a custom handler service\r\n      style: 'shell',\r\n      shadow: true,\r\n      radius: function(cellSize) {\r\n        return Math.floor(cellSize / 2);\r\n      },\r\n\r\n      //Shell stones\r\n      shell: {\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#111';\r\n          }\r\n          return '#BFBFBA';\r\n        },\r\n        stroke: 'rgba(128,128,128,0.15)',\r\n        types: [\r\n          {\r\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\r\n            factor: 0.15,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\r\n            factor: 0.1,\r\n            thickness: 1.5\r\n          },\r\n          {\r\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\r\n            factor: 0.05,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\r\n            factor: 0.1,\r\n            thickness: 2\r\n          }\r\n        ]\r\n      },\r\n\r\n      //Mono stones\r\n      mono: {\r\n        lineWidth: 1,\r\n        lineColor: function() {\r\n          return '#000';\r\n        },\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#000';\r\n          }\r\n          return '#fff';\r\n        }\r\n      },\r\n\r\n      //Mini stones\r\n      mini: {\r\n        scale: 0.5,\r\n        alpha: 1\r\n      },\r\n\r\n      //Faded stones\r\n      faded: {\r\n        scale: 1,\r\n        alpha: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return 0.3;\r\n          }\r\n          return 0.4;\r\n        }\r\n      }\r\n    },\r\n\r\n    //Shadows\r\n    shadow: {\r\n\r\n      //Shadow gradient colors\r\n      color: 'rgba(40,30,20,0.5)',\r\n\r\n      //Shadow size\r\n      size: function(cellSize) {\r\n        return Math.floor(cellSize / 20);\r\n      },\r\n\r\n      //Shadow blur size\r\n      blur: function(cellSize) {\r\n        return cellSize / 20;\r\n      },\r\n\r\n      //Shadow offset\r\n      offsetX: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      },\r\n      offsetY: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      }\r\n    },\r\n\r\n    //Markup\r\n    markup: {\r\n\r\n      //Standard color\r\n      color: function(stoneColor) {\r\n        if (stoneColor === StoneColor.B) {\r\n          return 'rgba(255,255,255,0.9)';\r\n        }\r\n        return 'rgba(0,0,0,0.9)';\r\n      },\r\n\r\n      //Line width\r\n      lineWidth: function(cellSize) {\r\n        return Math.max(1, Math.floor(cellSize / 16));\r\n      },\r\n\r\n      //Triangle\r\n      triangle: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Square\r\n      square: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Cricle\r\n      circle: {\r\n        scale: 0.55\r\n      },\r\n\r\n      //Mark\r\n      mark: {\r\n        lineCap: 'square',\r\n        scale: 0.75\r\n      },\r\n\r\n      //Last\r\n      last: {\r\n        scale: 0.7\r\n      },\r\n\r\n      //Smiley\r\n      smiley: {\r\n        lineCap: 'round',\r\n        scale: 0.85\r\n      },\r\n\r\n      //Label\r\n      label: {\r\n        font: 'Arial'\r\n      },\r\n\r\n      //Variation markup\r\n      variation: {\r\n        type: MarkupTypes.LABEL,\r\n        text: function(i) {\r\n          return String.fromCharCode(65 + i);\r\n        },\r\n        color: 'rgba(86,114,30,0.9)'\r\n      },\r\n\r\n      //Solution paths markup\r\n      solution: {\r\n        valid: {\r\n          type: MarkupTypes.SELECT,\r\n          text: null,\r\n          color: 'rgba(86,114,30,1)',\r\n          scale: 0.5\r\n        },\r\n        invalid: {\r\n          type: MarkupTypes.MARK,\r\n          text: null,\r\n          color: 'rgba(237,9,15,1)',\r\n          scale: 0.3\r\n        }\r\n      }\r\n    },\r\n\r\n    //Grid\r\n    grid: {\r\n\r\n      //Line properties\r\n      lineColor: 'rgba(60,40,15,1)',\r\n      lineWidth: function(cellSize) {\r\n        if (cellSize > 60) {\r\n          return 2;\r\n        }\r\n        else if (cellSize > 50) {\r\n          return 1.5;\r\n        }\r\n        return 1;\r\n      },\r\n      lineCap: 'square',\r\n\r\n      //Star points\r\n      star: {\r\n\r\n        //Color and radius\r\n        color: 'rgba(60,40,15,1)',\r\n        radius: function(cellSize) {\r\n          if (cellSize > 50) {\r\n            return Math.floor((cellSize / 16) + 1);\r\n          }\r\n          else if (cellSize > 30) {\r\n            return 3;\r\n          }\r\n          else if (cellSize > 15) {\r\n            return 2;\r\n          }\r\n          else if (cellSize > 5) {\r\n            return 1.5;\r\n          }\r\n          return 1;\r\n        },\r\n\r\n        //Locations\r\n        points: function(width, height) {\r\n\r\n          //19x19\r\n          if (width === height && width === 19) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\r\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\r\n            ];\r\n          }\r\n\r\n          //13x13\r\n          if (width === height && width === 13) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }\r\n            ];\r\n          }\r\n\r\n          //9x9\r\n          if (width === height && width === 9) {\r\n            return [\r\n              { x: 4, y: 4}, { x: 2, y: 2},\r\n              { x: 2, y: 6}, { x: 6, y: 2},\r\n              { x: 6, y: 6}\r\n            ];\r\n          }\r\n\r\n          //No star points\r\n          return [];\r\n        }\r\n      }\r\n    },\r\n\r\n    //Coordinates\r\n    coordinates: {\r\n\r\n      //Color\r\n      color: 'rgba(101,69,37,0.5)',\r\n\r\n      //Board margin factor when showing coordinates\r\n      margin: 1.25,\r\n\r\n      //Vertical coordinates style\r\n      vertical: {\r\n        font: 'Arial',\r\n        style: 'numbers',\r\n        inverse: true,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      },\r\n\r\n      //Horizontal coordinates style\r\n      horizontal: {\r\n        font: 'Arial',\r\n        style: 'letters',\r\n        inverse: false,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Set global default theme\r\n   */\r\n  this.setTheme = function(theme) {\r\n    if (theme) {\r\n      defaultTheme = angular.merge(defaultTheme, theme);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = function() {\r\n\r\n    /**\r\n     * Board theme constructor\r\n     */\r\n    function BoardTheme(theme) {\r\n\r\n      //Remember the given instance theme settings and (re)set the theme\r\n      this.instanceTheme = theme;\r\n      this.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the theme to defaults\r\n     */\r\n    BoardTheme.prototype.reset = function() {\r\n\r\n      //Use default theme as a base\r\n      this.theme = angular.copy(defaultTheme);\r\n\r\n      //Add any instance theme properties\r\n      if (this.instanceTheme) {\r\n        angular.merge(this.theme, this.instanceTheme);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get a theme property\r\n     */\r\n    BoardTheme.prototype.get = function(property) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Can't find the property?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          console.warn('Could not find theme property', property);\r\n          return null;\r\n        }\r\n\r\n        //Advance further in the object\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Found what we're looking for\r\n      if (typeof prop !== 'function') {\r\n        return prop;\r\n      }\r\n\r\n      //Prepare arguments\r\n      var args = [];\r\n      if (arguments.length > 1) {\r\n        for (var a = 1; a < arguments.length; a++) {\r\n          args.push(arguments[a]);\r\n        }\r\n      }\r\n\r\n      //Call function\r\n      return prop.apply(this, args);\r\n    };\r\n\r\n    /**\r\n     * Change a theme property dynamically (accepts handler function as value)\r\n     */\r\n    BoardTheme.prototype.set = function(property, value) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Time to set?\r\n        if ((i + 1) === path.length) {\r\n          prop[path[i]] = value;\r\n          break;\r\n        }\r\n\r\n        //Not set?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          prop[path[i]] = {};\r\n        }\r\n\r\n        //Move on\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\r\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\r\n     */\r\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\r\n\r\n      //If no linewidth specified, use the grid line width as a reference\r\n      //to make sure stuff is aligned to the grid\r\n      if (typeof lineWidth === 'undefined') {\r\n        lineWidth = this.get('grid.lineWidth');\r\n      }\r\n\r\n      //Return a translation for uneven widths\r\n      return (lineWidth % 2) * 0.5;\r\n    };\r\n\r\n    //Return\r\n    return BoardTheme;\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Game :: This class represents a game record or a game that is being played/edited. The class\r\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\r\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\r\n * The class also keeps a stack of all board positions in memory and can validate moves to make\r\n * sure they are not repeating or suicide.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Path.Service',\r\n  'ngGo.Game.Node.Service',\r\n  'ngGo.Game.Position.Service',\r\n  'ngGo.Kifu.Blank.Service',\r\n  'ngGo.Kifu.Parser.Service',\r\n  'ngGo.Errors.InvalidDataError.Service',\r\n  'ngGo.Errors.InvalidPositionError.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('Game', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default size of board\r\n    defaultSize: 0,\r\n\r\n    //Default komi and handicap\r\n    defaultKomi: 0,\r\n    defaultHandicap: 0,\r\n\r\n    //Remember last selected variation when traversing nodes\r\n    rememberPath: true,\r\n\r\n    //Check for repeating positions? (KO / ALL / empty)\r\n    checkRepeat: 'KO',\r\n\r\n    //Allow suicide?\r\n    allowSuicide: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\r\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\r\n    KifuBlank, InvalidDataError, InvalidPositionError\r\n  ) {\r\n\r\n    /*****************************************************************************\r\n     * General helpers\r\n     ***/\r\n\r\n    /**\r\n     * Validate the info we have to make sure the properties exist\r\n     */\r\n    function validateInfo() {\r\n\r\n      //Set board info if not set\r\n      if (!this.info.board) {\r\n        this.info.board = {};\r\n      }\r\n\r\n      //Set game info if not set\r\n      if (!this.info.game) {\r\n        this.info.game = {};\r\n      }\r\n\r\n      //Set defaults\r\n      if (typeof this.info.board.width === 'undefined') {\r\n        this.info.board.width = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.board.height === 'undefined') {\r\n        this.info.board.height = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.game.komi === 'undefined') {\r\n        this.info.game.komi = this.config.defaultKomi;\r\n      }\r\n      if (typeof this.info.game.handicap === 'undefined') {\r\n        this.info.game.handicap = this.config.defaultHandicap;\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Node navigation helpers\r\n     ***/\r\n\r\n    /**\r\n     * Navigate to the next node\r\n     */\r\n    function nextNode(i) {\r\n\r\n      //Check if we have children\r\n      if (this.node.children.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      //Remembered the path we took earlier?\r\n      if (i === undefined) {\r\n        i = this.node.rememberedPath;\r\n      }\r\n\r\n      //Determine which child node to process\r\n      i = i || 0;\r\n      if (i === -1) {\r\n        i = 0;\r\n      }\r\n\r\n      //Validate\r\n      if (i >= this.node.children.length || !this.node.children[i]) {\r\n        return false;\r\n      }\r\n\r\n      //Advance path\r\n      this.path.advance(i);\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.children[i];\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the previous node\r\n     */\r\n    function previousNode() {\r\n\r\n      //No parent node?\r\n      if (!this.node.parent) {\r\n        return false;\r\n      }\r\n\r\n      //Retreat path\r\n      this.path.retreat();\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.parent;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the first node\r\n     */\r\n    function firstNode() {\r\n\r\n      //Reset path\r\n      this.path.reset();\r\n\r\n      //Set node pointer back to root\r\n      this.node = this.root;\r\n\r\n      //Set the initial turn depending on handicap\r\n      //Can be overwritten by game record instructions\r\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Position history helpers\r\n     ***/\r\n\r\n    /**\r\n     * Clear the position history and initialize with a blank position\r\n     */\r\n    function initializeHistory() {\r\n\r\n      //Already at beginning?\r\n      if (this.history.length === 1) {\r\n        return;\r\n      }\r\n\r\n      //Clear positions stack and create new blank position\r\n      this.history = [];\r\n      this.history.push(new GamePosition());\r\n\r\n      //Set board size if we have the info\r\n      if (this.info.board) {\r\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add position to stack. If position isn't specified current position is\r\n     * cloned and stacked. Pointer of actual position is moved to the new position.\r\n     */\r\n    function pushPosition(newPosition) {\r\n\r\n      //Position not given?\r\n      if (!newPosition) {\r\n        newPosition = this.position.clone();\r\n      }\r\n\r\n      //Push\r\n      this.history.push(newPosition);\r\n      return newPosition;\r\n    }\r\n\r\n    /**\r\n     * Remove current position from stack\r\n     */\r\n    function popPosition() {\r\n\r\n      //Nothing left?\r\n      if (this.history.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      //Get old position\r\n      return this.history.pop();\r\n    }\r\n\r\n    /**\r\n     * Replace the current position in the stack\r\n     */\r\n    function replacePosition(newPosition) {\r\n      if (newPosition) {\r\n        this.history.pop();\r\n        this.history.push(newPosition);\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Execution helpers\r\n     ***/\r\n\r\n    /**\r\n     * Execute the current node\r\n     */\r\n    function executeNode() {\r\n\r\n      //Remember last selected node if we have a parent\r\n      if (this.node.parent) {\r\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\r\n      }\r\n\r\n      //Initialize new position\r\n      var i;\r\n      var newPosition = this.position.clone();\r\n\r\n      //Handle moves\r\n      if (this.node.isMove()) {\r\n        if (this.node.move.pass) {\r\n          newPosition.setTurn(-this.node.move.color);\r\n        }\r\n        else {\r\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\r\n        }\r\n      }\r\n\r\n      //Handle turn instructions\r\n      if (this.node.turn) {\r\n        newPosition.setTurn(this.node.turn);\r\n      }\r\n\r\n      //Handle setup instructions\r\n      if (this.node.setup) {\r\n        for (i in this.node.setup) {\r\n          if (this.node.setup.hasOwnProperty(i)) {\r\n            newPosition.stones.set(\r\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Handle markup\r\n      if (this.node.markup) {\r\n        for (i in this.node.markup) {\r\n          if (this.node.markup.hasOwnProperty(i)) {\r\n            newPosition.markup.set(\r\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Push the new position into the history now\r\n      pushPosition.call(this, newPosition);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Game class\r\n     ***/\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Game(data, config) {\r\n\r\n      //Extend config\r\n      this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n      //Define property getter/setter for position\r\n      Object.defineProperty(this, 'position', {\r\n\r\n        //Getter returns the last position from the stack\r\n        get: function() {\r\n          return this.history[this.history.length - 1];\r\n        },\r\n\r\n        //Setter adds a new position to the stack\r\n        set: function(newPosition) {\r\n          this.history[this.history.length] = newPosition;\r\n        }\r\n      });\r\n\r\n      //Load data\r\n      if (data) {\r\n        this.load(data);\r\n      }\r\n      else {\r\n        this.init();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Initialize\r\n     */\r\n    Game.prototype.init = function() {\r\n\r\n      //Info properties\r\n      this.info = {};\r\n\r\n      //The rood node and pointer to the current node\r\n      this.root = null;\r\n      this.node = null;\r\n\r\n      //Game path\r\n      this.path = new GamePath();\r\n\r\n      //JGF record we loaded from\r\n      this.jgf = null;\r\n\r\n      //Positions history stack\r\n      this.history = [];\r\n    };\r\n\r\n    /**\r\n     * Load game record data\r\n     */\r\n    Game.prototype.load = function(data) {\r\n\r\n      //Initialize\r\n      this.init();\r\n\r\n      //Try to load game record data\r\n      try {\r\n        this.fromData(data);\r\n      }\r\n      catch (errorCode) {\r\n\r\n        //Just initialize our history with a blank position\r\n        initializeHistory.call(this);\r\n\r\n        //Wrap error code in error object\r\n        throw new InvalidDataError(errorCode);\r\n      }\r\n\r\n      //Go to the first move\r\n      this.first();\r\n    };\r\n\r\n    /**\r\n     * Reload game record\r\n     */\r\n    Game.prototype.reload = function() {\r\n      if (this.jgf) {\r\n        this.load(this.jgf);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if we managed to load a valid game record\r\n     */\r\n    Game.prototype.isLoaded = function() {\r\n      return this.root !== null;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game cloning and conversion\r\n     ***/\r\n\r\n    /**\r\n     * Clone this game\r\n     */\r\n    Game.prototype.clone = function() {\r\n\r\n      //Create new kifu object and get properties\r\n      var clone = new Game();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy all properties\r\n      for (var p = 0; p < props.length; p++) {\r\n        clone[p] = angular.copy(this[p]);\r\n      }\r\n\r\n      //Return clone\r\n      return clone;\r\n    };\r\n\r\n    /**\r\n     * Load from an unknown data source\r\n     */\r\n    Game.prototype.fromData = function(data) {\r\n\r\n      //No data, can't do much\r\n      if (!data) {\r\n        throw ngGo.error.NO_DATA;\r\n      }\r\n\r\n      //String given, could be stringified JGF, an SGF or GIB file\r\n      if (typeof data === 'string') {\r\n        var c = data.charAt(0);\r\n        if (c === '(') {\r\n          return this.fromSgf(data);\r\n        }\r\n        else if (c === '{' || c === '[') {\r\n          return this.fromJgf(data);\r\n        }\r\n        else if (c === '\\\\') {\r\n          return this.fromGib(data);\r\n        }\r\n        else {\r\n          throw ngGo.error.UNKNOWN_DATA;\r\n        }\r\n      }\r\n\r\n      //Object given? Probably a JGF object\r\n      else if (typeof data === 'object') {\r\n        this.fromJgf(data);\r\n      }\r\n\r\n      //Something else?\r\n      else {\r\n        throw ngGo.error.UNKNOWN_DATA;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Load from GIB data\r\n     */\r\n    Game.prototype.fromGib = function(gib) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.gib2jgf(gib);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_GIB;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from SGF data\r\n     */\r\n    Game.prototype.fromSgf = function(sgf) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.sgf2jgf(sgf);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_SGF;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from JGF data\r\n     */\r\n    Game.prototype.fromJgf = function(jgf) {\r\n\r\n      //Parse jgf string\r\n      if (typeof jgf === 'string') {\r\n        try {\r\n          jgf = angular.fromJson(jgf);\r\n        }\r\n        catch (error) {\r\n          throw ngGo.error.INVALID_JGF_JSON;\r\n        }\r\n      }\r\n\r\n      //If array given, convert to object with only tree\r\n      if (angular.isArray(jgf)) {\r\n        jgf = {\r\n          tree: jgf\r\n        };\r\n      }\r\n\r\n      //Parse tree string\r\n      if (typeof jgf.tree === 'string') {\r\n        if (jgf.tree.charAt(0) === '[') {\r\n          try {\r\n            jgf.tree = angular.fromJson(jgf.tree);\r\n          }\r\n          catch (error) {\r\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\r\n          }\r\n        }\r\n        else {\r\n          jgf.tree = [];\r\n        }\r\n      }\r\n\r\n      //Copy all properties except moves tree\r\n      for (var i in jgf) {\r\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\r\n          this.info[i] = angular.copy(jgf[i]);\r\n        }\r\n      }\r\n\r\n      //Validate info\r\n      validateInfo.call(this);\r\n\r\n      //Create root node\r\n      this.root = new GameNode();\r\n\r\n      //Tree given? Load all the moves\r\n      if (jgf.tree) {\r\n        this.root.fromJgf(jgf.tree);\r\n      }\r\n\r\n      //Remember JGF\r\n      this.jgf = jgf;\r\n    };\r\n\r\n    /**\r\n     * Convert to SGF\r\n     */\r\n    Game.prototype.toSgf = function() {\r\n      return KifuParser.jgf2sgf(this.toJgf());\r\n    };\r\n\r\n    /**\r\n     * Convert to JGF (optionally stringified)\r\n     */\r\n    Game.prototype.toJgf = function(stringify) {\r\n\r\n      //Initialize JGF and get properties\r\n      var jgf = KifuBlank.jgf();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy properties\r\n      for (var p = 0; p < props.length; p++) {\r\n\r\n        //Skip root\r\n        if (p === 'root') {\r\n          continue;\r\n        }\r\n\r\n        //Already present on JGF object? Extend\r\n        if (jgf[p]) {\r\n          jgf[p] = angular.extend(jgf[p], this[p]);\r\n        }\r\n\r\n        //Otherwise copy\r\n        else {\r\n          jgf[p] = angular.copy(this[p]);\r\n        }\r\n      }\r\n\r\n      //Build tree\r\n      jgf.tree = this.root.toJgf();\r\n\r\n      //Return\r\n      return stringify ? angular.toJson(jgf) : jgf;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Getters\r\n     ***/\r\n\r\n    /**\r\n     * Get current node\r\n     */\r\n    Game.prototype.getNode = function() {\r\n      return this.node;\r\n    };\r\n\r\n    /**\r\n     * Get nodes array for currently remembered path\r\n     */\r\n    Game.prototype.getNodes = function() {\r\n\r\n      //Initialize node to process\r\n      var node = this.root;\r\n      var nodes = [node];\r\n\r\n      //Process children\r\n      while (node) {\r\n        node = node.getChild(node.rememberedPath);\r\n        if (node) {\r\n          nodes.push(node);\r\n        }\r\n      }\r\n\r\n      //Return nodes\r\n      return nodes;\r\n    };\r\n\r\n    /**\r\n     * Get node for a certain move\r\n     */\r\n    Game.prototype.getMoveNode = function(move) {\r\n      var nodes = this.getMoveNodes(move, move);\r\n      return nodes.length ? nodes[0] : null;\r\n    };\r\n\r\n    /**\r\n     * Get move nodes restricted by given move numbers\r\n     */\r\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\r\n\r\n      //Get all nodes for the current path\r\n      var nodes = this.getNodes();\r\n\r\n      //Use sensible defaults if no from/to moves given\r\n      fromMove = fromMove || 1;\r\n      toMove = toMove || nodes.length;\r\n\r\n      //Filter\r\n      return nodes.filter(function(node) {\r\n        if (node.isMove()) {\r\n          var move = node.getMoveNumber();\r\n          return (move >= fromMove && move <= toMove);\r\n        }\r\n        return false;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Get current move number\r\n     */\r\n    Game.prototype.getMove = function() {\r\n      if (this.node) {\r\n        return this.node.getMoveNumber();\r\n      }\r\n      return 0;\r\n    };\r\n\r\n    /**\r\n     * Get the number of moves in the main branch\r\n     */\r\n    Game.prototype.getMoveCount = function() {\r\n      var moveNodes = this.getMoveNodes();\r\n      return moveNodes.length;\r\n    };\r\n\r\n    /**\r\n     * Get the move variation for given coordinates\r\n     */\r\n    Game.prototype.getMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.getMoveVariation(x, y);\r\n      }\r\n      return -1;\r\n    };\r\n\r\n    /**\r\n     * Get the current game position\r\n     */\r\n    Game.prototype.getPosition = function() {\r\n      return this.position;\r\n    };\r\n\r\n    /**\r\n     * Get the game path\r\n     */\r\n    Game.prototype.getPath = function(clone) {\r\n      if (clone) {\r\n        return this.path.clone();\r\n      }\r\n      return this.path;\r\n    };\r\n\r\n    /**\r\n     * Clone the current game path\r\n     */\r\n    Game.prototype.clonePath = function() {\r\n      return this.path.clone();\r\n    };\r\n\r\n    /**\r\n     * Get the game path to a certain named node\r\n     */\r\n    Game.prototype.getPathToNode = function(nodeName) {\r\n      return GamePath.findNode(nodeName, this.root);\r\n    };\r\n\r\n    /**\r\n     * Get the game komi\r\n     */\r\n    Game.prototype.getKomi = function() {\r\n      var komi = this.get('game.komi', 0);\r\n      return parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Set the game komi\r\n     */\r\n    Game.prototype.setKomi = function(komi) {\r\n      if (typeof komi === 'undefined') {\r\n        komi = this.config.defaultKomi;\r\n      }\r\n      this.info.game.komi = parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Get the game name\r\n     */\r\n    Game.prototype.getName = function() {\r\n      return this.get('game.name', '');\r\n    };\r\n\r\n    /**\r\n     * Get the game result\r\n     */\r\n    Game.prototype.getResult = function() {\r\n      return this.get('game.result', '');\r\n    };\r\n\r\n    /**\r\n     * Get the player turn for this position\r\n     */\r\n    Game.prototype.getTurn = function() {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return StoneColor.B;\r\n      }\r\n\r\n      //Get from position\r\n      return this.position.getTurn();\r\n    };\r\n\r\n    /**\r\n     * Set the player turn for the current position\r\n     */\r\n    Game.prototype.setTurn = function(color) {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return;\r\n      }\r\n\r\n      //Set in position\r\n      this.position.setTurn(color);\r\n    };\r\n\r\n    /**\r\n     * Get the total capture count up to the current position\r\n     */\r\n    Game.prototype.getCaptureCount = function() {\r\n\r\n      //Initialize\r\n      var captures = {};\r\n      captures[StoneColor.B] = 0;\r\n      captures[StoneColor.W] = 0;\r\n\r\n      //Loop all positions and increment capture count\r\n      for (var i = 0; i < this.history.length; i++) {\r\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\r\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\r\n      }\r\n\r\n      //Return\r\n      return captures;\r\n    };\r\n\r\n    /**\r\n     * Get an info property\r\n     */\r\n    Game.prototype.get = function(property, defaultValue) {\r\n\r\n      //Must have a property\r\n      if (!property) {\r\n        return;\r\n      }\r\n\r\n      //The item's property in the object is given by dot separated strings\r\n      if (typeof property === 'string') {\r\n        property = property.split('.');\r\n      }\r\n\r\n      //Initialize object we're getting info from\r\n      var obj = this.info;\r\n      var key;\r\n\r\n      //Loop the properties\r\n      for (var p = 0; p < property.length; p++) {\r\n\r\n        //Get actual key\r\n        key = property[p];\r\n\r\n        //Last key reached? Done, get value\r\n        if ((p + 1) === property.length) {\r\n          if (typeof obj[key] === 'undefined') {\r\n            return defaultValue;\r\n          }\r\n          return obj[key];\r\n        }\r\n\r\n        //Must be object container\r\n        if (typeof obj[key] !== 'object') {\r\n          console.warn('Game info property', key, 'is not an object');\r\n          return defaultValue;\r\n        }\r\n\r\n        //Move up in tree\r\n        obj = obj[key];\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Checkers\r\n     ***/\r\n\r\n    /**\r\n     * Check if coordinates are on the board\r\n     */\r\n    Game.prototype.isOnBoard = function(x, y) {\r\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\r\n    };\r\n\r\n    /**\r\n     * Check if given coordinates are one of the next child node coordinates\r\n     */\r\n    Game.prototype.isMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.isMoveVariation(x, y);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Check if a given position is repeating within this game\r\n     */\r\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\r\n\r\n      //Init\r\n      var stop;\r\n\r\n      //Check for ko only? (Last two positions)\r\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\r\n        stop = this.history.length - 2;\r\n      }\r\n\r\n      //Check all history?\r\n      else if (this.checkRepeat === 'ALL') {\r\n        stop = 0;\r\n      }\r\n\r\n      //Not repeating\r\n      else {\r\n        return false;\r\n      }\r\n\r\n      //Loop history of positions to check\r\n      for (var i = this.history.length - 2; i >= stop; i--) {\r\n        if (checkPosition.isSameAs(this.history[i])) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      //Not repeating\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Wrapper for validateMove() returning a boolean and catching any errors\r\n     */\r\n    Game.prototype.isValidMove = function(x, y, color) {\r\n      try {\r\n        this.validateMove(x, y, color);\r\n        return true;\r\n      }\r\n      catch (error) {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if a move is valid. If valid, the new game position object is returned.\r\n     * You can supply a pre-created position to use, or the current position is cloned.\r\n     */\r\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Something already here?\r\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\r\n      }\r\n\r\n      //Set color of move to make\r\n      color = color || this.position.getTurn();\r\n\r\n      //Determine position to use\r\n      newPosition = newPosition || this.position.clone();\r\n\r\n      //Place the stone\r\n      newPosition.stones.set(x, y, color);\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = newPosition.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created?\r\n        if (!newPosition.hasLiberties(x, y)) {\r\n\r\n          //Capture the group if it's allowed\r\n          if (this.allowSuicide) {\r\n            newPosition.captureGroup(x, y);\r\n          }\r\n\r\n          //Invalid move\r\n          else {\r\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Check history for repeating moves\r\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\r\n      }\r\n\r\n      //Set proper turn\r\n      newPosition.setTurn(-color);\r\n\r\n      //Move is valid\r\n      return newPosition;\r\n    };\r\n\r\n    /**\r\n     * Check if a stone (setup) placement is valid.\r\n     */\r\n    Game.prototype.validatePlacement = function(x, y, color, position) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Place the stone\r\n      position.stones.set(x, y, color);\r\n\r\n      //Empty spot? Don't need to check for captures\r\n      if (color === StoneColor.EMPTY) {\r\n        return;\r\n      }\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = position.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created? Capture it\r\n        if (!position.hasLiberties(x, y)) {\r\n          position.captureGroup(x, y);\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Stone and markup handling\r\n     ***/\r\n\r\n    /**\r\n     * Add a stone\r\n     */\r\n    Game.prototype.addStone = function(x, y, color) {\r\n\r\n      //Check if there's anything to do at all\r\n      if (this.position.stones.is(x, y, color)) {\r\n        return;\r\n      }\r\n\r\n      //Create temporary position\r\n      var tempPosition = this.position.clone();\r\n\r\n      //Validate placement on temp position\r\n      this.validatePlacement(x, y, color, tempPosition);\r\n\r\n      //No setup instructions container in this node?\r\n      if (typeof this.node.setup === 'undefined') {\r\n\r\n        //Is this a move node?\r\n        if (this.node.isMove()) {\r\n\r\n          //Clone our position\r\n          pushPosition.call(this);\r\n\r\n          //Create new node\r\n          var node = new GameNode();\r\n\r\n          //Append it to the current node and change the pointer\r\n          var i = node.appendTo(this.node);\r\n          this.node = node;\r\n\r\n          //Advance path to the added node index\r\n          this.path.advance(i);\r\n        }\r\n\r\n        //Create setup container in this node\r\n        this.node.setup = [];\r\n      }\r\n\r\n      //Replace current position\r\n      replacePosition.call(this, tempPosition);\r\n\r\n      //Add setup instructions to node\r\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\r\n    };\r\n\r\n    /**\r\n     * Add markup\r\n     */\r\n    Game.prototype.addMarkup = function(x, y, markup) {\r\n\r\n      //No markup instructions container in this node?\r\n      if (typeof this.node.markup === 'undefined') {\r\n        this.node.markup = [];\r\n      }\r\n\r\n      //Add markup to game position\r\n      this.position.markup.set(x, y, markup);\r\n\r\n      //Add markup instructions to node\r\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\r\n    };\r\n\r\n    /**\r\n     * Remove a stone\r\n     */\r\n    Game.prototype.removeStone = function(x, y) {\r\n\r\n      //Check if the stone is found in setup instructions\r\n      var foundInSetup = false;\r\n\r\n      //Remove from node setup instruction\r\n      if (typeof this.node.setup !== 'undefined') {\r\n        for (var i = 0; i < this.node.setup.length; i++) {\r\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\r\n\r\n            //Remove from node and unset in position\r\n            this.node.setup.splice(i, 1);\r\n            this.position.stones.unset(x, y);\r\n\r\n            //Mark as found\r\n            foundInSetup = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Not found in setup? Add as no stone color\r\n      if (!foundInSetup) {\r\n        this.addStone(x, y, StoneColor.EMPTY);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove markup\r\n     */\r\n    Game.prototype.removeMarkup = function(x, y) {\r\n\r\n      //Remove from node\r\n      if (typeof this.node.markup !== 'undefined') {\r\n        for (var i = 0; i < this.node.markup.length; i++) {\r\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\r\n            this.node.markup.splice(i, 1);\r\n            this.position.markup.unset(x, y);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if there is a stone at the given coordinates for the current position\r\n     */\r\n    Game.prototype.hasStone = function(x, y, color) {\r\n      if (typeof color !== 'undefined') {\r\n        return this.position.stones.is(x, y, color);\r\n      }\r\n      return this.position.stones.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Check if there is markup at the given coordinate for the current position\r\n     */\r\n    Game.prototype.hasMarkup = function(x, y, type) {\r\n      if (typeof type !== 'undefined') {\r\n        return this.position.markup.is(x, y, type);\r\n      }\r\n      return this.position.markup.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get stone on coordinates\r\n     */\r\n    Game.prototype.getStone = function(x, y) {\r\n      return this.position.stones.get(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get markup on coordinates\r\n     */\r\n    Game.prototype.getMarkup = function(x, y) {\r\n      return this.position.markup.get(x, y);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Move handling\r\n     ***/\r\n\r\n    /**\r\n     * Play move\r\n     */\r\n    Game.prototype.play = function(x, y, color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Validate move and get new position\r\n      var newPosition = this.validateMove(x, y, color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          x: x,\r\n          y: y,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n\r\n      //Valid move\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Play pass\r\n     */\r\n    Game.prototype.pass = function(color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Initialize new position and switch the turn\r\n      var newPosition = this.position.clone();\r\n      newPosition.setTurn(-color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          pass: true,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game tree navigation\r\n     ***/\r\n\r\n    /**\r\n     * Go to the next position\r\n     */\r\n    Game.prototype.next = function(i) {\r\n\r\n      //Object (node) given as parameter? Find index\r\n      if (typeof i === 'object') {\r\n        i = this.node.children.indexOf(i);\r\n      }\r\n\r\n      //Go to the next node\r\n      if (nextNode.call(this, i)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n          return true;\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      //Didn't go to next position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the previous position\r\n     */\r\n    Game.prototype.previous = function() {\r\n\r\n      //Go to the previous node\r\n      if (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        return true;\r\n      }\r\n\r\n      //Didn't go to previous position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the last position\r\n     */\r\n    Game.prototype.last = function() {\r\n\r\n      //Keep going to the next node until we reach the end\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the first position\r\n     */\r\n    Game.prototype.first = function() {\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      executeNode.call(this);\r\n    };\r\n\r\n    /**\r\n     * Go to position specified by a path object, a numeric move numer, or a node name string\r\n     */\r\n    Game.prototype.goto = function(target) {\r\n\r\n      //Must have a tree\r\n      if (this.root === null) {\r\n        return;\r\n      }\r\n\r\n      //Nothing given?\r\n      if (typeof target === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      //Function given? Call now\r\n      if (typeof target === 'function') {\r\n        target = target.call(this);\r\n      }\r\n\r\n      //Initialize path\r\n      var path;\r\n\r\n      //Simple move number? Convert to path object\r\n      if (typeof target === 'number') {\r\n        path = this.path.clone();\r\n        path.setMove(target);\r\n      }\r\n\r\n      //String? Named node\r\n      else if (typeof target === 'string') {\r\n\r\n        //Already here?\r\n        if (this.node.name === target) {\r\n          return;\r\n        }\r\n\r\n        //Find path to node\r\n        path = this.getPathToNode(target);\r\n        if (path === null) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Otherwise assume path object\r\n      else {\r\n        path = target;\r\n      }\r\n\r\n      //Already here?\r\n      if (this.path.compare(path)) {\r\n        return;\r\n      }\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      pushPosition.call(this);\r\n      executeNode.call(this);\r\n\r\n      //Loop path\r\n      var n = path.getMove();\r\n      for (var i = 0; i < n; i++) {\r\n\r\n        //Try going to the next node\r\n        if (!nextNode.call(this, path.nodeAt(i))) {\r\n          break;\r\n        }\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next fork\r\n     */\r\n    Game.prototype.nextFork = function() {\r\n\r\n      //Keep going to the next node until we reach one with multiple children\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Have multiple children?\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous fork\r\n     */\r\n    Game.prototype.previousFork = function() {\r\n\r\n      //Loop until we find a node with more than one child\r\n      while (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next move with comments\r\n     */\r\n    Game.prototype.nextComment = function() {\r\n\r\n      //Keep going to the next node until we find one with comments\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous move with comments\r\n     */\r\n    Game.prototype.previousComment = function() {\r\n\r\n      //Go back until we find a node with comments\r\n      while (previousNode.call(this)) {\r\n\r\n        //Pop the position\r\n        popPosition.call(this);\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state\r\n     */\r\n    Game.prototype.getState = function() {\r\n\r\n      //Can only create when we have a JGF and path\r\n      if (!this.jgf || !this.path) {\r\n        return null;\r\n      }\r\n\r\n      //Create state\r\n      var state = {\r\n        jgf: this.jgf,\r\n        path: this.path.clone()\r\n      };\r\n\r\n      //Return\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the game state\r\n     */\r\n    Game.prototype.restoreState = function(state) {\r\n\r\n      //Must have jgf and path\r\n      if (!state || !state.jgf || !state.path) {\r\n        return;\r\n      }\r\n\r\n      //Restore state\r\n      this.load(state.jgf);\r\n      this.goto(state.path);\r\n    };\r\n\r\n    //Return object\r\n    return Game;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameNode :: This class represents a single node in the game moves tree. It contains\r\n * properties like the x and y grid coordinates, the move played, board setup instructions,\r\n * markup, player turn and comments. The moves tree in the game record is represented by a\r\n * string of GameNodes, each with pointers to their parent and children. Each node can have\r\n * multiple children (move variations), but only one parent.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Node.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameNode', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /**\r\n   * Helper to construct a coordinates base object\r\n   */\r\n  function coordinatesObject(coords, baseObject) {\r\n    baseObject = baseObject || {};\r\n    if (coords === '' || coords === 'pass') {\r\n      baseObject.pass = true;\r\n    }\r\n    else {\r\n\r\n      //Backwards compatibility with SGF string coordinates in JGF\r\n      if (typeof coords === 'string') {\r\n        coords = convertCoordinates(coords);\r\n      }\r\n\r\n      //Append coordinates\r\n      baseObject.x = coords[0] * 1;\r\n      baseObject.y = coords[1] * 1;\r\n    }\r\n    return baseObject;\r\n  }\r\n\r\n  /**\r\n   * Convert a numeric color value (color constant) to a string\r\n   */\r\n  function toStringColor(color) {\r\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\r\n  }\r\n\r\n  /**\r\n   * Convert a string color value to a numeric color constant\r\n   */\r\n  function toColorConstant(color) {\r\n    if (color === 'B') {\r\n      return StoneColor.B;\r\n    }\r\n    else if (color === 'W') {\r\n      return StoneColor.W;\r\n    }\r\n    return StoneColor.E;\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Helpers for conversion between JGF / KIFU format\r\n   ***/\r\n\r\n  /**\r\n   * Convert move object to JGF format\r\n   */\r\n  function convertMoveToJgf(move) {\r\n\r\n    //Initialize JGF move object and determine color\r\n    var jgfMove = angular.copy(move);\r\n    var color = toStringColor(move.color);\r\n\r\n    //No color?\r\n    if (color === '') {\r\n      return null;\r\n    }\r\n\r\n    //Pass move?\r\n    if (move.pass === true) {\r\n      jgfMove[color] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      jgfMove[color] = [move.x, move.y];\r\n    }\r\n\r\n    //Delete coordinates and color\r\n    delete jgfMove.x;\r\n    delete jgfMove.y;\r\n    delete jgfMove.color;\r\n\r\n    //Return move\r\n    return jgfMove;\r\n  }\r\n\r\n  /**\r\n   * Convert move from JGF format\r\n   */\r\n  function convertMoveFromJgf(move) {\r\n\r\n    //Prepare color, coordinates\r\n    var color, coords;\r\n\r\n    //Check whose move it was\r\n    if (move.W) {\r\n      color = 'W';\r\n      coords = move.W;\r\n    }\r\n    else if (move.B) {\r\n      color = 'B';\r\n      coords = move.B;\r\n    }\r\n\r\n    //No coordinates?\r\n    if (!coords) {\r\n      return null;\r\n    }\r\n\r\n    //Return coordinates object\r\n    return coordinatesObject(coords, {\r\n      color: toColorConstant(color)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert setup object to JGF format\r\n   */\r\n  function convertSetupToJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var i, color;\r\n    var jgfSetup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in setup) {\r\n      if (setup.hasOwnProperty(i)) {\r\n\r\n        //Get color\r\n        color = toStringColor(setup[i].color) || 'E';\r\n\r\n        //Initialize array\r\n        if (typeof jgfSetup[color] === 'undefined') {\r\n          jgfSetup[color] = [];\r\n        }\r\n\r\n        //Add coordinates\r\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert setup from JGF format\r\n   */\r\n  function convertSetupFromJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var c, key, color;\r\n    var gameSetup = [];\r\n\r\n    //Loop setup\r\n    for (key in setup) {\r\n      if (setup.hasOwnProperty(key)) {\r\n\r\n        //Get color constant\r\n        color = toColorConstant(key);\r\n\r\n        //Loop coordinates\r\n        for (c in setup[key]) {\r\n          if (setup[key].hasOwnProperty(c)) {\r\n            gameSetup.push(coordinatesObject(setup[key][c], {\r\n              color: color\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup object to JGF format\r\n   */\r\n  function convertMarkupToJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var i, type;\r\n    var jgfMarkup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in markup) {\r\n      if (markup.hasOwnProperty(i)) {\r\n\r\n        //Get type\r\n        type = markup[i].type;\r\n\r\n        //Initialize array\r\n        if (typeof jgfMarkup[type] === 'undefined') {\r\n          jgfMarkup[type] = [];\r\n        }\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\r\n        }\r\n        else {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup from JGF format\r\n   */\r\n  function convertMarkupFromJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var l, type;\r\n    var gameMarkup = [];\r\n\r\n    //Loop markup types\r\n    for (type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          for (l = 0; l < markup[type].length; l++) {\r\n\r\n            //Validate\r\n            if (!angular.isArray(markup[type][l])) {\r\n              continue;\r\n            }\r\n\r\n            //SGF type coordinates?\r\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\r\n              var text = markup[type][l][1];\r\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\r\n              markup[type][l].push(text);\r\n            }\r\n\r\n            //Validate length\r\n            if (markup[type][l].length < 3) {\r\n              continue;\r\n            }\r\n\r\n            //Add to stack\r\n            gameMarkup.push(coordinatesObject(markup[type][l], {\r\n              type: type,\r\n              text: markup[type][l][2]\r\n            }));\r\n          }\r\n        }\r\n        else {\r\n\r\n          //Loop coordinates\r\n          for (l in markup[type]) {\r\n            if (markup[type].hasOwnProperty(l)) {\r\n              gameMarkup.push(coordinatesObject(markup[type][l], {\r\n                type: type\r\n              }));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert turn object to JGF format\r\n   */\r\n  function convertTurnToJgf(turn) {\r\n    switch (turn) {\r\n      case StoneColor.W:\r\n        return 'W';\r\n      case StoneColor.B:\r\n        return 'B';\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert turn from JGF format\r\n   */\r\n  function convertTurnFromJgf(turn) {\r\n    switch (turn) {\r\n      case 'W':\r\n        return StoneColor.W;\r\n      case 'B':\r\n        return StoneColor.B;\r\n      default:\r\n        return StoneColor.EMPTY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Conversions map\r\n   */\r\n  var conversionMap = {\r\n    toJgf: {\r\n      move: convertMoveToJgf,\r\n      setup: convertSetupToJgf,\r\n      markup: convertMarkupToJgf,\r\n      turn: convertTurnToJgf\r\n    },\r\n    fromJgf: {\r\n      move: convertMoveFromJgf,\r\n      setup: convertSetupFromJgf,\r\n      markup: convertMarkupFromJgf,\r\n      turn: convertTurnFromJgf\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameNode(properties, parent) {\r\n\r\n    //Set parent and children\r\n    this.parent = parent || null;\r\n    this.children = [];\r\n\r\n    //Save properties\r\n    if (properties) {\r\n      for (var key in properties) {\r\n        if (properties.hasOwnProperty(key)) {\r\n          this[key] = properties[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get node's child specified by index or null if doesn't exist\r\n   */\r\n  GameNode.prototype.getChild = function(i) {\r\n    i = i || 0;\r\n    if (this.children[i]) {\r\n      return this.children[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Get all the children\r\n   */\r\n  GameNode.prototype.getChildren = function() {\r\n    return this.children;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has any chilren\r\n   */\r\n  GameNode.prototype.hasChildren = function() {\r\n    return (this.children.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Get parent node\r\n   */\r\n  GameNode.prototype.getParent = function() {\r\n    return this.parent;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has more than one move variation\r\n   */\r\n  GameNode.prototype.hasMoveVariations = function() {\r\n\r\n    //Less than two child nodes?\r\n    if (this.children.length <= 1) {\r\n      return false;\r\n    }\r\n\r\n    //Loop children\r\n    var moveVariations = 0;\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations++;\r\n      }\r\n\r\n      //More than one move node present?\r\n      if (moveVariations > 1) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //No move variations\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Get all the move variation nodes\r\n   */\r\n  GameNode.prototype.getMoveVariations = function() {\r\n\r\n    //No child nodes?\r\n    if (this.children.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize\r\n    var moveVariations = [];\r\n\r\n    //Loop child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations.push(this.children[i]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return moveVariations;\r\n  };\r\n\r\n  /**\r\n   * Get the move variation for given coordinates\r\n   */\r\n  GameNode.prototype.getMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return -1;\r\n  };\r\n\r\n  /**\r\n   * Check if given coordinates are one of the next child node coordinates\r\n   */\r\n  GameNode.prototype.isMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if we have comments\r\n   */\r\n  GameNode.prototype.hasComments = function() {\r\n    return (this.comments && this.comments.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Check if this is a move node\r\n   */\r\n  GameNode.prototype.isMove = function() {\r\n    return !!this.move;\r\n  };\r\n\r\n  /**\r\n   * Get move number\r\n   */\r\n  GameNode.prototype.getMoveNumber = function() {\r\n\r\n    //Move node?\r\n    if (this.isMove()) {\r\n      if (this.parent) {\r\n        return this.parent.getMoveNumber() + 1;\r\n      }\r\n      return 1;\r\n    }\r\n\r\n    //Use parent move number if we have one\r\n    if (this.parent) {\r\n      return this.parent.getMoveNumber();\r\n    }\r\n\r\n    //No parent\r\n    return 0;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Node manipulation\r\n   ***/\r\n\r\n  /**\r\n   * Remove this node from its parent\r\n   */\r\n  GameNode.prototype.remove = function() {\r\n\r\n    //Can't remove if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found remove it\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1) {\r\n      this.parent.children.splice(i, 1);\r\n    }\r\n\r\n    //Clear parent reference\r\n    this.parent = null;\r\n  };\r\n\r\n  /**\r\n   * Move the node up in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveUp = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i > 0) {\r\n      var temp = this.parent.children[i - 1];\r\n      this.parent.children[i - 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Move the node down in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveDown = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\r\n      var temp = this.parent.children[i + 1];\r\n      this.parent.children[i + 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Append this node to another node\r\n   */\r\n  GameNode.prototype.appendTo = function(node) {\r\n\r\n    //Remove from existing parent\r\n    this.remove();\r\n\r\n    //Set new parent\r\n    this.parent = node;\r\n    node.children.push(this);\r\n    return node.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Append child node to this node.\r\n   */\r\n  GameNode.prototype.appendChild = function(node) {\r\n    node.parent = this;\r\n    this.children.push(node);\r\n    return this.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Insert another node after this one\r\n   */\r\n  GameNode.prototype.insertNode = function(node) {\r\n\r\n    //Loop our children and change parent node\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      this.children[i].parent = node;\r\n    }\r\n\r\n    //Merge children, set this node as the parent of given node\r\n    node.children = node.children.concat(this.children);\r\n    node.parent = this;\r\n\r\n    //Set given node as the child of this node\r\n    this.children = [node];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * JGF conversion\r\n   ***/\r\n\r\n  /**\r\n   * Build a Game Node from a given JGF tree\r\n   */\r\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\r\n\r\n    //Root JGF file given?\r\n    if (typeof jgf.tree !== 'undefined') {\r\n      return GameNode.fromJgf(jgf.tree, gameNode);\r\n    }\r\n\r\n    //Initialize helper vars\r\n    var variationNode, nextNode, i, j;\r\n\r\n    //Node to work with given? Otherwise, work with ourselves\r\n    gameNode = gameNode || this;\r\n\r\n    //Loop moves in the JGF tree\r\n    for (i = 0; i < jgf.length; i++) {\r\n\r\n      //Array? That means a variation branch\r\n      if (angular.isArray(jgf[i])) {\r\n\r\n        //Loop variation stacks\r\n        for (j = 0; j < jgf[i].length; j++) {\r\n\r\n          //Build the variation node\r\n          variationNode = new GameNode();\r\n          variationNode.fromJgf(jgf[i][j]);\r\n\r\n          //Append to working node\r\n          gameNode.appendChild(variationNode);\r\n        }\r\n      }\r\n\r\n      //Regular node\r\n      else {\r\n\r\n        //Get properties to copy\r\n        var properties = Object.getOwnPropertyNames(jgf[i]);\r\n\r\n        //Copy node properties\r\n        for (var key in properties) {\r\n          if (properties.hasOwnProperty(key)) {\r\n            var prop = properties[key];\r\n\r\n            //Conversion function present?\r\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\r\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\r\n            }\r\n            else if (typeof jgf[i][prop] === 'object') {\r\n              gameNode[prop] = angular.copy(jgf[i][prop]);\r\n            }\r\n            else {\r\n              gameNode[prop] = jgf[i][prop];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Next element is a regular node? Prepare new working node\r\n      //Otherwise, if there are no more nodes or if the next element is\r\n      //an array (e.g. variations), we keep our working node as the current one\r\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\r\n        nextNode = new GameNode();\r\n        gameNode.appendChild(nextNode);\r\n        gameNode = nextNode;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Convert this node to a JGF node container\r\n   */\r\n  GameNode.prototype.toJgf = function(container) {\r\n\r\n    //Initialize container to add nodes to\r\n    container = container || [];\r\n\r\n    //Initialize node and get properties\r\n    var node = {};\r\n    var properties = Object.getOwnPropertyNames(this);\r\n\r\n    //Copy node properties\r\n    for (var key in properties) {\r\n      if (properties.hasOwnProperty(key)) {\r\n        var prop = properties[key];\r\n\r\n        //Skip some properties\r\n        if (prop === 'parent' || prop === 'children') {\r\n          continue;\r\n        }\r\n\r\n        //Conversion function present?\r\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\r\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\r\n        }\r\n        else if (typeof this[prop] === 'object') {\r\n          node[prop] = angular.copy(this[prop]);\r\n        }\r\n        else {\r\n          node[prop] = this[prop];\r\n        }\r\n      }\r\n    }\r\n\r\n    //Add node to container\r\n    container.push(node);\r\n\r\n    //Variations present?\r\n    if (this.children.length > 1) {\r\n\r\n      //Create variations container\r\n      var variationsContainer = [];\r\n      container.push(variationsContainer);\r\n\r\n      //Loop child (variation) nodes\r\n      for (var i = 0; i < this.children.length; i++) {\r\n\r\n        //Create container for this variation\r\n        var variationContainer = [];\r\n        variationsContainer.push(variationContainer);\r\n\r\n        //Call child node converter\r\n        this.children[i].toJgf(variationContainer);\r\n      }\r\n    }\r\n\r\n    //Just one child?\r\n    else if (this.children.length === 1) {\r\n      this.children[0].toJgf(container);\r\n    }\r\n\r\n    //Return container\r\n    return container;\r\n  };\r\n\r\n  //Return object\r\n  return GameNode;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePath :: A simple class that keeps track of a path taken in a game.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Path.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePath', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePath() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Reset\r\n   */\r\n  GamePath.prototype.reset = function() {\r\n    this.move = 0;\r\n    this.path = {};\r\n    this.branches = 0;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Advance a move\r\n   */\r\n  GamePath.prototype.advance = function(i) {\r\n\r\n    //Different child variation chosen? Remember\r\n    if (i > 0) {\r\n      this.path[this.move] = 1;\r\n      this.branches++;\r\n    }\r\n\r\n    //Increment move\r\n    this.move++;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Retreat a move\r\n   */\r\n  GamePath.prototype.retreat = function() {\r\n\r\n    //At start?\r\n    if (this.move === 0) {\r\n      return;\r\n    }\r\n\r\n    //Delete path choice\r\n    if (this.path[this.move]) {\r\n      delete this.path[this.move];\r\n      this.branches--;\r\n    }\r\n\r\n    //Decrement move\r\n    this.move--;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Go to a specific move number\r\n   */\r\n  GamePath.prototype.setMove = function(no) {\r\n\r\n    //Less than our current move? We need to erase any paths above the move number\r\n    if (no < this.move) {\r\n      for (var i in this.path) {\r\n        if (i > no) {\r\n          delete this.path[i];\r\n          this.branches--;\r\n        }\r\n      }\r\n    }\r\n\r\n    //Set move number\r\n    this.move = no;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the move number\r\n   */\r\n  GamePath.prototype.getMove = function() {\r\n    return this.move;\r\n  };\r\n\r\n  /**\r\n   * Get the node choice at a specific move number\r\n   */\r\n  GamePath.prototype.nodeAt = function(no) {\r\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\r\n  };\r\n\r\n  /**\r\n   * Compare to another path\r\n   */\r\n  GamePath.prototype.compare = function(otherPath) {\r\n\r\n    //Invalid object?\r\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    //Different move number or path length?\r\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\r\n      return false;\r\n    }\r\n\r\n    //Check path\r\n    for (var i in this.path) {\r\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    //Same path!\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clone\r\n   */\r\n  GamePath.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newPath = new GamePath();\r\n\r\n    //Set vars\r\n    newPath.move = this.move;\r\n    newPath.branches = this.branches;\r\n    newPath.path = angular.copy(this.path);\r\n\r\n    //Return\r\n    return newPath;\r\n  };\r\n\r\n  /**\r\n   * Helper to find node name recursively\r\n   */\r\n  function findNodeName(node, nodeName, path) {\r\n\r\n    //Found in this node?\r\n    if (node.name && node.name === nodeName) {\r\n      return true;\r\n    }\r\n\r\n    //Loop children\r\n    for (var i = 0; i < node.children.length; i++) {\r\n\r\n      //Advance path\r\n      path.advance(i);\r\n\r\n      //Found in child node?\r\n      if (findNodeName(node.children[i], nodeName, path)) {\r\n        return true;\r\n      }\r\n\r\n      //Not found in this child node, retreat path\r\n      path.retreat();\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Static helper to create a path object to reach a certain node\r\n   */\r\n  GamePath.findNode = function(nodeName, rootNode) {\r\n\r\n    //Create new instance\r\n    var path = new GamePath();\r\n\r\n    //Find the node name\r\n    if (findNodeName(rootNode, nodeName, path)) {\r\n      return path;\r\n    }\r\n\r\n    //Not found\r\n    return null;\r\n  };\r\n\r\n  //Return\r\n  return GamePath;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\r\n * markup on the board in this position, as well as any captures that were made and which player's\r\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\r\n * compare changes to other positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Position.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePosition(width, height) {\r\n\r\n    //Initialize\r\n    this.error = 0;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.stones = new BoardGrid();\r\n    this.markup = new BoardGrid();\r\n    this.turn = StoneColor.B;\r\n\r\n    //Initialize captures\r\n    this.captures = {};\r\n    this.captures[StoneColor.B] = [];\r\n    this.captures[StoneColor.W] = [];\r\n\r\n    //Set empty value for stones grid\r\n    this.stones.whenEmpty(StoneColor.EMPTY);\r\n\r\n    //Set size\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  GamePosition.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Set in grids\r\n    this.stones.setSize(width, height);\r\n    this.markup.setSize(width, height);\r\n\r\n    //Empty the position\r\n    this.empty();\r\n  };\r\n\r\n  /**\r\n   * Clear the whole position\r\n   */\r\n  GamePosition.prototype.empty = function() {\r\n    this.stones.empty();\r\n    this.markup.empty();\r\n  };\r\n\r\n  /**\r\n   * Sets stone color at given coordinates.\r\n   */\r\n  GamePosition.prototype.setStone = function(x, y, color) {\r\n    this.stones.set(x, y, color);\r\n  };\r\n\r\n  /**\r\n   * Sets markup type at given coordinates.\r\n   */\r\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\r\n    this.markup.set(x, y, markup);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Liberties and capturing\r\n   ***/\r\n\r\n  /**\r\n   * Check if a group of given color has liberties, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\r\n\r\n    //Out of bounds? No liberties outside of the board\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize tested grid if needed\r\n    tested = tested || new BoardGrid(this.width, this.height);\r\n\r\n    //See what color is present on the coordinates\r\n    var color = this.stones.get(x, y);\r\n\r\n    //If no group color was given, use what's on the position\r\n    groupColor = groupColor || color;\r\n\r\n    //Already tested, or enemy stone? Not giving any liberties\r\n    if (tested.get(x, y) === true || color === -groupColor) {\r\n      return false;\r\n    }\r\n\r\n    //Empty? That's a liberty\r\n    if (color === StoneColor.EMPTY) {\r\n      return true;\r\n    }\r\n\r\n    //Mark this position as tested now\r\n    tested.set(x, y, true);\r\n\r\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\r\n    //If we get at least one true, we have a liberty\r\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\r\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\r\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\r\n        this.hasLiberties(x + 1, y, groupColor, tested);\r\n  };\r\n\r\n  /**\r\n   * Helper to capture adjacent groups\r\n   */\r\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    friendlyColor = friendlyColor || this.stones.get(x, y);\r\n\r\n    //Can't capture empty spots\r\n    if (friendlyColor === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Flag to see if we captured stuff\r\n    var captured = false;\r\n\r\n    //Check adjacent positions now, capturing stones in the process if possible\r\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n\r\n    //Return\r\n    return captured;\r\n  };\r\n\r\n  /**\r\n   * Helper if we can capture a certain group\r\n   */\r\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\r\n\r\n    //Out of bounds? Nothing to capture\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Empty spot? Can't capture\r\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //We need to have a stone of matching group color in order to be able to capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //There is a capturable stone, let's see if it has any liberties left\r\n    if (this.hasLiberties(x, y, enemyColor)) {\r\n      return false;\r\n    }\r\n\r\n    //No liberties left, the group is capturable. Capture if we want to\r\n    if (doCapture) {\r\n      this.captureGroup(x, y, enemyColor);\r\n    }\r\n\r\n    //Capturable\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a group of certain color, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //If no group color was given, use what's on the position\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //Stone at position does not match the given group color? Can't capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //Capture the stone\r\n    this.captureStone(x, y);\r\n\r\n    //Capture the rest of the group\r\n    this.captureGroup(x, y - 1, enemyColor);\r\n    this.captureGroup(x, y + 1, enemyColor);\r\n    this.captureGroup(x - 1, y, enemyColor);\r\n    this.captureGroup(x + 1, y, enemyColor);\r\n\r\n    //At least one stone was captured\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a stone at given coordinates\r\n   */\r\n  GamePosition.prototype.captureStone = function(x, y) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get color\r\n    var color = this.stones.get(x, y);\r\n\r\n    //Empty?\r\n    if (color === StoneColor.EMPTY) {\r\n      return;\r\n    }\r\n\r\n    //Ok, stone present, capture it\r\n    this.stones.set(x, y, StoneColor.EMPTY);\r\n    this.captures[color].push({x: x, y: y});\r\n  };\r\n\r\n  /**\r\n   * Set captures for a color (expects array with capture object coordinates)\r\n   */\r\n  GamePosition.prototype.setCaptures = function(color, captures) {\r\n    this.captures[color] = captures;\r\n  };\r\n\r\n  /**\r\n   * Get captures for a color\r\n   */\r\n  GamePosition.prototype.getCaptures = function(color) {\r\n    return this.captures[color] || [];\r\n  };\r\n\r\n  /**\r\n   * Get the capture count for a color (= the number of captures of the opposing color)\r\n   */\r\n  GamePosition.prototype.getCaptureCount = function(color) {\r\n    return this.captures[-color].length;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Turn control\r\n   ***/\r\n\r\n  /**\r\n   * Set color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.setTurn = function(color) {\r\n    this.turn = color;\r\n  };\r\n\r\n  /**\r\n   * Get color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.getTurn = function() {\r\n    return this.turn;\r\n  };\r\n\r\n  /**\r\n   * Switch the player turn on this position\r\n   */\r\n  GamePosition.prototype.switchTurn = function() {\r\n    this.turn = -this.turn;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Cloning and comparison\r\n   ***/\r\n\r\n  /**\r\n   * Clones the whole position except turn and captures\r\n   */\r\n  GamePosition.prototype.clone = function() {\r\n\r\n    //Create a new position\r\n    var newPosition = new GamePosition();\r\n\r\n    //Set vars manually for maximum efficiency\r\n    newPosition.turn = this.turn;\r\n    newPosition.width = this.width;\r\n    newPosition.height = this.height;\r\n    newPosition.stones = this.stones.clone();\r\n    newPosition.markup = new BoardGrid(this.width, this.height);\r\n\r\n    //Return\r\n    return newPosition;\r\n  };\r\n\r\n  /**\r\n   * Checks if a given position is the same as the current position\r\n   */\r\n  GamePosition.prototype.isSameAs = function(newPosition) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\r\n      return false;\r\n    }\r\n\r\n    //Compare the grids\r\n    return this.stones.isSameAs(newPosition.stones);\r\n  };\r\n\r\n  //Return\r\n  return GamePosition;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScore :: A simple class that contains a game score\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Score.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScore', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Helper to calculate the total points\r\n   */\r\n  function calcTotal() {\r\n    return parseInt(this.stones) + parseInt(this.territory) +\r\n      parseInt(this.captures) + parseInt(this.komi);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameScore() {\r\n\r\n    //Get self\r\n    var self = this;\r\n\r\n    //Setup score containers\r\n    this.black = {};\r\n    this.white = {};\r\n\r\n    //Initialize\r\n    this.reset();\r\n\r\n    //Add total handlers\r\n    this.black.total = function() {\r\n      return calcTotal.call(self.black);\r\n    };\r\n    this.white.total = function() {\r\n      return calcTotal.call(self.white);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the game score\r\n   */\r\n  GameScore.prototype.reset = function() {\r\n\r\n    //Get properties to loop\r\n    var props = ['stones', 'territory', 'captures', 'komi'];\r\n\r\n    //Score for black player\r\n    for (var i = 0; i < props.length; i++) {\r\n      this.black[props[i]] = 0;\r\n      this.white[props[i]] = 0;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the winner\r\n   */\r\n  GameScore.prototype.winner = function() {\r\n\r\n    //Get totals\r\n    var b = this.black.total();\r\n    var w = this.white.total();\r\n\r\n    //Determine winner\r\n    if (w > b) {\r\n      return StoneColor.W;\r\n    }\r\n    else if (b > w) {\r\n      return StoneColor.B;\r\n    }\r\n    return StoneColor.E;\r\n  };\r\n\r\n  //Return\r\n  return GameScore;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScorer :: This class is used to determine the score of a certain game position. It also\r\n * provides handling of manual adjustment of dead / living groups.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Scorer.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Score.Service',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Possible score states\r\n   */\r\n  var scoreState = {\r\n    UNKNOWN: StoneColor.EMPTY,\r\n    BLACK_STONE: StoneColor.B,\r\n    WHITE_STONE: StoneColor.W,\r\n    BLACK_CANDIDATE: StoneColor.B * 2,\r\n    WHITE_CANDIDATE: StoneColor.W * 2,\r\n    NEUTRAL: StoneColor.B * 3\r\n  };\r\n\r\n  /**\r\n   * Helper to set territory\r\n   */\r\n  function territorySet(x, y, candidateColor, boundaryColor) {\r\n\r\n    //Get color at given position\r\n    var posColor = this.stones.get(x, y);\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //If border reached, or a position which is already this color, or boundary color, can't set\r\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\r\n      return;\r\n    }\r\n\r\n    //Don't turn stones which are already this color into candidates, instead\r\n    //reset their color to what they were\r\n    if (origColor * 2 === candidateColor) {\r\n      this.stones.set(x, y, origColor);\r\n    }\r\n\r\n    //Otherwise, mark as candidate\r\n    else {\r\n      this.stones.set(x, y, candidateColor);\r\n    }\r\n\r\n    //Set adjacent squares\r\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\r\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\r\n  }\r\n\r\n  /**\r\n   * Helper to reset territory\r\n   */\r\n  function territoryReset(x, y) {\r\n\r\n    //Get original color from this position\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //Not on grid, or already this color?\r\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\r\n      return;\r\n    }\r\n\r\n    //Reset the color\r\n    this.stones.set(x, y, origColor);\r\n\r\n    //Set adjacent squares\r\n    territoryReset.call(this, x - 1, y);\r\n    territoryReset.call(this, x, y - 1);\r\n    territoryReset.call(this, x + 1, y);\r\n    territoryReset.call(this, x, y + 1);\r\n  }\r\n\r\n  /**\r\n   * Helper to determine score state\r\n   */\r\n  function determineScoreState() {\r\n\r\n    //Initialize vars\r\n    var change = true;\r\n    var curState, newState, adjacent, b, w, a, x, y;\r\n\r\n    //Loop while there is change\r\n    while (change) {\r\n\r\n      //Set to false\r\n      change = false;\r\n\r\n      //Go through the whole position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get current state at position\r\n          curState = this.stones.get(x, y);\r\n\r\n          //Unknown or candiates?\r\n          if (\r\n            curState === scoreState.UNKNOWN ||\r\n            curState === scoreState.BLACK_CANDIDATE ||\r\n            curState === scoreState.WHITE_CANDIDATE\r\n          ) {\r\n\r\n            //Get state in adjacent positions\r\n            adjacent = [\r\n              this.stones.get(x - 1, y),\r\n              this.stones.get(x, y - 1),\r\n              this.stones.get(x + 1, y),\r\n              this.stones.get(x, y + 1)\r\n            ];\r\n\r\n            //Reset\r\n            b = w = false;\r\n\r\n            //Loop adjacent squares\r\n            for (a = 0; a < 4; a++) {\r\n              if (\r\n                adjacent[a] === scoreState.BLACK_STONE ||\r\n                adjacent[a] === scoreState.BLACK_CANDIDATE\r\n              ) {\r\n                b = true;\r\n              }\r\n              else if (\r\n                adjacent[a] === scoreState.WHITE_STONE ||\r\n                adjacent[a] === scoreState.WHITE_CANDIDATE\r\n              ) {\r\n                w = true;\r\n              }\r\n              else if (adjacent[a] === scoreState.NEUTRAL) {\r\n                b = w = true;\r\n              }\r\n            }\r\n\r\n            //Determine new state\r\n            if (b && w) {\r\n              newState = scoreState.NEUTRAL;\r\n            }\r\n            else if (b) {\r\n              newState = scoreState.BLACK_CANDIDATE;\r\n            }\r\n            else if (w) {\r\n              newState = scoreState.WHITE_CANDIDATE;\r\n            }\r\n            else {\r\n              newState = false;\r\n            }\r\n\r\n            //Change?\r\n            if (newState !== false && newState !== curState) {\r\n              change = true;\r\n              this.stones.set(x, y, newState);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * this.game scorer class\r\n   */\r\n  var GameScorer = {\r\n\r\n    //Game to score\r\n    game: null,\r\n\r\n    //Score\r\n    score: null,\r\n\r\n    //Stones, captures and points grids\r\n    stones: null,\r\n    captures: null,\r\n    points: null,\r\n\r\n    /**\r\n     * Load a game to score\r\n     */\r\n    load: function(game) {\r\n\r\n      //Reset score\r\n      this.score = new GameScore();\r\n\r\n      //Remember\r\n      this.game = game;\r\n\r\n      //Clone position to work with\r\n      this.stones = this.game.position.stones.clone();\r\n\r\n      //Create grids\r\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n    },\r\n\r\n    /**\r\n     * Get the calculated score\r\n     */\r\n    getScore: function() {\r\n      return this.score;\r\n    },\r\n\r\n    /**\r\n     * Get the points grid\r\n     */\r\n    getPoints: function() {\r\n      return this.points;\r\n    },\r\n\r\n    /**\r\n     * Get the captures grid\r\n     */\r\n    getCaptures: function() {\r\n      return this.captures;\r\n    },\r\n\r\n    /**\r\n     * Run score calculation routine\r\n     */\r\n    calculate: function() {\r\n\r\n      //No game?\r\n      if (!this.game) {\r\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\r\n        return;\r\n      }\r\n\r\n      //Empty grids\r\n      this.points.empty();\r\n      this.captures.empty();\r\n\r\n      //Determine score state\r\n      determineScoreState.call(this);\r\n\r\n      //Get komi and captures\r\n      var komi = this.game.get('game.komi');\r\n      var captures = this.game.getCaptureCount();\r\n\r\n      //Reset score\r\n      this.score.reset();\r\n\r\n      //Set captures and komi\r\n      this.score.black.captures = captures[StoneColor.B];\r\n      this.score.white.captures = captures[StoneColor.W];\r\n      this.score.black.komi = komi < 0 ? komi : 0;\r\n      this.score.white.komi = komi > 0 ? komi : 0;\r\n\r\n      //Init helper vars\r\n      var x, y, state, color;\r\n\r\n      //Loop position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get state and color on original position\r\n          state = this.stones.get(x, y);\r\n          color = this.game.position.stones.get(x, y);\r\n\r\n          //Black stone\r\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\r\n            this.score.black.stones++;\r\n            continue;\r\n          }\r\n\r\n          //White stone\r\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\r\n            this.score.white.stones++;\r\n            continue;\r\n          }\r\n\r\n          //Black candidate\r\n          if (state === scoreState.BLACK_CANDIDATE) {\r\n            this.score.black.territory++;\r\n            this.points.set(x, y, StoneColor.B);\r\n\r\n            //White stone underneath?\r\n            if (color === StoneColor.W) {\r\n              this.score.black.captures++;\r\n              this.captures.set(x, y, StoneColor.W);\r\n            }\r\n            continue;\r\n          }\r\n\r\n          //White candidate\r\n          if (state === scoreState.WHITE_CANDIDATE) {\r\n            this.score.white.territory++;\r\n            this.points.set(x, y, StoneColor.W);\r\n\r\n            //Black stone underneath?\r\n            if (color === StoneColor.B) {\r\n              this.score.white.captures++;\r\n              this.captures.set(x, y, StoneColor.B);\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mark stones dead or alive\r\n     */\r\n    mark: function(x, y) {\r\n\r\n      //Get color of original position and state of the count position\r\n      var color = this.game.position.stones.get(x, y);\r\n      var state = this.stones.get(x, y);\r\n\r\n      //White stone\r\n      if (color === StoneColor.W) {\r\n\r\n        //Was white, mark it and any territory it's in as black's\r\n        if (state === scoreState.WHITE_STONE) {\r\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\r\n        }\r\n\r\n        //Was marked as not white, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n\r\n      //Black stone\r\n      else if (color === StoneColor.B) {\r\n\r\n        //Was black, mark it and any territory it's in as white's\r\n        if (state === scoreState.BLACK_STONE) {\r\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\r\n        }\r\n\r\n        //Was marked as not black, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return GameScorer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidDataError :: Error class to handle invalid data.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidDataError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidDataError(code) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidDataError';\r\n    this.message = 'Invalid data: ';\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.NO_DATA:\r\n        this.message += 'no data to process.';\r\n        break;\r\n      case ngGo.error.UNKNOWN_DATA:\r\n        this.message += 'unknown data format.';\r\n        break;\r\n      case ngGo.error.INVALID_GIB:\r\n        this.message += 'unable to parse GIB data.';\r\n        break;\r\n      case ngGo.error.INVALID_SGF:\r\n        this.message += 'unable to parse SGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_JSON:\r\n        this.message += 'unable to parse JGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_TREE_JSON:\r\n        this.message += 'unable to parse the JGF tree data.';\r\n        break;\r\n      default:\r\n        this.message += 'unable to parse the data.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidDataError.prototype = new Error();\r\n  InvalidDataError.prototype.constructor = InvalidDataError;\r\n\r\n  //Return object\r\n  return InvalidDataError;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidPositionError :: Error class to handle invalid moves.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidPositionError(code, x, y, color) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidPositionError';\r\n    this.message = 'Invalid position detected.';\r\n\r\n    //Add position data\r\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\r\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\r\n        ' stone on (' + x + ', ' + y + ')';\r\n    }\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\r\n        this.message += ', but these coordinates are not on the board.';\r\n        break;\r\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\r\n        this.message += ', but there is already a stone on those coordinates.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_SUICIDE:\r\n        this.message += ', but that would be suicide.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_REPEATING:\r\n        this.message += ', but this position already occured.';\r\n        break;\r\n      default:\r\n        this.message += '.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidPositionError.prototype = new Error();\r\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\r\n\r\n  //Return object\r\n  return InvalidPositionError;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Blank.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuBlank', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Blank JGF\r\n   */\r\n  var blankJgf = {\r\n    record: {\r\n      application: ngGo.name + ' v' + ngGo.version,\r\n      version: 1,\r\n      charset: 'UTF-8'\r\n    },\r\n    game: {\r\n      type: 'go',\r\n      players: [\r\n        {\r\n          color: 'black',\r\n          name: 'Black'\r\n        },\r\n        {\r\n          color: 'white',\r\n          name: 'White'\r\n        }\r\n      ]\r\n    },\r\n    board: {\r\n      width: 19,\r\n      height: 19\r\n    },\r\n    tree: []\r\n  };\r\n\r\n  /**\r\n   * Blank SGF\r\n   */\r\n  var blankSgf = {\r\n    AP: ngGo.name + ':' + ngGo.version,\r\n    CA: 'UTF-8',\r\n    FF: '4',\r\n    GM: '1',\r\n    SZ: '19',\r\n    PB: 'Black',\r\n    PW: 'White'\r\n  };\r\n\r\n  /**\r\n   * Blank JGF/SGF container\r\n   */\r\n  var KifuBlank = {\r\n\r\n    /**\r\n     * Get blank JGF\r\n     */\r\n    jgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankJgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    },\r\n\r\n    /**\r\n     * Get blank SGF\r\n     */\r\n    sgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankSgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = base[p];\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuBlank;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\r\n * constants used by the parsers to aid conversion.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parser.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\r\n])\r\n\r\n/**\r\n * SGF/JGF aliases constant for conversion between the two formats\r\n * Note: not all properties can be translated directly, so some are\r\n * not present here in this constant\r\n */\r\n.constant('sgfAliases', {\r\n\r\n  //Record properties\r\n  'AP': 'record.application',\r\n  'CA': 'record.charset',\r\n  'CP': 'record.copyright',\r\n  'SO': 'record.source',\r\n  'US': 'record.transcriber',\r\n  'AN': 'record.annotator',\r\n\r\n  //Game properties\r\n  'GM': 'game.type',\r\n  'GN': 'game.name',\r\n  'KM': 'game.komi',\r\n  'HA': 'game.handicap',\r\n  'RE': 'game.result',\r\n  'RU': 'game.rules',\r\n  'TM': 'game.time.main',\r\n  'OT': 'game.time.overtime',\r\n  'DT': 'game.dates',\r\n  'PC': 'game.location',\r\n  'EV': 'game.event',\r\n  'RO': 'game.round',\r\n  'ON': 'game.opening',\r\n  'GC': 'game.comment',\r\n\r\n  //Player info properties\r\n  'PB': 'name',\r\n  'PW': 'name',\r\n  'BT': 'team',\r\n  'WT': 'team',\r\n  'BR': 'rank',\r\n  'WR': 'rank',\r\n\r\n  //Node annotation\r\n  'N': 'name',\r\n  'C': 'comments',\r\n  'CR': 'circle',\r\n  'TR': 'triangle',\r\n  'SQ': 'square',\r\n  'MA': 'mark',\r\n  'SL': 'select',\r\n  'LB': 'label'\r\n})\r\n\r\n/**\r\n * SGF game definitions\r\n */\r\n.constant('sgfGames', {\r\n  1: 'go',\r\n  2: 'othello',\r\n  3: 'chess',\r\n  4: 'renju',\r\n  6: 'backgammon',\r\n  7: 'chinese chess',\r\n  8: 'shogi'\r\n})\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\r\n\r\n  /**\r\n   * Parser wrapper class\r\n   */\r\n  var KifuParser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    gib2jgf: function(gib, stringified) {\r\n      return Gib2Jgf.parse(gib, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    sgf2jgf: function(sgf, stringified) {\r\n      return Sgf2Jgf.parse(sgf, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    jgf2sgf: function(jgf) {\r\n      return Jgf2Sgf.parse(jgf);\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuParser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Directive', [\r\n  'ngGo.Board.Directive'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('player', ['Player', function(Player) {\r\n  return {\r\n    restrict: 'E',\r\n\r\n    /**\r\n     * Controller\r\n     */\r\n    controller: ['$scope', function($scope) {\r\n\r\n      //Set player in scope\r\n      if (!$scope.Player) {\r\n        $scope.Player = Player;\r\n      }\r\n    }],\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Link the element\r\n      Player.linkElement(element);\r\n\r\n      //Observe mode and tool attributes\r\n      attrs.$observe('mode', function(mode) {\r\n        Player.switchMode(mode);\r\n      });\r\n      attrs.$observe('tool', function(tool) {\r\n        Player.switchTool(tool);\r\n      });\r\n\r\n      //Observe other settings attributes\r\n      attrs.$observe('variationMarkup', function(attr) {\r\n        Player.setVariationMarkup(attr === 'true');\r\n      });\r\n      attrs.$observe('solutionPaths', function(attr) {\r\n        Player.toggleSolutionPaths(attr === 'true');\r\n      });\r\n      attrs.$observe('lastMoveMarker', function(attr) {\r\n        Player.setLastMoveMarker(attr);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Player :: This class brings the board to life and allows a user to interact with it. It\r\n * handles user input, controls objects going to the board, can load game records, and allows the\r\n * user to manipulate the board according to the current player mode.\r\n * Unless you want to display static positions, this is the class you'd use by default.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Service', [\r\n  'ngGo',\r\n  'ngGo.Player.Directive',\r\n  'ngGo.Player.Mode.Common.Service',\r\n  'ngGo.Board.Service',\r\n  'ngGo.Game.Service',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default mode/tool\r\n    mode: PlayerModes.REPLAY,\r\n    tool: PlayerTools.MOVE,\r\n\r\n    //Keys/scrollwheel navigation\r\n    arrowKeysNavigation: true,\r\n    scrollWheelNavigation: true,\r\n\r\n    //Last move marker, leave empty for none\r\n    lastMoveMarker: MarkupTypes.LAST,\r\n\r\n    //Indicate variations with markup on the board, and show\r\n    //successor node variations or current node variations\r\n    variationMarkup: true,\r\n    variationChildren: true,\r\n    variationSiblings: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\r\n\r\n    /**\r\n     * Helper to append board grid coordinatess to the broadcast event object\r\n     */\r\n    function processMouseEvent(broadcastEvent, mouseEvent) {\r\n\r\n      //Can only do this with a board and mouse event\r\n      if (!this.board || !mouseEvent) {\r\n        broadcastEvent.x = -1;\r\n        broadcastEvent.y = -1;\r\n        return;\r\n      }\r\n\r\n      //Init\r\n      var x = 0;\r\n      var y = 0;\r\n\r\n      //Set x\r\n      if (typeof mouseEvent.offsetX !== 'undefined') {\r\n        x = mouseEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.layerX;\r\n      }\r\n\r\n      //Set y\r\n      if (typeof mouseEvent.offsetY !== 'undefined') {\r\n        y = mouseEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.layerY;\r\n      }\r\n\r\n      //Apply pixel ratio factor\r\n      x *= (window.devicePixelRatio || 1);\r\n      y *= (window.devicePixelRatio || 1);\r\n\r\n      //Append coords\r\n      broadcastEvent.x = this.board.getGridX(x);\r\n      broadcastEvent.y = this.board.getGridY(y);\r\n\r\n      //Did we drag?\r\n      if (mouseEvent.drag) {\r\n        broadcastEvent.drag = mouseEvent.drag;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player class\r\n     */\r\n    var Player = {\r\n\r\n      //Player configuration\r\n      config: {},\r\n\r\n      //Board and game instances\r\n      board: null,\r\n      game: null,\r\n\r\n      //Available modes and tools\r\n      modes: {},\r\n      tools: [],\r\n\r\n      //Player mode and active tool\r\n      mode: '',\r\n      tool: '',\r\n\r\n      //Current path\r\n      path: null,\r\n\r\n      /**\r\n       * Initialization\r\n       */\r\n      init: function() {\r\n\r\n        //Unlink board instance, create new game\r\n        this.board = null;\r\n        this.game = new Game();\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Player mode and active tool\r\n        this.mode = '';\r\n        this.tool = '';\r\n\r\n        //Arrow keys / scroll wheel navigation\r\n        this.arrowKeysNavigation = false;\r\n        this.scrollWheelNavigation = false;\r\n\r\n        //Last move marker\r\n        this.lastMoveMarker = '';\r\n\r\n        //Variation markup\r\n        this.variationMarkup = false;\r\n        this.variationChildren = false;\r\n        this.variationSiblings = false;\r\n\r\n        //Restricted nodes\r\n        this.restrictNodeStart = null;\r\n        this.restrictNodeEnd = null;\r\n\r\n        //Parse config\r\n        this.parseConfig();\r\n      },\r\n\r\n      /**\r\n       * Link the player to a HTML element\r\n       */\r\n      linkElement: function(element) {\r\n\r\n        //Set element\r\n        this.element = element;\r\n\r\n        //Register document event\r\n        this.registerElementEvent('keydown', $document);\r\n\r\n        //Register element events\r\n        this.registerElementEvent('click');\r\n        this.registerElementEvent('mousedown');\r\n        this.registerElementEvent('mouseup');\r\n        this.registerElementEvent('mousemove');\r\n        this.registerElementEvent('mouseout');\r\n        this.registerElementEvent('mousewheel');\r\n        this.registerElementEvent('wheel');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Configuration\r\n       ***/\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.switchMode(this.config.mode);\r\n        this.switchTool(this.config.tool);\r\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\r\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\r\n        this.setLastMoveMarker(this.config.lastMoveMarker);\r\n        this.setVariationMarkup(\r\n          this.config.variationMarkup,\r\n          this.config.variationChildren,\r\n          this.config.variationSiblings\r\n        );\r\n\r\n        //Let the modes parse their config\r\n        for (var mode in this.modes) {\r\n          if (this.modes[mode].parseConfig) {\r\n            this.modes[mode].parseConfig.call(this, this.config);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set arrow keys navigation\r\n       */\r\n      setArrowKeysNavigation: function(arrowKeys) {\r\n        if (arrowKeys !== this.arrowKeysNavigation) {\r\n          this.arrowKeysNavigation = arrowKeys;\r\n          this.broadcast('settingChange', 'arrowKeysNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set scroll wheel navigation\r\n       */\r\n      setScrollWheelNavigation: function(scrollWheel) {\r\n        if (scrollWheel !== this.scrollWheelNavigation) {\r\n          this.scrollWheelNavigation = scrollWheel;\r\n          this.broadcast('settingChange', 'scrollWheelNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the last move marker\r\n       */\r\n      setLastMoveMarker: function(lastMoveMarker) {\r\n        if (lastMoveMarker !== this.lastMoveMarker) {\r\n          this.lastMoveMarker = lastMoveMarker;\r\n          this.broadcast('settingChange', 'lastMoveMarker');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set variation markup on the board\r\n       */\r\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\r\n\r\n        //One change event for these three settings\r\n        var change = false;\r\n\r\n        //Markup setting change?\r\n        if (variationMarkup !== this.variationMarkup) {\r\n          this.variationMarkup = variationMarkup;\r\n          change = true;\r\n        }\r\n\r\n        //Children setting change?\r\n        if (\r\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\r\n        ) {\r\n          this.variationChildren = variationChildren;\r\n          change = true;\r\n        }\r\n\r\n        //Siblings setting change?\r\n        if (\r\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\r\n        ) {\r\n          this.variationSiblings = variationSiblings;\r\n          change = true;\r\n        }\r\n\r\n        //Did anything change?\r\n        if (change) {\r\n          this.broadcast('settingChange', 'variationMarkup');\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Mode and tool handling\r\n       ***/\r\n\r\n      /**\r\n       * Register a player mode\r\n       */\r\n      registerMode: function(mode, PlayerMode) {\r\n\r\n        //Register the mode and let it parse the configuration\r\n        this.modes[mode] = PlayerMode;\r\n\r\n        //Parse config if we have a handler\r\n        if (this.modes[mode].parseConfig) {\r\n          this.modes[mode].parseConfig.call(this, this.config);\r\n        }\r\n\r\n        //Force switch the mode now, if it matches the initial mode\r\n        if (this.mode === mode) {\r\n          this.switchMode(this.mode, true);\r\n          this.switchTool(this.tool, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set available tools\r\n       */\r\n      setTools: function(tools) {\r\n        this.tools = tools || [PlayerTools.NONE];\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player mode\r\n       */\r\n      hasMode: function(mode) {\r\n        return this.modes[mode] ? true : false;\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player tool\r\n       */\r\n      hasTool: function(tool) {\r\n        return (this.tools.indexOf(tool) !== -1);\r\n      },\r\n\r\n      /**\r\n       * Switch player mode\r\n       */\r\n      switchMode: function(mode, force) {\r\n\r\n        //No change?\r\n        if (!force && (!mode || this.mode === mode)) {\r\n          return false;\r\n        }\r\n\r\n        //Broadcast mode exit\r\n        if (this.mode) {\r\n          this.broadcast('modeExit', this.mode);\r\n        }\r\n\r\n        //Set mode, reset tools and active tool\r\n        this.mode = mode;\r\n        this.tools = [];\r\n        this.tool = PlayerTools.NONE;\r\n\r\n        //Broadcast mode entry\r\n        this.broadcast('modeEnter', this.mode);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Switch player tool\r\n       */\r\n      switchTool: function(tool, force) {\r\n\r\n        //No change?\r\n        if (!force && (!tool || this.tool === tool)) {\r\n          return false;\r\n        }\r\n\r\n        //Validate tool switch (only when there is a mode)\r\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\r\n          return false;\r\n        }\r\n\r\n        //Change tool\r\n        this.tool = tool;\r\n        this.broadcast('toolSwitch', this.tool);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Save the full player state\r\n       */\r\n      saveState: function() {\r\n\r\n        //Save player state\r\n        this.playerState = {\r\n          mode: this.mode,\r\n          tool: this.tool,\r\n          restrictNodeStart: this.restrictNodeStart,\r\n          restrictNodeEnd: this.restrictNodeEnd\r\n        };\r\n\r\n        //Save game state\r\n        this.saveGameState();\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved player state\r\n       */\r\n      restoreState: function() {\r\n\r\n        //Must have player state\r\n        if (!this.playerState) {\r\n          return;\r\n        }\r\n\r\n        //Restore\r\n        this.switchMode(this.playerState.mode);\r\n        this.switchTool(this.playerState.tool);\r\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\r\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\r\n\r\n        //Restore game state\r\n        this.restoreGameState();\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game record handling\r\n       ***/\r\n\r\n      /**\r\n       * Load game record\r\n       */\r\n      load: function(data, allowPlayerConfig) {\r\n\r\n        //Try to load the game record data\r\n        try {\r\n          this.game.load(data);\r\n        }\r\n        catch (error) {\r\n          throw error;\r\n        }\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Parse configuration from JGF if allowed\r\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\r\n          this.parseConfig(this.game.get('settings'));\r\n        }\r\n\r\n        //Dispatch game loaded event\r\n        this.broadcast('gameLoaded', this.game);\r\n\r\n        //Board present?\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n\r\n        //Loaded ok\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Reload the existing game record\r\n       */\r\n      reload: function() {\r\n\r\n        //Must have game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reload game\r\n        this.game.reload();\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Save the current state\r\n       */\r\n      saveGameState: function() {\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.gameState = this.game.getState();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved state\r\n       */\r\n      restoreGameState: function() {\r\n\r\n        //Must have game and saved state\r\n        if (!this.game || !this.gameState) {\r\n          return;\r\n        }\r\n\r\n        //Restore state\r\n        this.game.restoreState(this.gameState);\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Navigation\r\n       ***/\r\n\r\n      /**\r\n       * Go to the next position\r\n       */\r\n      next: function(i) {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.next(i);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position\r\n       */\r\n      previous: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previous();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the last position\r\n       */\r\n      last: function() {\r\n        if (this.game) {\r\n          this.game.last();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the first position\r\n       */\r\n      first: function() {\r\n        if (this.game) {\r\n          this.game.first();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to a specific move number, tree path or named node\r\n       */\r\n      goto: function(target) {\r\n        if (this.game && target) {\r\n          this.game.goto(target);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the previous fork\r\n       */\r\n      previousFork: function() {\r\n        if (this.game) {\r\n          this.game.previousFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next fork\r\n       */\r\n      nextFork: function() {\r\n        if (this.game) {\r\n          this.game.nextFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next position with a comment\r\n       */\r\n      nextComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.nextComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position with a comment\r\n       */\r\n      previousComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previousComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restrict navigation to the current node\r\n       */\r\n      restrictNode: function(end) {\r\n\r\n        //Must have game and node\r\n        if (!this.game || !this.game.node) {\r\n          return;\r\n        }\r\n\r\n        //Restrict to current node\r\n        if (end) {\r\n          this.restrictNodeEnd = this.game.node;\r\n        }\r\n        else {\r\n          this.restrictNodeStart = this.game.node;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Process a new game position\r\n       */\r\n      processPosition: function() {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Get current node and game position\r\n        var node = this.game.getNode();\r\n        var path = this.game.getPath();\r\n        var position = this.game.getPosition();\r\n        var pathChanged = !path.compare(this.path);\r\n\r\n        //Update board\r\n        this.updateBoard(node, position, pathChanged);\r\n\r\n        //Path change?\r\n        if (pathChanged) {\r\n\r\n          //Copy new path and broadcast path change\r\n          this.path = path.clone();\r\n          this.broadcast('pathChange', node);\r\n\r\n          //Named node reached? Broadcast event\r\n          if (node.name) {\r\n            this.broadcast('reachedNode.' + node.name, node);\r\n          }\r\n        }\r\n\r\n        //Passed?\r\n        if (node.move && node.move.pass) {\r\n          this.broadcast('movePassed', node);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Show move numbers\r\n       */\r\n      showMoveNumbers: function(fromMove, toMove) {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Use sensible defaults if no from/to moves given\r\n        fromMove = fromMove || 1;\r\n        toMove = toMove || this.game.getMove();\r\n\r\n        //Get nodes for these moves\r\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\r\n        var move = fromMove;\r\n\r\n        //Loop nodes\r\n        angular.forEach(nodes, function(node) {\r\n          this.board.add('markup', node.move.x, node.move.y, {\r\n            type: MarkupTypes.LABEL,\r\n            text: move++\r\n          });\r\n        }, this);\r\n\r\n        //Redraw board markup\r\n        this.board.redraw('markup');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game handling\r\n       ***/\r\n\r\n      /**\r\n       * Start a new game\r\n       */\r\n      newGame: function() {\r\n        this.game = new Game();\r\n        this.processPosition();\r\n      },\r\n\r\n      /**\r\n       * Score the current game position\r\n       */\r\n      scoreGame: function() {\r\n\r\n        //Calculate score\r\n        GameScorer.calculate();\r\n\r\n        //Get score, points and captures\r\n        var score = GameScorer.getScore();\r\n        var points = GameScorer.getPoints();\r\n        var captures = GameScorer.getCaptures();\r\n\r\n        //Remove all markup, and set captures and points\r\n        this.board.layers.markup.removeAll();\r\n        this.board.layers.score.setAll(points, captures);\r\n\r\n        //Broadcast score\r\n        this.broadcast('scoreCalculated', score);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Board handling\r\n       ***/\r\n\r\n      /**\r\n       * Get the board\r\n       */\r\n      getBoard: function() {\r\n        return this.board;\r\n      },\r\n\r\n      /**\r\n       * Set the board\r\n       */\r\n      setBoard: function(Board) {\r\n\r\n        //Set the board\r\n        this.board = Board;\r\n\r\n        //Board ready\r\n        if (this.board) {\r\n          this.broadcast('boardReady', this.board);\r\n        }\r\n\r\n        //If a game has been loaded already, parse config and update the board\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Update the board\r\n       */\r\n      updateBoard: function(node, position, pathChanged) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Update board with new position\r\n        this.board.updatePosition(position, pathChanged);\r\n\r\n        //Mark last move\r\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\r\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\r\n        }\r\n\r\n        //Broadcast board update event\r\n        this.broadcast('boardUpdate', node);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Event handling\r\n       ***/\r\n\r\n      /**\r\n       * Register an element event\r\n       */\r\n      registerElementEvent: function(event, element) {\r\n\r\n        //Which element to use\r\n        if (typeof element === 'undefined' || !element.on) {\r\n          element = this.element;\r\n        }\r\n\r\n        //Remove any existing event listener and apply new one\r\n        //TODO: Namespacing events doesn't work with Angular's jqLite\r\n        element.off(event/* + '.ngGo.player'*/);\r\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\r\n      },\r\n\r\n      /**\r\n       * Event listener\r\n       */\r\n      on: function(type, listener, mode, $scope) {\r\n\r\n        //Must have valid listener\r\n        if (typeof listener !== 'function') {\r\n          console.warn('Listener is not a function:', listener);\r\n          return;\r\n        }\r\n\r\n        //Scope given as 3rd parameter?\r\n        if (mode && mode.$parent) {\r\n          $scope = mode;\r\n          mode = '';\r\n        }\r\n\r\n        //Multiple events?\r\n        if (type.indexOf(' ') !== -1) {\r\n          var types = type.split(' ');\r\n          for (var t = 0; t < types.length; t++) {\r\n            this.on(types[t], listener, mode, $scope);\r\n          }\r\n          return;\r\n        }\r\n\r\n        //Get self and determine scope to use\r\n        var self = this;\r\n        var scope = $scope || $rootScope;\r\n\r\n        //Create listener and return de-registration function\r\n        return scope.$on('ngGo.player.' + type, function() {\r\n\r\n          //Filter on mode\r\n          if (mode) {\r\n            if (\r\n              (typeof mode === 'string' && mode !== self.mode) ||\r\n              mode.indexOf(self.mode) === -1\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          //Inside a text field?\r\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\r\n            return;\r\n          }\r\n\r\n          //Append grid coordinates for mouse events\r\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\r\n            processMouseEvent.call(self, arguments[0], arguments[1]);\r\n          }\r\n\r\n          //Dragging? Prevent click events from firing\r\n          if (self.preventClickEvent && type === 'click') {\r\n            delete self.preventClickEvent;\r\n            return;\r\n          }\r\n          else if (type === 'mousedrag') {\r\n            self.preventClickEvent = true;\r\n          }\r\n\r\n          //Call listener\r\n          listener.apply(self, arguments);\r\n        });\r\n      },\r\n\r\n      /**\r\n       * Event broadcaster\r\n       */\r\n      broadcast: function(type, args) {\r\n\r\n        //Must have type\r\n        if (!type) {\r\n          return;\r\n        }\r\n\r\n        //Make sure we are in a digest cycle\r\n        if (!$rootScope.$$phase) {\r\n          $rootScope.$apply(function() {\r\n            $rootScope.$broadcast('ngGo.player.' + type, args);\r\n          });\r\n        }\r\n        else {\r\n          $rootScope.$broadcast('ngGo.player.' + type, args);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Initialize\r\n    Player.init();\r\n\r\n    //Return object\r\n    return Player;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\r\n * gridlines, starpoints and coordinates via the Coordinates class.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Coordinates.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\r\n\r\n  /**\r\n   * Helper for drawing starpoints\r\n   */\r\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\r\n\r\n    //Don't draw if it falls outsize of the board grid\r\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\r\n      return;\r\n    }\r\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\r\n      return;\r\n    }\r\n\r\n    //Get absolute coordinates and star point radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n\r\n    //Draw star point\r\n    this.context.beginPath();\r\n    this.context.fillStyle = starColor;\r\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GridLayer(board, context) {\r\n\r\n    //Set coordinates setting\r\n    this.coordinates = false;\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Show or hide the coordinates.\r\n   */\r\n  GridLayer.prototype.setCoordinates = function(show) {\r\n    this.coordinates = show;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Get all has nothing to return\r\n   */\r\n  GridLayer.prototype.getAll = function() {\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Set all has nothing to set\r\n   */\r\n  GridLayer.prototype.setAll = function(/*grid*/) {\r\n    return;\r\n  };\r\n\r\n  /**\r\n   * Remove all has nothing to remove\r\n   */\r\n  GridLayer.prototype.removeAll = function() {\r\n    return;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw method\r\n   */\r\n  GridLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Determine top x and y margin\r\n    var tx = this.board.drawMarginHor;\r\n    var ty = this.board.drawMarginVer;\r\n\r\n    //Get theme properties\r\n    var cellSize = this.board.getCellSize();\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\r\n    var lineCap = this.board.theme.get('grid.lineCap');\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Helper vars\r\n    var i, x, y;\r\n\r\n    //Draw vertical lines\r\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\r\n      x = this.board.getAbsX(i);\r\n      this.context.moveTo(x, ty);\r\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\r\n    }\r\n\r\n    //Draw horizontal lines\r\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\r\n      y = this.board.getAbsY(i);\r\n      this.context.moveTo(tx, y);\r\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\r\n    }\r\n\r\n    //Draw grid lines\r\n    this.context.stroke();\r\n\r\n    //Star points defined?\r\n    for (i = 0; i < starPoints.length; i++) {\r\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n\r\n    //Draw coordinates\r\n    if (this.coordinates) {\r\n      Coordinates.draw.call(this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Clear rectangle\r\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  /**\r\n   * Redraw a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', s);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n\r\n    //Determine draw coordinates\r\n    var x1 = (gridX === 0) ? x : x - r;\r\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\r\n    var y1 = (gridY === 0) ? y : y - r;\r\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Patch up grid lines\r\n    this.context.moveTo(x1, y);\r\n    this.context.lineTo(x2, y);\r\n    this.context.moveTo(x, y1);\r\n    this.context.lineTo(x, y2);\r\n    this.context.stroke();\r\n\r\n    //Check if we need to draw a star point here\r\n    for (var i in starPoints) {\r\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\r\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\r\n      }\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  //Return\r\n  return GridLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function HoverLayer(board, context) {\r\n\r\n    //Container for items to restore\r\n    this.restore = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add hover item\r\n   */\r\n  HoverLayer.prototype.add = function(x, y, hover) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Remove any previous item at this position\r\n    this.remove(x, y);\r\n\r\n    //Create hover object\r\n    hover.object = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Stones\r\n    if (hover.type === 'stones') {\r\n      hover.objectClass = StoneFaded;\r\n      hover.object.color = hover.value;\r\n    }\r\n\r\n    //Markup\r\n    else if (hover.type === 'markup') {\r\n      hover.objectClass = Markup;\r\n      if (typeof hover.value === 'object') {\r\n        hover.object = angular.extend(hover.object, hover.value);\r\n      }\r\n      else {\r\n        hover.object.type = hover.value;\r\n      }\r\n    }\r\n\r\n    //Unknown\r\n    else {\r\n      console.warn('Unknown hover type', hover.type);\r\n      return;\r\n    }\r\n\r\n    //Check if we need to hide something on layers underneath\r\n    if (this.board.has(hover.type, x, y)) {\r\n      this.restore.push({\r\n        x: x,\r\n        y: y,\r\n        layer: hover.type,\r\n        value: this.board.get(hover.type, x, y)\r\n      });\r\n      this.board.remove(hover.type, x, y);\r\n    }\r\n\r\n    //Add to stack\r\n    this.grid.set(x, y, hover);\r\n\r\n    //Draw item\r\n    if (hover.objectClass && hover.objectClass.draw) {\r\n      hover.objectClass.draw.call(this, hover.object);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove the hover object\r\n   */\r\n  HoverLayer.prototype.remove = function(x, y) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.has(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get object and clear it\r\n    var hover = this.grid.get(x, y);\r\n    if (hover.objectClass && hover.objectClass.clear) {\r\n      hover.objectClass.clear.call(this, hover.object);\r\n    }\r\n\r\n    //Other objects to restore?\r\n    for (var i = 0; i < this.restore.length; i++) {\r\n      if (this.restore[i].x === x && this.restore[i].y === y) {\r\n        this.board.add(\r\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n        );\r\n        this.restore.splice(i, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove all hover objects\r\n   */\r\n  HoverLayer.prototype.removeAll = function() {\r\n\r\n    //Anything to do?\r\n    if (this.grid.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    //Get all item as objects\r\n    var i;\r\n    var hover = this.grid.all('layer');\r\n\r\n    //Clear them\r\n    for (i = 0; i < hover.length; i++) {\r\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\r\n        hover[i].objectClass.clear.call(this, hover[i].object);\r\n      }\r\n    }\r\n\r\n    //Clear layer and empty grid\r\n    this.clear();\r\n    this.grid.empty();\r\n\r\n    //Restore objects on other layers\r\n    for (i = 0; i < this.restore.length; i++) {\r\n      this.board.add(\r\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n      );\r\n    }\r\n\r\n    //Clear restore array\r\n    this.restore = [];\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  HoverLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Loop objects and clear them\r\n    var hover = this.grid.all('hover');\r\n    for (var i = 0; i < hover.length; i++) {\r\n      if (hover.objectClass && hover.objectClass.draw) {\r\n        hover.objectClass.draw.call(this, hover.object);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return HoverLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function MarkupLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all markup at once\r\n   */\r\n  MarkupLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'type');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Markup.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Markup.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  MarkupLayer.prototype.removeAll = function() {\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Clear them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.clear.call(this, markup[i]);\r\n    }\r\n\r\n    //Empty the grid now\r\n    this.grid.empty();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  MarkupLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.draw.call(this, markup[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  MarkupLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  MarkupLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return MarkupLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ScoreLayer(board, context) {\r\n\r\n    //Points and captures\r\n    this.points = [];\r\n    this.captures = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set points and captures\r\n   */\r\n  ScoreLayer.prototype.setAll = function(points, captures) {\r\n\r\n    //Remove all existing stuff first\r\n    this.removeAll();\r\n\r\n    //Set new stuff\r\n    this.points = points.all('color');\r\n    this.captures = captures.all('color');\r\n\r\n    //Draw\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Remove all scoring\r\n   */\r\n  ScoreLayer.prototype.removeAll = function() {\r\n\r\n    //If there are captures, draw them back onto the stones layer\r\n    for (var i = 0; i < this.captures.length; i++) {\r\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\r\n    }\r\n\r\n    //Clear the layer\r\n    this.clear();\r\n\r\n    //Remove all stuff\r\n    this.points = [];\r\n    this.captures = [];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ScoreLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Init\r\n    var i;\r\n\r\n    //Draw captures first (removing stones from the stones layer)\r\n    for (i = 0; i < this.captures.length; i++) {\r\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\r\n      StoneFaded.draw.call(this, this.captures[i]);\r\n    }\r\n\r\n    //Draw points on top of it\r\n    for (i = 0; i < this.points.length; i++) {\r\n      StoneMini.draw.call(this, this.points[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ScoreLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneShadow.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ShadowLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add a stone\r\n   */\r\n  ShadowLayer.prototype.add = function(stone) {\r\n\r\n    //Don't add if no shadow\r\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\r\n      return;\r\n    }\r\n\r\n    //Already have a stone here?\r\n    if (this.grid.has(stone.x, stone.y)) {\r\n      return;\r\n    }\r\n\r\n    //Add to grid\r\n    this.grid.set(stone.x, stone.y, stone.color);\r\n\r\n    //Draw it if there is a context\r\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\r\n      StoneShadow.draw.call(this, stone);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove a stone\r\n   */\r\n  ShadowLayer.prototype.remove = function(stone) {\r\n\r\n    //Remove from grid\r\n    this.grid.unset(stone.x, stone.y);\r\n\r\n    //Redraw whole layer\r\n    this.redraw();\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ShadowLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get shadowsize from theme\r\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\r\n\r\n    //Apply shadow transformation\r\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      StoneShadow.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ShadowLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function StonesLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n\r\n    //Set empty value for grid\r\n    this.grid.whenEmpty(StoneColor.EMPTY);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all stones at once\r\n   */\r\n  StonesLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'color');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Stone.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Stone.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  StonesLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      Stone.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  StonesLayer.prototype.redraw = function() {\r\n\r\n    //Clear shadows layer\r\n    this.board.removeAll('shadow');\r\n\r\n    //Redraw ourselves\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  StonesLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  StonesLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StonesLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Coordinates :: This class is used for drawing board coordinates\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Coordinates.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Coordinates', function() {\r\n\r\n  //Kanji\r\n  var kanji = [\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', ''\r\n  ];\r\n\r\n  //Character codes\r\n  var aChar = 'A'.charCodeAt(0);\r\n  var aCharLc = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Coordinate generators\r\n   */\r\n  var coordinates = {\r\n\r\n    //Kanji coordinates\r\n    kanji: function(i) {\r\n      return kanji[i] || '';\r\n    },\r\n\r\n    //Numbers from 1\r\n    numbers: function(i) {\r\n      return i + 1;\r\n    },\r\n\r\n    //Capital letters from A\r\n    letters: function(i) {\r\n\r\n      //Initialize\r\n      var ch = '';\r\n\r\n      //Beyond Z? Prepend with A\r\n      if (i >= 25) {\r\n        ch = 'A';\r\n        i -= 25;\r\n      }\r\n\r\n      //The letter I is ommitted\r\n      if (i >= 8) {\r\n        i++;\r\n      }\r\n\r\n      //Return\r\n      return ch + String.fromCharCode(aChar + i);\r\n    },\r\n\r\n    //JGF coordinates (e.g. 0, 1, ...)\r\n    jgf: function(i) {\r\n      return i;\r\n    },\r\n\r\n    //SGF coordinates (e.g. a, b, ...)\r\n    sgf: function(i) {\r\n      var ch;\r\n      if (i < 26) {\r\n        ch = aCharLc + i;\r\n      }\r\n      else {\r\n        ch = aChar + i;\r\n      }\r\n      return String.fromCharCode(ch);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Coordinates object\r\n   */\r\n  var Coordinates = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function() {\r\n\r\n      //Can only draw when we have context and dimensions\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Get cell size\r\n      var cellSize = this.board.getCellSize();\r\n\r\n      //Get boundary coordinates\r\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\r\n      var xr = this.board.drawWidth - xl;\r\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\r\n      var yb = this.board.drawHeight - yt;\r\n\r\n      //Get theme properties\r\n      var fillStyle = this.board.theme.get('coordinates.color');\r\n      var vertical = {\r\n        font: this.board.theme.get('coordinates.vertical.font'),\r\n        size: this.board.theme.get('coordinates.vertical.size'),\r\n        style: this.board.theme.get('coordinates.vertical.style'),\r\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\r\n      };\r\n      var horizontal = {\r\n        font: this.board.theme.get('coordinates.horizontal.font'),\r\n        size: this.board.theme.get('coordinates.horizontal.size'),\r\n        style: this.board.theme.get('coordinates.horizontal.style'),\r\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\r\n      };\r\n\r\n      //Configure context\r\n      this.context.fillStyle = fillStyle;\r\n      this.context.textBaseline = 'middle';\r\n      this.context.textAlign = 'center';\r\n\r\n      //Helper vars\r\n      var i, j, x, y, ch;\r\n\r\n      //Draw vertical coordinates\r\n      for (i = 0; i < this.board.height; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (vertical.inverse) {\r\n          j = this.board.height - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof vertical.style === 'function') {\r\n          ch = vertical.style.call(this, j);\r\n        }\r\n        else if (coordinates[vertical.style]) {\r\n          ch = coordinates[vertical.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        y = this.board.getAbsY(i);\r\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\r\n        this.context.fillText(ch, xl, y);\r\n        this.context.fillText(ch, xr, y);\r\n      }\r\n\r\n      //Draw horizontal coordinates\r\n      for (i = 0; i < this.board.width; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (horizontal.inverse) {\r\n          j = this.board.width - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof horizontal.style === 'function') {\r\n          ch = horizontal.style.call(this, j);\r\n        }\r\n        else if (coordinates[horizontal.style]) {\r\n          ch = coordinates[horizontal.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        x = this.board.getAbsX(i);\r\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\r\n        this.context.fillText(ch, x, yt);\r\n        this.context.fillText(ch, x, yb);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Coordinates;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Markup :: This class is used for drawing markup\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Markup.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\r\n\r\n  /**\r\n   * Math constants\r\n   */\r\n  var cosPi4 = Math.cos(Math.PI / 4);\r\n  var cosPi6 = Math.cos(Math.PI / 6);\r\n\r\n  /**\r\n   * Triangle draw handler\r\n   */\r\n  function drawTriangle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y - r);\r\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.closePath();\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Square draw handler\r\n   */\r\n  function drawSquare(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw circle handler\r\n   */\r\n  function drawCircle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw mark handler\r\n   */\r\n  function drawMark(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - rcos, y - rcos);\r\n    this.context.lineTo(x + rcos, y + rcos);\r\n    this.context.moveTo(x + rcos, y - rcos);\r\n    this.context.lineTo(x - rcos, y + rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw select handler\r\n   */\r\n  function drawSelect(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Last move draw handler\r\n   */\r\n  function drawLast(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y);\r\n    this.context.lineTo(x + r, y);\r\n    this.context.lineTo(x, y + r);\r\n    this.context.closePath();\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw happy smiley handler\r\n   */\r\n  function drawHappySmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 8);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw sad smiley handler\r\n   */\r\n  function drawSadSmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw label\r\n   */\r\n  function drawLabel(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //First, clear grid square below for clarity\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.clearCell(markup.x, markup.y);\r\n    }\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.textBaseline = 'middle';\r\n    this.context.textAlign = 'center';\r\n\r\n    //Convert to text\r\n    if (typeof markup.text === 'number') {\r\n      markup.text = markup.text.toString();\r\n    }\r\n\r\n    //Determine font size\r\n    if (markup.text.length === 1) {\r\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\r\n    }\r\n    else if (markup.text.length === 2) {\r\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\r\n    }\r\n    else {\r\n      this.context.font = r + 'px ' + font;\r\n    }\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.fillText(markup.text, x, y, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Clear label\r\n   */\r\n  function clearLabel(markup) {\r\n\r\n    //No stone on location? Redraw the grid square, if we cleared it\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup class\r\n   */\r\n  var Markup = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Drawing depends on type\r\n      switch (markup.type) {\r\n\r\n        //Triangle\r\n        case MarkupTypes.TRIANGLE:\r\n          drawTriangle.call(this, markup);\r\n          break;\r\n\r\n        //Square\r\n        case MarkupTypes.SQUARE:\r\n          drawSquare.call(this, markup);\r\n          break;\r\n\r\n        //Circle\r\n        case MarkupTypes.CIRCLE:\r\n          drawCircle.call(this, markup);\r\n          break;\r\n\r\n        //Mark\r\n        case MarkupTypes.MARK:\r\n          drawMark.call(this, markup);\r\n          break;\r\n\r\n        //Select\r\n        case MarkupTypes.SELECT:\r\n          drawSelect.call(this, markup);\r\n          break;\r\n\r\n        //happy\r\n        case MarkupTypes.HAPPY:\r\n          drawHappySmiley.call(this, markup);\r\n          break;\r\n\r\n        //Sad\r\n        case MarkupTypes.SAD:\r\n          drawSadSmiley.call(this, markup);\r\n          break;\r\n\r\n        //Last move marker\r\n        case MarkupTypes.LAST:\r\n          drawLast.call(this, markup);\r\n          break;\r\n\r\n        //Label\r\n        case MarkupTypes.LABEL:\r\n          markup.text = markup.text || '';\r\n          drawLabel.call(this, markup);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear\r\n     */\r\n    clear: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, markup);\r\n\r\n      //Special handling for label\r\n      if (markup.type === MarkupTypes.LABEL) {\r\n        clearLabel.call(this, markup);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Markup;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Stone :: This class is used for drawing stones on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Stone.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service',\r\n  'ngGo.Board.ShellPattern.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\r\n\r\n  /**\r\n   * Shell random seed\r\n   */\r\n  var shellSeed;\r\n\r\n  /**\r\n   * Mono colored stones\r\n   */\r\n  function drawMono(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Don't draw shadow\r\n    stone.shadow = false;\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\r\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Configure context\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Draw outline\r\n    this.context.stroke();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Glass stones\r\n   */\r\n  function drawGlass(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Begin path\r\n    this.context.beginPath();\r\n\r\n    //Determine stone texture\r\n    if (color === StoneColor.W) {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#fff');\r\n      this.context.fillStyle.addColorStop(1, '#aaa');\r\n    }\r\n    else {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#666');\r\n      this.context.fillStyle.addColorStop(1, '#111');\r\n    }\r\n\r\n    //Complete drawing\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Slate and shell stones\r\n   */\r\n  function drawSlateShell(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Get random seed\r\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var shellTypes = this.board.theme.get('stone.shell.types');\r\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.fill();\r\n\r\n    //Shell stones\r\n    if (color === StoneColor.W) {\r\n\r\n      //Get random shell type\r\n      var type =\r\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\r\n\r\n      //Determine random angle\r\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\r\n      var angle = (2 / z) * (shellSeed % z);\r\n\r\n      //Draw shell pattern\r\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Slate stones\r\n    else {\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var Stone = {\r\n\r\n    /**\r\n     * Draw a stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Determine style of stone\r\n      var style = this.board.theme.get('stone.style');\r\n\r\n      //Draw using the appropriate handler\r\n      switch (style) {\r\n\r\n        //Slate and shell\r\n        case 'shell':\r\n          drawSlateShell.call(this, stone);\r\n          break;\r\n\r\n        //Glass stones\r\n        case 'glass':\r\n          drawGlass.call(this, stone);\r\n          break;\r\n\r\n        //Mono stones\r\n        case 'mono':\r\n          drawMono.call(this, stone);\r\n          break;\r\n\r\n        //Custom type\r\n        default:\r\n          var handler = $injector.get(style);\r\n          if (handler) {\r\n            handler.call(this, stone);\r\n          }\r\n      }\r\n\r\n      //Add shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.add(stone);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear a stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, stone);\r\n\r\n      //Remove shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.remove(stone);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Stone;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneFaded', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneFaded = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.faded.scale');\r\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneFaded;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\r\n * (for scoring).\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneMini.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneMini', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneMini = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.mini.scale');\r\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneMini;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneShadow :: This class is used for drawing stone shadows on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneShadow', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var StoneShadow = {\r\n\r\n    /**\r\n     * Draw a stone shadow\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\r\n\r\n      //Apply scaling factor?\r\n      if (stone.scale) {\r\n        r = Math.round(r * stone.scale);\r\n      }\r\n\r\n      //Get theme properties\r\n      var blur = this.board.theme.get('shadow.blur', s);\r\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\r\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\r\n      var shadowColor = this.board.theme.get('shadow.color');\r\n\r\n      //Configure context\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\r\n      );\r\n      this.context.fillStyle.addColorStop(0, shadowColor);\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n\r\n      //Draw shadow\r\n      this.context.beginPath();\r\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    },\r\n\r\n    /**\r\n     * Clear a stone shadow\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Note: this method is currently not in use due to the overlapping shadows\r\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\r\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\r\n      //appropriate either, so for now we will leave it at this.\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = this.board.theme.get('stone.radius', s);\r\n\r\n      //Clear a generous rectangle\r\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneShadow;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeCommon :: This class governs common event handling of the player shared by\r\n * various player modes. It's basically an abstract player mode and it can't be actively set.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Common.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Run block\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\r\n\r\n  /**\r\n   * Register common event handlers\r\n   */\r\n  Player.on('keydown', PlayerModeCommon.keyDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n}])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\r\n\r\n  /**\r\n   * Helper to build drag object\r\n   */\r\n  function dragObject(event) {\r\n\r\n    //Initialize drag object\r\n    var drag = {\r\n      start: {\r\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\r\n      },\r\n      stop: {\r\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\r\n      }\r\n    };\r\n\r\n    //Fix boundaries\r\n    if (drag.start.x < 0) {\r\n      drag.start.x = 0;\r\n    }\r\n    if (drag.start.y < 0) {\r\n      drag.start.y = 0;\r\n    }\r\n    if (drag.stop.x > this.board.width - 1) {\r\n      drag.stop.x = this.board.width - 1;\r\n    }\r\n    if (drag.stop.y > this.board.height - 1) {\r\n      drag.stop.y = this.board.height - 1;\r\n    }\r\n\r\n    //Return\r\n    return drag;\r\n  }\r\n\r\n  /**\r\n   * Normalize the mousewheel event helper\r\n   */\r\n  function normalizeMousewheelEvent(event) {\r\n\r\n    //Initialize vars\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n\r\n    //Old school scrollwheel delta\r\n    if ('detail' in event) {\r\n      deltaY = event.detail * -1;\r\n    }\r\n    if ('wheelDelta' in event) {\r\n      deltaY = event.wheelDelta;\r\n    }\r\n    if ('wheelDeltaY' in event) {\r\n      deltaY = event.wheelDeltaY;\r\n    }\r\n    if ('wheelDeltaX' in event) {\r\n      deltaX = event.wheelDeltaX * -1;\r\n    }\r\n\r\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\r\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n      deltaX = deltaY * -1;\r\n      deltaY = 0;\r\n    }\r\n\r\n    //New type wheel delta (WheelEvent)\r\n    if ('deltaY' in event) {\r\n      deltaY = event.deltaY * -1;\r\n    }\r\n    if ('deltaX' in event) {\r\n      deltaX = event.deltaX;\r\n    }\r\n\r\n    //Set in event (have to use different property name because of strict mode)\r\n    event.mouseWheelX = deltaX;\r\n    event.mouseWheelY = deltaY;\r\n\r\n    //Return\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Player extension\r\n   */\r\n  angular.extend(Player, {\r\n\r\n    /**\r\n     * Mouse coordinate helper vars\r\n     */\r\n    mouse: {\r\n\r\n      //Drag start\r\n      dragStart: null,\r\n\r\n      //Last grid coordinates\r\n      lastX: -1,\r\n      lastY: -1\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Player mode definition\r\n   */\r\n  var PlayerMode = {\r\n\r\n    /**\r\n     * Handler for keydown events\r\n     */\r\n    keyDown: function(event, keyboardEvent) {\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Switch key code\r\n      switch (keyboardEvent.keyCode) {\r\n\r\n        //ESC\r\n        case KeyCodes.ESC:\r\n\r\n          //Cancel drag event, and prevent click event as well\r\n          this.mouse.dragStart = null;\r\n          this.preventClickEvent = true;\r\n          break;\r\n\r\n        //Right arrow\r\n        case KeyCodes.RIGHT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Advance to the next move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\r\n              this.next();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Left arrow\r\n        case KeyCodes.LEFT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Go to the previous move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\r\n              this.previous();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Up arrow\r\n        case KeyCodes.UP:\r\n          break;\r\n\r\n        //Down arrow\r\n        case KeyCodes.DOWN:\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handler for mousewheel events\r\n     */\r\n    mouseWheel: function(event, mouseEvent) {\r\n\r\n      //Disabled or not using move tool?\r\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\r\n        return true;\r\n      }\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return true;\r\n      }\r\n\r\n      //Normalize mousewheel event\r\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\r\n\r\n      //Find delta\r\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\r\n\r\n      //Next move\r\n      if (delta < 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.next();\r\n      }\r\n\r\n      //Previous move\r\n      else if (delta > 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.previous();\r\n      }\r\n\r\n      //Don't scroll the window\r\n      if (delta !== 0) {\r\n        mouseEvent.preventDefault();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse out handler\r\n     */\r\n    mouseOut: function() {\r\n      if (this.board) {\r\n        this.board.removeAll('hover');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse move handler\r\n     */\r\n    mouseMove: function(event, mouseEvent) {\r\n\r\n      //Attach drag object to events\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n      }\r\n\r\n      //Nothing else to do?\r\n      if (!this.board || !this.board.layers.hover) {\r\n        return;\r\n      }\r\n\r\n      //Last coordinates are the same?\r\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\r\n        return;\r\n      }\r\n\r\n      //Remember last coordinates\r\n      this.mouse.lastX = event.x;\r\n      this.mouse.lastY = event.y;\r\n\r\n      //Broadcast hover event\r\n      this.broadcast('hover', mouseEvent);\r\n    },\r\n\r\n    /**\r\n     * Mouse down handler\r\n     */\r\n    mouseDown: function(event) {\r\n      this.mouse.dragStart = {\r\n        x: event.x,\r\n        y: event.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Mouse up handler\r\n     */\r\n    mouseUp: function(event, mouseEvent) {\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n        this.broadcast('mousedrag', mouseEvent);\r\n      }\r\n      this.mouse.dragStart = null;\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return PlayerMode;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\r\n * a game record and its board positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Edit.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Setup tools\r\n */\r\n.constant('SetupTools', {\r\n  BLACK: 'black',\r\n  WHITE: 'white',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Markup tools\r\n */\r\n.constant('MarkupTools', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy',\r\n  TEXT: 'text',\r\n  NUMBER: 'number',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\r\n\r\n  //Register event handlers\r\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\r\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\r\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\r\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\r\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\r\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\r\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeEdit', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\r\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\r\n  ) {\r\n\r\n    //Character codes\r\n    var aChar = 'A'.charCodeAt(0);\r\n    var aCharLc = 'a'.charCodeAt(0);\r\n\r\n    /**\r\n     * Update hover mark at specific coordinates\r\n     */\r\n    function updateHoverMark(x, y, isDrag) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Setup tool\r\n        case PlayerTools.SETUP:\r\n\r\n          //Clear tool\r\n          if (this.setupTool === SetupTools.CLEAR) {\r\n\r\n            //Stone present? Can remove it\r\n            if (this.game.hasStone(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Stone color tool\r\n          else {\r\n\r\n            //Add or overwrite stone if no stone present of the given color\r\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'stones',\r\n                value: this.setupToolColor()\r\n              });\r\n            }\r\n\r\n            //Stone present of same color? Can remove it if we're not dragging\r\n            else if (!isDrag) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Markup tool\r\n        case PlayerTools.MARKUP:\r\n\r\n          //Clear tool, or already markup in place?\r\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\r\n            if (this.game.hasMarkup(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Text or number\r\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: {\r\n                type: MarkupTypes.LABEL,\r\n                text: this.markupLabel\r\n              }\r\n            });\r\n          }\r\n\r\n          //Other markup\r\n          else {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: this.markupTool\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set markup\r\n     */\r\n    function setMarkup(x, y) {\r\n\r\n      //Already markup in place? Remove it first\r\n      if (this.game.hasMarkup(x, y)) {\r\n\r\n        //Check what markup there is\r\n        var markup = this.game.getMarkup(x, y);\r\n\r\n        //Label? Also remove from our labels list\r\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\r\n          var i = this.markupLabels.indexOf(markup.text);\r\n          if (i !== -1) {\r\n            this.markupLabels.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        //Remove from game\r\n        this.game.removeMarkup(x, y);\r\n        return;\r\n      }\r\n\r\n      //Clear tool used? Done\r\n      if (this.markupTool === MarkupTools.CLEAR) {\r\n        return;\r\n      }\r\n\r\n      //Text\r\n      else if (this.markupTool === MarkupTools.TEXT) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next text label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Number\r\n      else if (this.markupTool === MarkupTools.NUMBER) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next number label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Other markup\r\n      else {\r\n        this.game.addMarkup(x, y, this.markupTool);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set a stone\r\n     */\r\n    function setStone(x, y, isDrag) {\r\n\r\n      //Get the stone color\r\n      var color = this.setupToolColor();\r\n\r\n      //Trying to remove a stone\r\n      if (color === StoneColor.EMPTY) {\r\n        this.game.removeStone(x, y);\r\n      }\r\n\r\n      //Adding a stone\r\n      else {\r\n\r\n        //A stone there already of the same color? Just remove if not dragging\r\n        if (!isDrag && this.game.hasStone(x, y, color)) {\r\n          this.game.removeStone(x, y);\r\n          return;\r\n        }\r\n\r\n        //Any stone present?\r\n        else if (this.game.hasStone(x, y)) {\r\n          this.game.removeStone(x, y);\r\n        }\r\n\r\n        //Add stone now\r\n        this.game.addStone(x, y, color);\r\n      }\r\n\r\n      //Redraw markup\r\n      this.board.layers.markup.redrawCell(x, y);\r\n    }\r\n\r\n    /**\r\n     * Find all markup labels in current position\r\n     */\r\n    function findAllMarkupLabels() {\r\n\r\n      //Clear\r\n      this.markupLabels = [];\r\n\r\n      //Must have game\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get all markup from position\r\n      var markup = this.game.position.markup.all('type');\r\n      for (var i = 0; i < markup.length; i++) {\r\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\r\n          this.markupLabels.push(markup[i].text);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Active setup tool and markup tool\r\n      setupTool: SetupTools.BLACK,\r\n      markupTool: MarkupTools.TRIANGLE,\r\n\r\n      //Current markup labels on the board and current markup label\r\n      markupLabels: [],\r\n      markupLabel: '',\r\n\r\n      /**\r\n       * Set the setup tool\r\n       */\r\n      switchSetupTool: function(tool) {\r\n        this.setupTool = tool;\r\n      },\r\n\r\n      /**\r\n       * Set the markup tool\r\n       */\r\n      switchMarkupTool: function(tool) {\r\n        this.markupTool = tool;\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          this.determineMarkupLabel();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Conversion of setup tool to stone color\r\n       */\r\n      setupToolColor: function() {\r\n        switch (this.setupTool) {\r\n          case SetupTools.BLACK:\r\n            return StoneColor.B;\r\n          case SetupTools.WHITE:\r\n            return StoneColor.W;\r\n          default:\r\n            return StoneColor.EMPTY;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the new text markup label\r\n       */\r\n      setMarkupLabel: function(label) {\r\n        if (label) {\r\n          this.markupLabel = label;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Determine the new text markup label\r\n       */\r\n      determineMarkupLabel: function() {\r\n\r\n        //Clear\r\n        this.markupLabel = '';\r\n\r\n        //Check what tool we're using\r\n        switch (this.markupTool) {\r\n\r\n          //Text tool?\r\n          case MarkupTools.TEXT:\r\n            var i = 0;\r\n\r\n            //Loop while the label is present\r\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n\r\n              //A-Z\r\n              if (i < 26) {\r\n                this.markupLabel = String.fromCharCode(aChar + i);\r\n              }\r\n\r\n              //a-z\r\n              else if (i < 52) {\r\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\r\n              }\r\n\r\n              //AA, AB, AC, etc.\r\n              else {\r\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\r\n                  String.fromCharCode(aChar + (i % 26));\r\n              }\r\n\r\n              //Keep going\r\n              i++;\r\n            }\r\n            break;\r\n\r\n          //Number tool?\r\n          case MarkupTools.NUMBER:\r\n            this.markupLabel = 0;\r\n\r\n            //Loop while the label is present\r\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n              this.markupLabel++;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeEdit = {\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items\r\n        this.board.removeAll('hover');\r\n\r\n        //Single coordinate?\r\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //No dragging for labels\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //Loop area\r\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n            updateHoverMark.call(this, x, y, true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Keydown handler\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //TODO: tool switching via keyboard input\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Click handler\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        this.board.removeAll('hover');\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Try to play the move\r\n            if (!this.game.play(event.x, event.y)) {\r\n              return;\r\n            }\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Set stone and update board\r\n            setStone.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Set markup and update board\r\n            setMarkup.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Mouse drag handler\r\n       */\r\n      mouseDrag: function(event) {\r\n\r\n        //Initialize vars\r\n        var x, y;\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setStone.call(this, x, y, true);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Don't do this for labels\r\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n              break;\r\n            }\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setMarkup.call(this, x, y);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change\r\n       */\r\n      pathChange: function() {\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SETUP,\r\n          PlayerTools.MARKUP,\r\n          PlayerTools.SCORE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Find all markup labels in the current game position\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeEdit;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\r\n * through an existing game record without the ability to deviate from the tree or its variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Replay.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\r\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\r\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\r\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\r\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\r\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\r\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\r\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\r\n\r\n  //Register the mode\r\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeReplay', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Auto play delay\r\n    autoPlayDelay: 1000\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show move variations on the board\r\n     */\r\n    function showMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n\r\n        //Auto variation markup should never overwrite existing markup\r\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\r\n          continue;\r\n        }\r\n\r\n        //Add to board\r\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n          type: this.board.theme.get('markup.variation.type'),\r\n          text: this.board.theme.get('markup.variation.text', i),\r\n          color: this.board.theme.get('markup.variation.color')\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide move variations from the board\r\n     */\r\n    function hideMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) move variations on the board\r\n     */\r\n    function drawMoveVariations(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get the current node\r\n      var node = this.game.getNode();\r\n      var variations;\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      //Child variations?\r\n      if (this.variationChildren && node.hasMoveVariations()) {\r\n        variations = node.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n\r\n      //Sibling variations?\r\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\r\n        variations = node.parent.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Auto play vars\r\n      autoPlaying: false,\r\n      autoPlayDelay: 1000,\r\n      autoPlayPromise: null,\r\n\r\n      /**\r\n       * Set auto play delay\r\n       */\r\n      setAutoPlayDelay: function(delay) {\r\n        if (this.autoPlayDelay !== delay) {\r\n          this.autoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'autoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Start auto play with a given delay\r\n       */\r\n      start: function(delay) {\r\n\r\n        //Not in replay mode or already auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Already auto playing, no game or no move children?\r\n        if (!this.game || !this.game.node.hasChildren()) {\r\n          return;\r\n        }\r\n\r\n        //Get self\r\n        var self = this;\r\n\r\n        //Determine delay\r\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\r\n\r\n        //Switch tool\r\n        this.switchTool(PlayerTools.NONE);\r\n\r\n        //Create interval\r\n        this.autoPlaying = true;\r\n        this.autoPlayPromise = $interval(function() {\r\n\r\n          //Advance to the next node\r\n          self.next(0, true);\r\n\r\n          //Ran out of children?\r\n          if (!self.game.node.hasChildren()) {\r\n            self.stop();\r\n          }\r\n        }, delay);\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStarted', this.game.node);\r\n      },\r\n\r\n      /**\r\n       * Stop auto play\r\n       */\r\n      stop: function() {\r\n\r\n        //Not in replay mode or not auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Cancel interval\r\n        if (this.autoPlayPromise) {\r\n          $interval.cancel(this.autoPlayPromise);\r\n        }\r\n\r\n        //Clear flags\r\n        this.autoPlayPromise = null;\r\n        this.autoPlaying = false;\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStopped', this.game.node);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeReplay = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'variationMarkup') {\r\n          drawMoveVariations.call(this, this.variationMarkup);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Check if we clicked a move variation, advance to the next position if so\r\n            if (this.game.isMoveVariation(event.x, event.y)) {\r\n              this.next(this.game.getMoveVariation(event.x, event.y));\r\n            }\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeReplay.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SCORE,\r\n          PlayerTools.NONE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Stop auto playing\r\n        if (this.autoPlaying) {\r\n          this.stop();\r\n        }\r\n\r\n        //Hide move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, false);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeReplay;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\r\n * go problems and finding the right move or variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Solve.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\r\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\r\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\r\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\r\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\r\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\r\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\r\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Player color\r\n    playerColor: StoneColor.B,\r\n\r\n    //Show solution paths\r\n    solutionPaths: false,\r\n\r\n    //Auto play settings\r\n    solveAutoPlay: true,\r\n    solveAutoPlayDelay: 500\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\r\n\r\n    /**\r\n     * Check if we can make a move\r\n     */\r\n    function canMakeMove() {\r\n\r\n      //We can make a move when...\r\n\r\n      //...there is no auto play going on\r\n      if (!this.solveAutoPlay) {\r\n        return true;\r\n      }\r\n\r\n      //...we solved the puzzle already\r\n      if (this.problemSolved) {\r\n        return true;\r\n      }\r\n\r\n      //...we are off path\r\n      if (this.problemOffPath) {\r\n        return true;\r\n      }\r\n\r\n      //...it's our turn\r\n      if (this.game.getTurn() === this.playerColor) {\r\n        return true;\r\n      }\r\n\r\n      //Otherwise, we can't make a move\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show solution paths\r\n     */\r\n    function showSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        if (variations[i].solution === true) {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.valid.type'),\r\n            text: this.board.theme.get('markup.solution.valid.text', i),\r\n            scale: this.board.theme.get('markup.solution.valid.scale'),\r\n            color: this.board.theme.get('markup.solution.valid.color')\r\n          });\r\n        }\r\n        else {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.invalid.type'),\r\n            text: this.board.theme.get('markup.solution.invalid.text', i),\r\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\r\n            color: this.board.theme.get('markup.solution.invalid.color')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide solution paths\r\n     */\r\n    function hideSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) solution paths\r\n     */\r\n    function drawSolutionPaths(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get node and variations\r\n      var node = this.game.getNode();\r\n      var variations = node.getMoveVariations();\r\n\r\n      //When showing, make sure it's not during the auto solver's move\r\n      if (show && !this.problemSolved && this.solveAutoPlay) {\r\n        if (this.game.getTurn() !== this.playerColor) {\r\n          hideSolutionPaths.call(this, variations);\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Call helper\r\n      if (show) {\r\n        showSolutionPaths.call(this, variations);\r\n      }\r\n      else {\r\n        hideSolutionPaths.call(this, variations);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Solved and off-path flags\r\n      problemSolved: false,\r\n      problemOffPath: false,\r\n\r\n      //Problem start path\r\n      problemStartPath: null,\r\n\r\n      //The player color\r\n      playerColor: 0,\r\n\r\n      //Solution paths\r\n      solutionPaths: false,\r\n\r\n      //Auto play vars\r\n      solveAutoPlay: true,\r\n      solveAutoPlayDelay: 500,\r\n\r\n      //Navigation blocked flag\r\n      solveNavigationBlocked: false,\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlay: function(autoPlay) {\r\n        if (this.solveAutoPlay !== autoPlay) {\r\n          this.solveAutoPlay = autoPlay;\r\n          this.broadcast('settingChange', 'solveAutoPlay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlayDelay: function(delay) {\r\n        if (this.solveAutoPlayDelay !== delay) {\r\n          this.solveAutoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set player color\r\n       */\r\n      setPlayerColor: function(color) {\r\n        if (this.playerColor !== color) {\r\n          this.playerColor = color;\r\n          this.broadcast('settingChange', 'playerColor');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Get player color\r\n       */\r\n      getPlayerColor: function(asOnBoard) {\r\n        if (asOnBoard && this.board) {\r\n          return this.board.colorMultiplier * this.playerColor;\r\n        }\r\n        return this.playerColor;\r\n      },\r\n\r\n      /**\r\n       * Toggle solution paths\r\n       */\r\n      toggleSolutionPaths: function(solutionPaths) {\r\n\r\n        //Toggle if not given\r\n        if (typeof solutionPaths === 'undefined') {\r\n          solutionPaths = !this.solutionPaths;\r\n        }\r\n\r\n        //Change?\r\n        if (solutionPaths !== this.solutionPaths) {\r\n          this.solutionPaths = solutionPaths;\r\n          this.broadcast('settingChange', 'solutionPaths');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Auto play next move\r\n       */\r\n      autoPlayNext: function(immediately) {\r\n\r\n        //Must have game and children\r\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\r\n          return;\r\n        }\r\n\r\n        //Init vars\r\n        var children = [];\r\n        var self = this;\r\n        var i;\r\n\r\n        //When picking a child node, we always prefer to pick a valid solution\r\n        for (i = 0; i < this.game.node.children.length; i++) {\r\n          if (this.game.node.children[i].solution) {\r\n            children.push(this.game.node.children[i]);\r\n          }\r\n        }\r\n\r\n        //No solution nodes? Just use all nodes then.\r\n        if (children.length === 0) {\r\n          children = this.game.node.children;\r\n        }\r\n\r\n        //Pick a random child node\r\n        i = Math.floor(Math.random() * children.length);\r\n\r\n        //No delay?\r\n        if (immediately || !this.solveAutoPlayDelay) {\r\n          this.next(children[i]);\r\n          return;\r\n        }\r\n\r\n        //Block navigation and run the timeout\r\n        this.solveNavigationBlocked = true;\r\n        $timeout(function() {\r\n\r\n          //Move to next move and unblock navigation\r\n          self.next(children[i]);\r\n          self.solveNavigationBlocked = false;\r\n\r\n        }, this.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Start solving from the current game node\r\n       */\r\n      solve: function() {\r\n\r\n        //Must have a game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return false;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Remember problem start path\r\n        this.problemStartPath = this.game.getPath(true);\r\n\r\n        //Restrict start of navigation to the current node\r\n        this.restrictNode();\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restart the problem\r\n       */\r\n      restartProblem: function() {\r\n\r\n        //Must be in solve mode, must have game\r\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Go back to the start path\r\n        if (this.problemStartPath) {\r\n          this.goto(this.problemStartPath);\r\n        }\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeSolve = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.toggleSolutionPaths(this.config.solutionPaths);\r\n        this.setPlayerColor(this.config.playerColor);\r\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\r\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'solutionPaths') {\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n        }\r\n\r\n        //Player color changed?\r\n        if (setting === 'playerColor') {\r\n\r\n          //Draw (or hide) solution paths\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n\r\n          //Make an auto play move if it's not our turn\r\n          if (\r\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\r\n          ) {\r\n            this.autoPlayNext(true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this, event.x, event.y);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for keydown events\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //Right arrow\r\n          case KeyCodes.RIGHT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\r\n\r\n                //Go forward one move if solved\r\n                if (this.problemSolved) {\r\n                  this.next();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n\r\n          //Left arrow\r\n          case KeyCodes.LEFT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked and not reached the start?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\r\n\r\n                //Go back one move\r\n                this.previous();\r\n\r\n                //Go back one more if this is not the player's turn and if\r\n                //the problem hasn't been solved yet\r\n                if (\r\n                  !this.problemSolved && this.solveAutoPlay &&\r\n                  this.game.getTurn() === -this.playerColor\r\n                ) {\r\n                  this.previous();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //A valid variation\r\n        if (this.game.isMoveVariation(event.x, event.y)) {\r\n\r\n          //Get the node\r\n          var i = this.game.getMoveVariation(event.x, event.y);\r\n\r\n          //Advance to the next position and get the next node\r\n          this.next(i);\r\n          var node = this.game.getNode();\r\n\r\n          //No children left? Check if we solved it or not\r\n          if (node.children.length === 0) {\r\n            if (node.solution === true) {\r\n              this.problemSolved = true;\r\n              this.broadcast('solutionFound', node);\r\n            }\r\n            else {\r\n              this.broadcast('solutionWrong', node);\r\n            }\r\n          }\r\n\r\n          //Auto-play next move?\r\n          else if (!this.problemSolved && this.solveAutoPlay) {\r\n            this.autoPlayNext();\r\n          }\r\n        }\r\n\r\n        //Unknown variation, try to play\r\n        else if (this.game.play(event.x, event.y)) {\r\n          this.problemOffPath = true;\r\n          this.processPosition();\r\n          this.broadcast('solutionOffPath', this.game.getNode());\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Draw solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Hide any solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, false);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeSolve;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\r\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions\r\n   */\r\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\r\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\r\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\r\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\r\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\r\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\r\n\r\n  /**\r\n   * Player parser function\r\n   */\r\n  function parsePlayer(jgf, match) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\r\n\r\n    //Create player object\r\n    var player = {\r\n      color: color,\r\n      name: match[2],\r\n      rank: match[3].toLowerCase()\r\n    };\r\n\r\n    //Check if player of this color already exists, if so, overwrite\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p] = player;\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, push\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, match) {\r\n    jgf.game.komi = parseFloat(match[1] / 10);\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, match) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Push date\r\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\r\n  }\r\n\r\n  /**\r\n   * Result parser function\r\n   */\r\n  function parseResult(jgf, match) {\r\n\r\n    //Winner color\r\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\r\n    result += '+';\r\n\r\n    //Win condition\r\n    if (match[2].match(/res/i)) {\r\n      result += 'R';\r\n    }\r\n    else if (match[2].match(/time/i)) {\r\n      result += 'T';\r\n    }\r\n    else {\r\n      result += match[2];\r\n    }\r\n\r\n    //Set in JGF\r\n    jgf.game.result = result;\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, match) {\r\n\r\n    //Determine player color\r\n    var color = match[2];\r\n    if (color === 1) {\r\n      color = 'B';\r\n    }\r\n    else if (color === 2) {\r\n      color = 'W';\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (false) {\r\n\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[color] = [match[3] * 1, match[4] * 1];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    parse: function(gib, stringified) {\r\n\r\n      //Get new JGF object\r\n      var jgf = KifuBlank.jgf();\r\n\r\n      //Initialize\r\n      var match;\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find player information\r\n      while ((match = regPlayer.exec(gib))) {\r\n        parsePlayer(jgf, match);\r\n      }\r\n\r\n      //Find komi\r\n      if ((match = regKomi.exec(gib))) {\r\n        parseKomi(jgf, match);\r\n      }\r\n\r\n      //Find game date\r\n      if ((match = regDate.exec(gib))) {\r\n        parseDate(jgf, match);\r\n      }\r\n\r\n      //Find game result\r\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\r\n        parseResult(jgf, match);\r\n      }\r\n\r\n      //Find moves\r\n      while ((match = regMove.exec(gib))) {\r\n\r\n        //Create new node\r\n        node = {};\r\n\r\n        //Parse move\r\n        parseMove(jgf, node, match);\r\n\r\n        //Push node to container\r\n        container.push(node);\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Flip SGF alias map and create JGF alias map\r\n   */\r\n  var jgfAliases = {};\r\n  for (var sgfProp in sgfAliases) {\r\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\r\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert to SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to escape SGF info\r\n   */\r\n  function escapeSgf(text) {\r\n    if (typeof text === 'string') {\r\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\r\n    }\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Helper to write an SGF group\r\n   */\r\n  function writeGroup(prop, values, output, escape) {\r\n    if (values.length) {\r\n      output.sgf += prop;\r\n      for (var i = 0; i < values.length; i++) {\r\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser\r\n   */\r\n  function parseMove(move, output) {\r\n\r\n    //Determine and validate color\r\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\r\n    if (color === '') {\r\n      return;\r\n    }\r\n\r\n    //Determine move\r\n    var coords = (move[color] === 'pass') ? '' : move[color];\r\n\r\n    //Append to SGF\r\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\r\n  }\r\n\r\n  /**\r\n   * Setup parser\r\n   */\r\n  function parseSetup(setup, output) {\r\n\r\n    //Loop colors\r\n    for (var color in setup) {\r\n      if (setup.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < setup[color].length; i++) {\r\n          setup[color][i] = convertCoordinates(setup[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('A' + color, setup[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Score parser\r\n   */\r\n  function parseScore(score, output) {\r\n\r\n    //Loop colors\r\n    for (var color in score) {\r\n      if (score.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < score[color].length; i++) {\r\n          score[color][i] = convertCoordinates(score[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('T' + color, score[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser\r\n   */\r\n  function parseMarkup(markup, output) {\r\n\r\n    //Loop markup types\r\n    for (var type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n        var i;\r\n\r\n        //Label type has the label text appended to the coords\r\n        if (type === 'label') {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\r\n          }\r\n        }\r\n        else {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]);\r\n          }\r\n        }\r\n\r\n        //Convert type\r\n        if (typeof jgfAliases[type] !== 'undefined') {\r\n          type = jgfAliases[type];\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup(type, markup[type], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser\r\n   */\r\n  function parseTurn(turn, output) {\r\n    output.sgf += 'PL[' + turn + ']';\r\n  }\r\n\r\n  /**\r\n   * Comments parser\r\n   */\r\n  function parseComments(comments, output) {\r\n\r\n    //Determine key\r\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\r\n\r\n    //Flatten comment objects\r\n    var flatComments = [];\r\n    for (var c = 0; c < comments.length; c++) {\r\n      if (typeof comments[c] === 'string') {\r\n        flatComments.push(comments[c]);\r\n      }\r\n      else if (comments[c].comment) {\r\n        flatComments.push(comments[c].comment);\r\n      }\r\n    }\r\n\r\n    //Write as group\r\n    writeGroup(key, flatComments, output, true);\r\n  }\r\n\r\n  /**\r\n   * Node name parser\r\n   */\r\n  function parseNodeName(nodeName, output) {\r\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\r\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\r\n  }\r\n\r\n  /**\r\n   * Game parser\r\n   */\r\n  function parseGame(game) {\r\n\r\n    //Loop SGF game definitions\r\n    for (var i in sgfGames) {\r\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Application parser\r\n   */\r\n  function parseApplication(application) {\r\n    var parts = application.split(' v');\r\n    if (parts.length > 1) {\r\n      return parts[0] + ':' + parts[1];\r\n    }\r\n    return application;\r\n  }\r\n\r\n  /**\r\n   * Player instructions parser\r\n   */\r\n  function parsePlayer(player, rootProperties) {\r\n\r\n    //Variation handling\r\n    var st = 0;\r\n    if (!player.variationMarkup) {\r\n      st += 2;\r\n    }\r\n    if (player.variationSiblings) {\r\n      st += 1;\r\n    }\r\n\r\n    //Set in root properties\r\n    rootProperties.ST = st;\r\n  }\r\n\r\n  /**\r\n   * Board parser\r\n   */\r\n  function parseBoard(board, rootProperties) {\r\n\r\n    //Both width and height should be given\r\n    if (board.width && board.height) {\r\n\r\n      //Same dimensions?\r\n      if (board.width === board.height) {\r\n        rootProperties.SZ = board.width;\r\n      }\r\n\r\n      //Different dimensions are not supported by SGF, but OGS uses the\r\n      //format w:h, so we will stick with that for anyone who supports it.\r\n      else {\r\n        rootProperties.SZ = board.width + ':' + board.height;\r\n      }\r\n    }\r\n\r\n    //Otherwise, check if only width or height were given at least\r\n    else if (board.width) {\r\n      rootProperties.SZ = board.width;\r\n    }\r\n    else if (board.height) {\r\n      rootProperties.SZ = board.height;\r\n    }\r\n\r\n    //Can't determine size\r\n    else {\r\n      rootProperties.SZ = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Players parser\r\n   */\r\n  function parsePlayers(players, rootProperties) {\r\n\r\n    //Loop players\r\n    for (var p = 0; p < players.length; p++) {\r\n\r\n      //Validate color\r\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\r\n        continue;\r\n      }\r\n\r\n      //Get SGF color\r\n      var color = (players[p].color === 'black') ? 'B' : 'W';\r\n\r\n      //Name given?\r\n      if (players[p].name) {\r\n        rootProperties['P' + color] = players[p].name;\r\n      }\r\n\r\n      //Rank given?\r\n      if (players[p].rank) {\r\n        rootProperties[color + 'R'] = players[p].rank;\r\n      }\r\n\r\n      //Team given?\r\n      if (players[p].team) {\r\n        rootProperties[color + 'T'] = players[p].team;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Node properties\r\n    'move': parseMove,\r\n    'setup': parseSetup,\r\n    'score': parseScore,\r\n    'markup': parseMarkup,\r\n    'turn': parseTurn,\r\n    'comments': parseComments,\r\n    'name': parseNodeName,\r\n\r\n    //Info properties\r\n    'record.application': parseApplication,\r\n    'player': parsePlayer,\r\n    'board': parseBoard,\r\n    'game.type': parseGame,\r\n    'game.players': parsePlayers\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Parser functions\r\n   ***/\r\n\r\n  /**\r\n   * Helper to write a JGF tree to SGF\r\n   */\r\n  function writeTree(tree, output) {\r\n\r\n    //Loop nodes in the tree\r\n    for (var i = 0; i < tree.length; i++) {\r\n      var node = tree[i];\r\n\r\n      //Array? That means a variation\r\n      if (angular.isArray(node)) {\r\n        for (var j = 0; j < node.length; j++) {\r\n          output.sgf += '(\\n;';\r\n          writeTree(node[j], output);\r\n          output.sgf += '\\n)';\r\n        }\r\n\r\n        //Continue\r\n        continue;\r\n      }\r\n\r\n      //Loop node properties\r\n      for (var key in node) {\r\n        if (node.hasOwnProperty(key)) {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n            parsingMap[key](node[key], output);\r\n            continue;\r\n          }\r\n\r\n          //Other object, can't handle it\r\n          if (typeof node[key] === 'object') {\r\n            continue;\r\n          }\r\n\r\n          //Anything else, append it\r\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //More to come?\r\n      if ((i + 1) < tree.length) {\r\n        output.sgf += '\\n;';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to extract all SGF root properties from a JGF object\r\n   */\r\n  function extractRootProperties(jgf, rootProperties, key) {\r\n\r\n    //Initialize key\r\n    if (typeof key === 'undefined') {\r\n      key = '';\r\n    }\r\n\r\n    //Loop properties of jgf node\r\n    for (var subKey in jgf) {\r\n      if (jgf.hasOwnProperty(subKey)) {\r\n\r\n        //Skip SGF signature (as we keep our own)\r\n        if (subKey === 'sgf') {\r\n          continue;\r\n        }\r\n\r\n        //Build jgf key\r\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\r\n\r\n        //If the item is an object, handle separately\r\n        if (typeof jgf[subKey] === 'object') {\r\n\r\n          //Handler for this object present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\r\n          }\r\n\r\n          //Otherwise, just flatten and call this function recursively\r\n          else {\r\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Check if it's a known key, if so, append the value to the root\r\n        var value;\r\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            value = parsingMap[jgfKey](jgf[subKey]);\r\n          }\r\n          else {\r\n            value = escapeSgf(jgf[subKey]);\r\n          }\r\n\r\n          //Set in root properties\r\n          rootProperties[jgfAliases[jgfKey]] = value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    parse: function(jgf) {\r\n\r\n      //String given?\r\n      if (typeof jgf === 'string') {\r\n        jgf = angular.fromJson(jgf);\r\n      }\r\n\r\n      //Must have moves tree\r\n      if (!jgf.tree) {\r\n        console.error('No moves tree in JGF object');\r\n        return;\r\n      }\r\n\r\n      //Initialize output (as object, so it remains a reference) and root properties container\r\n      var output = {sgf: '(\\n;'};\r\n      var root = angular.copy(jgf);\r\n      var rootProperties = KifuBlank.sgf();\r\n\r\n      //The first node of the JGF tree is the root node, and it can contain comments,\r\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\r\n      //and attach it to the root\r\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\r\n        root = angular.extend(root, jgf.tree[0]);\r\n        delete root.root;\r\n        delete jgf.tree[0];\r\n      }\r\n\r\n      //Set root properties\r\n      delete root.tree;\r\n      extractRootProperties(root, rootProperties);\r\n\r\n      //Write root properties\r\n      for (var key in rootProperties) {\r\n        if (rootProperties[key]) {\r\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //Write game tree\r\n      writeTree(jgf.tree, output);\r\n\r\n      //Close SGF and return\r\n      output.sgf += ')';\r\n      return output.sgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions for SGF data\r\n   */\r\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\r\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\r\n  var regProperty = /[A-Z]+/;\r\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Application parser function (doesn't overwrite existing signature)\r\n   */\r\n  function parseApp(jgf, node, key, value) {\r\n    if (!jgf.record.application) {\r\n      var app = value[0].split(':');\r\n      if (app.length > 1) {\r\n        jgf.record.application = app[0] + ' v' + app[1];\r\n      }\r\n      else {\r\n        jgf.record.application = app[0];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SGF format parser\r\n   */\r\n  function parseSgfFormat() {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Game type parser function\r\n   */\r\n  function parseGame(jgf, node, key, value) {\r\n    var game = value[0];\r\n    if (typeof sgfGames[game] !== 'undefined') {\r\n      jgf.game.type = sgfGames[game];\r\n    }\r\n    else {\r\n      jgf.game.type = value[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, key, value) {\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\r\n      node.move[key] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[key] = convertCoordinates(value[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Comment parser function\r\n   */\r\n  function parseComment(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Node name parser function\r\n   */\r\n  function parseNodeName(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value[0];\r\n  }\r\n\r\n  /**\r\n   * Board setup parser function\r\n   */\r\n  function parseSetup(jgf, node, key, value) {\r\n\r\n    //Initialize setup container on node\r\n    if (typeof node.setup === 'undefined') {\r\n      node.setup = {};\r\n    }\r\n\r\n    //Remove \"A\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Initialize setup container of this type\r\n    if (typeof node.setup[key] === 'undefined') {\r\n      node.setup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.setup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scoring parser function\r\n   */\r\n  function parseScore(jgf, node, key, value) {\r\n\r\n    //Initialize score container on node\r\n    if (typeof node.score === 'undefined') {\r\n      node.score = {\r\n        B: [],\r\n        W: []\r\n      };\r\n    }\r\n\r\n    //Remove \"T\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.score[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser function\r\n   */\r\n  function parseTurn(jgf, node, key, value) {\r\n    node.turn = value[0];\r\n  }\r\n\r\n  /**\r\n   * Label parser function\r\n   */\r\n  function parseLabel(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n\r\n      //Split off coordinates and add label contents\r\n      var coords = convertCoordinates(value[i].substr(0, 2));\r\n      coords.push(value[i].substr(3));\r\n\r\n      //Add to node\r\n      node.markup[key].push(coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser function\r\n   */\r\n  function parseMarkup(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.markup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Size parser function\r\n   */\r\n  function parseSize(jgf, node, key, value) {\r\n\r\n    //Initialize board container\r\n    if (typeof jgf.board === 'undefined') {\r\n      jgf.board = {};\r\n    }\r\n\r\n    //Add size property (can be width:height or just a single size)\r\n    var size = value[0].split(':');\r\n    if (size.length > 1) {\r\n      jgf.board.width = parseInt(size[0]);\r\n      jgf.board.height = parseInt(size[1]);\r\n    }\r\n    else {\r\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, node, key, value) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Explode dates\r\n    var dates = value[0].split(',');\r\n    for (var d = 0; d < dates.length; d++) {\r\n      jgf.game.dates.push(dates[d]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, node, key, value) {\r\n    jgf.game.komi = parseFloat(value[0]);\r\n  }\r\n\r\n  /**\r\n   * Variations handling parser function\r\n   */\r\n  function parseVariations(jgf, node, key, value) {\r\n\r\n    //Initialize display property\r\n    if (typeof jgf.player === 'undefined') {\r\n      jgf.player = {};\r\n    }\r\n\r\n    //Initialize variation display settings\r\n    jgf.player.variationMarkup = false;\r\n    jgf.player.variationChildren = false;\r\n    jgf.player.variationSiblings = false;\r\n\r\n    //Parse as integer\r\n    var st = parseInt(value[0]);\r\n\r\n    //Determine what we want (see SGF specs for details)\r\n    switch (st) {\r\n      case 0:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 1:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n      case 2:\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 3:\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Player info parser function\r\n   */\r\n  function parsePlayer(jgf, node, key, value) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Check if player of this color already exists\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p][key] = value[0];\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, initialize\r\n    var player = {color: color};\r\n    player[key] = value[0];\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Parsing function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Application, game type, board size, komi, date\r\n    'AP': parseApp,\r\n    'FF': parseSgfFormat,\r\n    'GM': parseGame,\r\n    'SZ': parseSize,\r\n    'KM': parseKomi,\r\n    'DT': parseDate,\r\n\r\n    //Variations handling\r\n    'ST': parseVariations,\r\n\r\n    //Player info handling\r\n    'PB': parsePlayer,\r\n    'PW': parsePlayer,\r\n    'BT': parsePlayer,\r\n    'WT': parsePlayer,\r\n    'BR': parsePlayer,\r\n    'WR': parsePlayer,\r\n\r\n    //Moves\r\n    'B': parseMove,\r\n    'W': parseMove,\r\n\r\n    //Node annotation\r\n    'C': parseComment,\r\n    'N': parseNodeName,\r\n\r\n    //Board setup\r\n    'AB': parseSetup,\r\n    'AW': parseSetup,\r\n    'AE': parseSetup,\r\n    'PL': parseTurn,\r\n    'TW': parseScore,\r\n    'TB': parseScore,\r\n\r\n    //Markup\r\n    'CR': parseMarkup,\r\n    'SQ': parseMarkup,\r\n    'TR': parseMarkup,\r\n    'MA': parseMarkup,\r\n    'SL': parseMarkup,\r\n    'LB': parseLabel\r\n  };\r\n\r\n  /**\r\n   * These properties need a node object\r\n   */\r\n  var needsNode = [\r\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\r\n  ];\r\n\r\n  /*****************************************************************************\r\n   * Parser helpers\r\n   ***/\r\n\r\n  /**\r\n   * Set info in the JGF tree at a certain position\r\n   */\r\n  function setInfo(jgf, position, value) {\r\n\r\n    //Position given must be an array\r\n    if (typeof position !== 'object') {\r\n      return;\r\n    }\r\n\r\n    //Initialize node to attach value to\r\n    var node = jgf;\r\n    var key;\r\n\r\n    //Loop the position\r\n    for (var p = 0; p < position.length; p++) {\r\n\r\n      //Get key\r\n      key = position[p];\r\n\r\n      //Last key reached? Done\r\n      if ((p + 1) === position.length) {\r\n        break;\r\n      }\r\n\r\n      //Create container if not set\r\n      if (typeof node[key] !== 'object') {\r\n        node[key] = {};\r\n      }\r\n\r\n      //Move up in tree\r\n      node = node[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    parse: function(sgf, stringified) {\r\n\r\n      //Get new JGF object (with SGF node as a base)\r\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\r\n\r\n      //Initialize\r\n      var stack = [];\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find sequence of elements\r\n      var sequence = sgf.match(regSequence);\r\n\r\n      //Loop sequence items\r\n      for (var i = 0; i < sequence.length; i++) {\r\n\r\n        //Push stack if new variation found\r\n        if (sequence[i] === '(') {\r\n\r\n          //First encounter, this defines the main tree branch, so skip\r\n          if (i === 0 || i === '0') {\r\n            continue;\r\n          }\r\n\r\n          //Push the current container to the stack\r\n          stack.push(container);\r\n\r\n          //Create variation container if it doesn't exist yet\r\n          if (!angular.isArray(container[container.length - 1])) {\r\n            container.push([]);\r\n          }\r\n\r\n          //Use variation container\r\n          container = container[container.length - 1];\r\n\r\n          //Now create moves container\r\n          container.push([]);\r\n          container = container[container.length - 1];\r\n          continue;\r\n        }\r\n\r\n        //Grab last container from stack if end of variation reached\r\n        else if (sequence[i] === ')') {\r\n          if (stack.length) {\r\n            container = stack.pop();\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Make array of properties within this sequence\r\n        var properties = sequence[i].match(regNode) || [];\r\n\r\n        //Loop them\r\n        for (var j = 0; j < properties.length; j++) {\r\n\r\n          //Get property's key and separate values\r\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\r\n          var values = properties[j].match(regValues);\r\n\r\n          //Remove additional braces [ and ]\r\n          for (var k = 0; k < values.length; k++) {\r\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\r\n          }\r\n\r\n          //SGF parser present for this key? Call it, and we're done\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n\r\n            //Does this type of property need a node?\r\n            if (needsNode.indexOf(key) !== -1) {\r\n\r\n              //If no node object present, create a new node\r\n              //For moves, always a new node is created\r\n              if (!node || key === 'B' || key === 'W') {\r\n                node = {};\r\n                container.push(node);\r\n              }\r\n            }\r\n\r\n            //Apply parsing function on node\r\n            parsingMap[key](jgf, node, key, values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF parser present, we continue with regular property handling\r\n\r\n          //If there is only one value, simplify array\r\n          if (values.length === 1) {\r\n            values = values[0];\r\n          }\r\n\r\n          //SGF alias known? Then this is an info element and we handle it accordingly\r\n          if (typeof sgfAliases[key] !== 'undefined') {\r\n\r\n            //The position in the JGF object is represented by dot separated strings\r\n            //in the sgfAliases array. Split the position and use the setInfo helper\r\n            //to set the info on the JGF object\r\n            setInfo(jgf, sgfAliases[key].split('.'), values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF alias present either, just append the data\r\n\r\n          //Save in node\r\n          if (node) {\r\n            node[key] = values;\r\n          }\r\n\r\n          //Save in root\r\n          else {\r\n            jgf[key] = values;\r\n          }\r\n        }\r\n\r\n        //Reset node, unless this was the root node\r\n        if (node && !node.root) {\r\n          node = null;\r\n        }\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}