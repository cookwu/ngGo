{"version":3,"sources":["ngGo.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js","ngGo.min.js"],"names":["window","angular","undefined","module","constant","name","version","error","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","POSITION_IS_SUICIDE","POSITION_IS_REPEATING","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","E","EMPTY","B","BLACK","W","WHITE","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","SAD","HAPPY","PLAY","REPLAY","EDIT","SOLVE","NONE","MOVE","SCORE","SETUP","MARKUP","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","PAGEUP","PAGEDOWN","factory","ngGo","InvalidDataError","code","this","message","prototype","Error","constructor","StoneColor","InvalidPositionError","x","y","color","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","directive","$window","Board","createLayerCanvas","canvas","document","createElement","context","getContext","pixelRatio","scale","className","width","clientWidth","height","clientHeight","appendChild","determineDrawSize","scope","availableWidth","availableHeight","drawWidth","drawHeight","cellSize","Math","min","floor","lastDrawWidth","lastDrawHeight","$broadcast","devicePixelRatio","restrict","instance","link","element","attrs","i","layer","playerElement","parent","sizingElement","existingInstance","linkElement","tagName","$on","event","find","length","forceSize","css","setDrawSize","on","board","resized","addClass","makeStatic","call","layerOrder","layers","setContext","$observe","size","toLowerCase","indexOf","split","setSize","attr","toggleCoordinates","isDefined","setCutoff","swapColors","$parent","Player","setBoard","redraw","provider","defaultConfig","cutoff","section","top","right","bottom","left","coordinates","colorMultiplier","setConfig","config","extend","$get","$rootScope","$injector","BoardTheme","init","parseConfig","removeAll","theme","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","l","layerClass","toUpperCase","substr","LayerClass","get","margin","grid","setCoordinates","setSection","setMargin","isArray","changes","side","hasOwnProperty","parseInt","isNaN","show","multiplier","getTheme","setTheme","add","value","remove","has","setAll","updatePosition","position","pathChanged","stones","markup","getState","getAll","state","isEmpty","restoreState","clear","draw","xLeft","xRight","yTop","yBot","noCellsHor","noCellsVer","getCellSize","getAbsX","gridX","offset","round","getAbsY","gridY","getGridX","absX","getGridY","absY","isOnBoard","obj","s","r","clearRect","BoardGridChanges","toObject","valueKey","BoardGrid","emptyValue","set","isOnGrid","unset","is","all","objects","push","populate","empty","clone","newGrid","copy","isSameAs","compare","console","warn","whenEmpty","getSize","setSubtract","a","b","q","n","j","concat","newChanges","BoardLayer","clearCell","drawCell","redrawCell","DefaultClearHandler","BoardObject","drawheight","shellLine","ctx","radius","startAngle","endAngle","strokeStyle","shadowBlur","lineWidth","thickness","beginPath","max","m","angle","x1","cos","PI","y1","sin","x2","y2","atan","c","factor","dx","dy","bx1","by1","bx2","by2","moveTo","bezierCurveTo","stroke","lines","MarkupTypes","defaultTheme","stone","style","shadow","shell","stoneColor","types","mono","lineColor","mini","alpha","faded","blur","offsetX","ceil","offsetY","triangle","square","circle","mark","lineCap","last","smiley","label","font","variation","type","text","String","fromCharCode","solution","valid","invalid","star","points","vertical","inverse","ch","horizontal","merge","instanceTheme","reset","property","path","prop","args","arguments","apply","canvasTranslate","defaultSize","defaultKomi","defaultHandicap","rememberPath","checkRepeat","allowSuicide","GamePath","GameNode","GamePosition","KifuParser","KifuBlank","validateInfo","info","game","komi","handicap","nextNode","node","children","rememberedPath","advance","previousNode","retreat","firstNode","root","setTurn","initializeHistory","history","pushPosition","newPosition","popPosition","pop","replacePosition","executeNode","isMove","move","pass","validateMove","turn","setup","Game","data","Object","defineProperty","load","jgf","fromData","errorCode","first","reload","isLoaded","props","getOwnPropertyNames","p","charAt","fromSgf","fromJgf","fromGib","gib","gib2jgf","sgf","sgf2jgf","fromJson","tree","toSgf","jgf2sgf","toJgf","stringify","toJson","getNode","getNodes","nodes","getChild","getMoveNode","getMoveNodes","fromMove","toMove","filter","getMoveNumber","getMove","getMoveCount","moveNodes","getMoveVariation","getPosition","getPath","clonePath","getPathToNode","nodeName","findNode","getKomi","parseFloat","setKomi","getName","getResult","getTurn","getCaptureCount","captures","defaultValue","key","isMoveVariation","isRepeatingPosition","checkPosition","stop","isValidMove","captureAdjacent","hasLiberties","captureGroup","validatePlacement","addStone","tempPosition","appendTo","addMarkup","removeStone","foundInSetup","splice","removeMarkup","hasStone","hasMarkup","getStone","getMarkup","play","next","previous","target","setMove","nodeAt","nextFork","previousFork","nextComment","hasComments","previousComment","convertCoordinates","coords","charCodeAt","aChar","coordinatesObject","baseObject","toStringColor","toColorConstant","convertMoveToJgf","jgfMove","convertMoveFromJgf","convertSetupToJgf","jgfSetup","convertSetupFromJgf","gameSetup","convertMarkupToJgf","jgfMarkup","convertMarkupFromJgf","gameMarkup","convertTurnToJgf","convertTurnFromJgf","properties","conversionMap","getChildren","hasChildren","getParent","hasMoveVariations","moveVariations","getMoveVariations","comments","moveUp","temp","moveDown","insertNode","gameNode","variationNode","container","variationsContainer","variationContainer","findNodeName","branches","no","otherPath","newPath","rootNode","setStone","setMarkup","groupColor","tested","friendlyColor","captured","canCapture","enemyColor","doCapture","captureStone","setCaptures","getCaptures","switchTurn","calcTotal","territory","GameScore","self","black","white","total","winner","w","territorySet","candidateColor","boundaryColor","posColor","origColor","territoryReset","determineScoreState","curState","newState","adjacent","change","scoreState","UNKNOWN","BLACK_CANDIDATE","WHITE_CANDIDATE","BLACK_STONE","WHITE_STONE","NEUTRAL","GameScorer","score","getScore","getPoints","calculate","blankJgf","record","application","charset","players","blankSgf","AP","CA","FF","GM","SZ","PB","PW","base","blank","CP","SO","US","AN","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","ON","GC","BT","WT","BR","WR","N","C","CR","TR","SQ","MA","SL","LB","1","2","3","4","6","7","8","Gib2Jgf","Sgf2Jgf","Jgf2Sgf","stringified","parse","controller","$scope","mode","switchMode","tool","switchTool","setVariationMarkup","toggleSolutionPaths","setLastMoveMarker","PlayerModes","PlayerTools","arrowKeysNavigation","scrollWheelNavigation","lastMoveMarker","variationMarkup","variationChildren","variationSiblings","$document","processMouseEvent","broadcastEvent","mouseEvent","originalEvent","layerX","layerY","drag","modes","tools","restrictNodeStart","restrictNodeEnd","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","arrowKeys","broadcast","scrollWheel","registerMode","PlayerMode","setTools","hasMode","hasTool","force","saveState","playerState","saveGameState","restoreGameState","allowPlayerConfig","processPosition","gameState","goto","restrictNode","end","updateBoard","showMoveNumbers","forEach","newGame","scoreGame","getBoard","off","bind","listener","querySelector","preventClickEvent","t","$$phase","$apply","Coordinates","drawStarPoint","starRadius","starColor","fillStyle","arc","fill","GridLayer","tx","ty","starPoints","translate","lineTo","Markup","StoneFaded","HoverLayer","restore","hover","object","objectClass","MarkupLayer","StoneMini","ScoreLayer","StoneShadow","ShadowLayer","shadowSize","setTransform","Stone","StonesLayer","kanji","aCharLc","numbers","letters","xl","xr","yt","yb","textBaseline","textAlign","fillText","drawTriangle","cosPi6","closePath","drawSquare","rcos","cosPi4","rect","drawCircle","drawMark","drawSelect","drawLast","drawHappySmiley","drawSadSmiley","drawLabel","toString","clearLabel","ShellPattern","drawMono","globalAlpha","drawGlass","createRadialGradient","addColorStop","drawSlateShell","shellSeed","random","shellTypes","z","handler","shadowColor","parsePlayer","match","player","rank","parseKomi","parseDate","dates","parseResult","result","parseMove","regMove","regPlayer","regKomi","regDate","regResultMargin","regResultOther","Parser","exec","sgfAliases","sgfGames","escapeSgf","replace","writeGroup","values","output","escape","parseSetup","parseScore","parseMarkup","jgfAliases","parseTurn","parseComments","flatComments","comment","parseNodeName","parseGame","parseApplication","parts","rootProperties","st","ST","parseBoard","parsePlayers","team","writeTree","parsingMap","extractRootProperties","subKey","jgfKey","sgfProp","record.application","game.type","game.players","parseApp","app","parseSgfFormat","parseComment","parseLabel","parseSize","d","parseVariations","setInfo","regSequence","regNode","regProperty","regValues","AB","AW","AE","PL","TW","TB","needsNode","stack","sequence","k","substring","run","PlayerModeCommon","keyDown","mouseWheel","mouseMove","mouseOut","mouseDown","mouseUp","KeyCodes","dragObject","start","mouse","dragStart","normalizeMousewheelEvent","deltaX","deltaY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","mouseWheelX","mouseWheelY","lastX","lastY","keyboardEvent","keyCode","preventDefault","delta","CLEAR","TEXT","NUMBER","PlayerModeEdit","pathChange","toolSwitch","modeEnter","mouseDrag","click","SetupTools","MarkupTools","updateHoverMark","isDrag","setupTool","setupToolColor","markupTool","markupLabel","markupLabels","determineMarkupLabel","findAllMarkupLabels","switchSetupTool","switchMarkupTool","setMarkupLabel","statePreScoring","PlayerModeReplay","settingChange","boardUpdate","modeExit","autoPlayDelay","$interval","showMoveVariations","variations","hideMoveVariations","drawMoveVariations","autoPlaying","autoPlayPromise","setAutoPlayDelay","delay","cancel","setting","PlayerModeSolve","playerColor","solutionPaths","solveAutoPlay","solveAutoPlayDelay","$timeout","canMakeMove","problemSolved","problemOffPath","showSolutionPaths","hideSolutionPaths","drawSolutionPaths","problemStartPath","solveNavigationBlocked","setSolveAutoPlay","autoPlay","setSolveAutoPlayDelay","setPlayerColor","getPlayerColor","asOnBoard","autoPlayNext","immediately","solve","restartProblem"],"mappings":"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","file":"ngGo.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\r\n * ngGo\r\n *\r\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\r\n * refactored to fit the Angular framework, as well as having been linted, properly commented\r\n * and generally cleaned up.\r\n *\r\n * Copyright (c) 2013 Jan Prokop (WGo)\r\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify, merge,\r\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\r\n * to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo', [])\r\n\r\n/**\r\n * ngGo constants\r\n */\r\n.constant('ngGo', {\r\n  name: 'ngGo',\r\n  version: '1.3.1',\r\n  error: {\r\n\r\n    //Position errors\r\n    POSITION_OUT_OF_BOUNDS: 1,\r\n    POSITION_ALREADY_HAS_STONE: 2,\r\n    POSITION_IS_SUICIDE: 3,\r\n    POSITION_IS_REPEATING: 4,\r\n\r\n    //Data loading errors\r\n    NO_DATA: 5,\r\n    UNKNOWN_DATA: 6,\r\n    INVALID_SGF: 7,\r\n    INVALID_GIB: 8,\r\n    INVALID_JGF_JSON: 9,\r\n    INVALID_JGF_TREE_JSON: 10\r\n  }\r\n})\r\n\r\n/**\r\n * Stone colors\r\n */\r\n.constant('StoneColor', {\r\n  E: 0,\r\n  EMPTY: 0,\r\n  B: 1,\r\n  BLACK: 1,\r\n  W: -1,\r\n  WHITE: -1\r\n})\r\n\r\n/**\r\n * Markup types\r\n */\r\n.constant('MarkupTypes', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  LABEL: 'label',\r\n  LAST: 'last',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy'\r\n})\r\n\r\n/**\r\n * Player modes\r\n */\r\n.constant('PlayerModes', {\r\n  PLAY: 'play',\r\n  REPLAY: 'replay',\r\n  EDIT: 'edit',\r\n  SOLVE: 'solve'\r\n})\r\n\r\n/**\r\n * Player tools\r\n */\r\n.constant('PlayerTools', {\r\n  NONE: 'none',\r\n  MOVE: 'move',\r\n  SCORE: 'score',\r\n  SETUP: 'setup',\r\n  MARKUP: 'markup'\r\n})\r\n\r\n/**\r\n * Key codes\r\n */\r\n.constant('KeyCodes', {\r\n  LEFT: 37,\r\n  RIGHT: 39,\r\n  UP: 38,\r\n  DOWN: 40,\r\n  ESC: 27,\r\n  ENTER: 13,\r\n  SPACE: 32,\r\n  TAB: 9,\r\n  SHIFT: 16,\r\n  CTRL: 17,\r\n  ALT: 18,\r\n  HOME: 36,\r\n  END: 35,\r\n  PAGEUP: 33,\r\n  PAGEDOWN: 34\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidDataError :: Error class to handle invalid data.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidDataError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidDataError(code) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidDataError';\r\n    this.message = 'Invalid data: ';\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.NO_DATA:\r\n        this.message += 'no data to process.';\r\n        break;\r\n      case ngGo.error.UNKNOWN_DATA:\r\n        this.message += 'unknown data format.';\r\n        break;\r\n      case ngGo.error.INVALID_GIB:\r\n        this.message += 'unable to parse GIB data.';\r\n        break;\r\n      case ngGo.error.INVALID_SGF:\r\n        this.message += 'unable to parse SGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_JSON:\r\n        this.message += 'unable to parse JGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_TREE_JSON:\r\n        this.message += 'unable to parse the JGF tree data.';\r\n        break;\r\n      default:\r\n        this.message += 'unable to parse the data.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidDataError.prototype = new Error();\r\n  InvalidDataError.prototype.constructor = InvalidDataError;\r\n\r\n  //Return object\r\n  return InvalidDataError;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidPositionError :: Error class to handle invalid moves.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidPositionError(code, x, y, color) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidPositionError';\r\n    this.message = 'Invalid position detected.';\r\n\r\n    //Add position data\r\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\r\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\r\n        ' stone on (' + x + ', ' + y + ')';\r\n    }\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\r\n        this.message += ', but these coordinates are not on the board.';\r\n        break;\r\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\r\n        this.message += ', but there is already a stone on those coordinates.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_SUICIDE:\r\n        this.message += ', but that would be suicide.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_REPEATING:\r\n        this.message += ', but this position already occured.';\r\n        break;\r\n      default:\r\n        this.message += '.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidPositionError.prototype = new Error();\r\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\r\n\r\n  //Return object\r\n  return InvalidPositionError;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Directive', [\r\n  'ngGo.Board.Service'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('board', ['$window', 'Board', function($window, Board) {\r\n\r\n  //Get pixel ratio\r\n  var pixelRatio = window.devicePixelRatio || 1;\r\n\r\n  /**\r\n   * Helper to create a layer canvas\r\n   */\r\n  function createLayerCanvas(name) {\r\n\r\n    //Create canvas element and get context\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    //Scale context depending on pixel ratio\r\n    if (pixelRatio > 1) {\r\n      context.scale(pixelRatio, pixelRatio);\r\n    }\r\n\r\n    //Set class\r\n    canvas.className = name;\r\n\r\n    //Set initial canvas width/height based on our own size\r\n    canvas.width = this.clientWidth * pixelRatio;\r\n    canvas.height = this.clientHeight * pixelRatio;\r\n\r\n    //Append to element now and return context\r\n    this.appendChild(canvas);\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Helper to determine draw size\r\n   */\r\n  function determineDrawSize(scope, availableWidth, availableHeight) {\r\n\r\n    //Init vars\r\n    var drawWidth, drawHeight, cellSize;\r\n\r\n    //Stretch available height to width if zero\r\n    if (availableHeight === 0 && availableWidth > 0) {\r\n      availableHeight = availableWidth;\r\n    }\r\n\r\n    //Grid size known?\r\n    if (scope.Board.width && scope.Board.height) {\r\n\r\n      //Determine smallest cell size\r\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\r\n\r\n      //Set draw size\r\n      drawWidth = Math.floor(cellSize * scope.Board.width);\r\n      drawHeight = Math.floor(cellSize * scope.Board.height);\r\n    }\r\n\r\n    //Otherwise, use the lesser of the available width/height\r\n    else {\r\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\r\n    }\r\n\r\n    //Broadcast new size if changed\r\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\r\n      scope.lastDrawWidth = drawWidth;\r\n      scope.lastDrawHeight = drawHeight;\r\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\r\n      return true;\r\n    }\r\n\r\n    //No change\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Directive\r\n   */\r\n  return {\r\n    restrict: 'E',\r\n    scope: {\r\n      instance: '&'\r\n    },\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Init vars\r\n      var i, context, layer, playerElement;\r\n      var parent = element.parent();\r\n      var sizingElement = element[0];\r\n      var existingInstance = true;\r\n\r\n      //Remember last draw width/height\r\n      scope.lastDrawWidth = 0;\r\n      scope.lastDrawHeight = 0;\r\n\r\n      //Get board instance\r\n      scope.Board = scope.instance();\r\n\r\n      //Function given?\r\n      if (typeof scope.Board === 'function') {\r\n        scope.Board = scope.Board();\r\n      }\r\n\r\n      //Instantiate board if not present in scope\r\n      if (!scope.Board) {\r\n        existingInstance = false;\r\n        scope.Board = new Board();\r\n      }\r\n\r\n      //Link element\r\n      scope.Board.linkElement(element);\r\n\r\n      //Find player element\r\n      if (parent[0].tagName === 'PLAYER') {\r\n        playerElement = parent;\r\n        sizingElement = parent.parent()[0];\r\n      }\r\n\r\n      //Listen for board drawsize events\r\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\r\n\r\n        //First set the new dimensions on the canvas elements\r\n        var canvas = element.find('canvas');\r\n        for (i = 0; i < canvas.length; i++) {\r\n          canvas[i].width = width * pixelRatio;\r\n          canvas[i].height = height * pixelRatio;\r\n        }\r\n\r\n        //Set on the element if we're using a player element and if there is a size\r\n        if (playerElement || attrs.forceSize === 'true') {\r\n          element.css({width: width + 'px', height: height + 'px'});\r\n        }\r\n\r\n        //Next set it on the board itself\r\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\r\n      });\r\n\r\n      //Determine initial draw size\r\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n\r\n      //On window resize, determine the draw size again\r\n      angular.element($window).on('resize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On manual resize, determine draw size again\r\n      scope.$on('ngGo.board.determineDrawSize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On board grid resize, determine the draw size again\r\n      scope.$on('ngGo.board.resize', function(event, board) {\r\n\r\n        //Only relevent if this was our own board\r\n        if (board !== scope.Board) {\r\n          return;\r\n        }\r\n\r\n        //If the draw size didn't change, the draw size event won't be triggered.\r\n        //However, that means we should call the resized() method now manually because\r\n        //it won't be called with the setDrawSize() call.\r\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\r\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\r\n          scope.Board.resized();\r\n        }\r\n      });\r\n\r\n      //Static board\r\n      if (attrs.static && attrs.static === 'true') {\r\n\r\n        //Add static class and make the board static\r\n        element.addClass('static');\r\n        scope.Board.makeStatic();\r\n\r\n        //Create single canvas and link to all relevant layer service classes\r\n        context = createLayerCanvas.call(element[0], 'static');\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Dynamic board\r\n      else {\r\n\r\n        //Create individual layer canvasses and link the canvas context to the layer service class\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          context = createLayerCanvas.call(element[0], layer);\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Observe the board size attribute\r\n      attrs.$observe('size', function(size) {\r\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\r\n          size = size.split('x');\r\n          scope.Board.setSize(size[0], size[1]);\r\n        }\r\n        else {\r\n          scope.Board.setSize(size, size);\r\n        }\r\n      });\r\n\r\n      //Observe the coordinates attribute\r\n      attrs.$observe('coordinates', function(attr) {\r\n        scope.Board.toggleCoordinates(attr === 'true');\r\n      });\r\n\r\n      //Observe the cutoff attribute\r\n      attrs.$observe('cutoff', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.setCutoff(attr.split(','));\r\n        }\r\n      });\r\n\r\n      //Observe color multiplier\r\n      attrs.$observe('colorMultiplier', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.swapColors(attr);\r\n        }\r\n      });\r\n\r\n      //Link board to player if present in parent scope\r\n      if (scope.$parent.Player) {\r\n        scope.$parent.Player.setBoard(scope.Board);\r\n      }\r\n\r\n      //Redraw board if we had an existing instance (it might contain data)\r\n      if (existingInstance) {\r\n        scope.Board.redraw();\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\r\n * and is used for placing and removing objects on the board. The class has helpers to figure out\r\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\r\n * responsible for drawing all layers on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Directive',\r\n  'ngGo.Board.Theme.Service',\r\n  'ngGo.Board.Layer.GridLayer.Service',\r\n  'ngGo.Board.Layer.ShadowLayer.Service',\r\n  'ngGo.Board.Layer.StonesLayer.Service',\r\n  'ngGo.Board.Layer.MarkupLayer.Service',\r\n  'ngGo.Board.Layer.ScoreLayer.Service',\r\n  'ngGo.Board.Layer.HoverLayer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.Stone.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Board', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Width and height\r\n    width: 0,\r\n    height: 0,\r\n\r\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\r\n    cutoff: [],\r\n\r\n    //Section of board to display\r\n    section: {top: 0, right: 0, bottom: 0, left: 0},\r\n\r\n    //Show coordinates?\r\n    coordinates: false,\r\n\r\n    //Color multiplier (use -1 to swap colors)\r\n    colorMultiplier: 1\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\r\n\r\n    /**\r\n     * Board constructor\r\n     */\r\n    function Board(config) {\r\n\r\n      //Initialize board\r\n      this.init();\r\n\r\n      //Parse config\r\n      this.parseConfig(config || {});\r\n    }\r\n\r\n    /**\r\n     * Initialize board\r\n     */\r\n    Board.prototype.init = function() {\r\n\r\n      //Remove everything\r\n      this.removeAll();\r\n\r\n      //Set board theme\r\n      this.theme = new BoardTheme();\r\n\r\n      //Initialize board draw dimensions in pixels\r\n      this.cellSize = 0;\r\n      this.drawWidth = 0;\r\n      this.drawHeight = 0;\r\n      this.drawMarginHor = 0;\r\n      this.drawMarginVer = 0;\r\n      this.gridDrawWidth = 0;\r\n      this.gridDrawHeight = 0;\r\n\r\n      //Set layer order\r\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\r\n\r\n      //Initialize layers\r\n      this.layers = {};\r\n      for (var l = 0; l < this.layerOrder.length; l++) {\r\n        var layer = this.layerOrder[l];\r\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\r\n        var LayerClass = $injector.get(layerClass);\r\n        this.layers[layer] = new LayerClass(this);\r\n      }\r\n\r\n      //Static board flag\r\n      this.static = false;\r\n\r\n      //Get margin from theme\r\n      this.margin = this.theme.get('board.margin');\r\n\r\n      //Color multiplier (to allow color swapping)\r\n      this.colorMultiplier = 1;\r\n\r\n      //Turn off coordinates\r\n      this.coordinates = false;\r\n      this.layers.grid.setCoordinates(false);\r\n\r\n      //Initialize grid size\r\n      this.width = 0;\r\n      this.height = 0;\r\n\r\n      //Initialize cutoff\r\n      this.cutoff = {\r\n        top: false,\r\n        left: false,\r\n        right: false,\r\n        bottom: false\r\n      };\r\n\r\n      //Initialize section\r\n      this.section = {\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Link the board to a HTML element\r\n     */\r\n    Board.prototype.linkElement = function(element) {\r\n      this.element = element;\r\n    };\r\n\r\n    /**\r\n     * Make this board static (one canvas layer, only grid, stones and markup)\r\n     */\r\n    Board.prototype.makeStatic = function() {\r\n      this.static = true;\r\n      this.layerOrder = ['grid', 'stones', 'markup'];\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Configuration\r\n     ***/\r\n\r\n    /**\r\n     * Parse config instructions\r\n     */\r\n    Board.prototype.parseConfig = function(config) {\r\n\r\n      //Validate\r\n      if (typeof config !== 'object') {\r\n        return;\r\n      }\r\n\r\n      //Extend from default config\r\n      config = angular.extend({}, defaultConfig, config);\r\n\r\n      //Process settigns\r\n      this.toggleCoordinates(config.coordinates);\r\n      this.swapColors(config.colorMultiplier);\r\n      this.setCutoff(config.cutoff);\r\n      this.setSection(config.section);\r\n      this.setSize(config.width, config.height);\r\n    };\r\n\r\n    /**\r\n     * Set margin\r\n     */\r\n    Board.prototype.setMargin = function(margin) {\r\n\r\n      //Reset when not defined\r\n      if (typeof margin === 'undefined') {\r\n        margin = this.theme.get('board.margin');\r\n      }\r\n\r\n      //Set margin if changed\r\n      if (this.margin !== margin) {\r\n        this.margin = margin;\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set grid cut-off\r\n     */\r\n    Board.prototype.setCutoff = function(cutoff) {\r\n\r\n      //Nothing given? Reset cutoff\r\n      if (!cutoff || !angular.isArray(cutoff)) {\r\n        cutoff = [];\r\n      }\r\n\r\n      //Init\r\n      var changes = false;\r\n\r\n      //Check if there's a change\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff.hasOwnProperty(side)) {\r\n          if (cutoff.indexOf(side) !== -1) {\r\n            if (!this.cutoff[side]) {\r\n              this.cutoff[side] = true;\r\n              changes = true;\r\n            }\r\n          }\r\n          else {\r\n            if (this.cutoff[side]) {\r\n              this.cutoff[side] = false;\r\n              changes = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Trigger resized if there were changes\r\n      if (changes) {\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set section of the board to be displayed\r\n     */\r\n    Board.prototype.setSection = function(section) {\r\n\r\n      //Nothing given?\r\n      if (!section || typeof section !== 'object') {\r\n        return this;\r\n      }\r\n\r\n      //Expand on default\r\n      section = angular.extend({\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      }, section);\r\n\r\n      //No changes?\r\n      if (\r\n        this.section.top === section.top && this.section.bottom === section.bottom &&\r\n        this.section.left === section.left && this.section.right === section.right\r\n      ) {\r\n        return this;\r\n      }\r\n\r\n      //Set section and call resized handler\r\n      this.section = section;\r\n      this.resized();\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set board size. This will clear the board objects.\r\n     */\r\n    Board.prototype.setSize = function(width, height) {\r\n\r\n      //Check what's given\r\n      width = parseInt(width || height || 0);\r\n      height = parseInt(height || width || 0);\r\n\r\n      //Invalid?\r\n      if (isNaN(width) || isNaN(height)) {\r\n        return;\r\n      }\r\n\r\n      //Changing?\r\n      if (width !== this.width || height !== this.height) {\r\n\r\n        //Remember size\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        //Set size in layers\r\n        for (var layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].setSize(width, height);\r\n          }\r\n        }\r\n\r\n        //Broadcast event (no call to resized, as that is handled in the directive)\r\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set new draw size\r\n     */\r\n    Board.prototype.setDrawSize = function(width, height) {\r\n      if (width !== this.drawWidth || height !== this.drawHeight) {\r\n        this.drawWidth = width;\r\n        this.drawHeight = height;\r\n        this.resized();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Toggle the coordinates\r\n     */\r\n    Board.prototype.toggleCoordinates = function(show) {\r\n\r\n      //Set or toggle\r\n      if (typeof show !== 'undefined') {\r\n        this.coordinates = show;\r\n      }\r\n      else {\r\n        this.coordinates = !this.coordinates;\r\n      }\r\n\r\n      //Set in grid layer\r\n      this.layers.grid.setCoordinates(this.coordinates);\r\n\r\n      //Set the proper board margin\r\n      if (this.coordinates) {\r\n        this.setMargin(this.theme.get('coordinates.margin'));\r\n      }\r\n      else {\r\n        this.setMargin(this.theme.get('board.margin'));\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Swap colors on the board\r\n     */\r\n    Board.prototype.swapColors = function(multiplier) {\r\n\r\n      //Multiplier not given? Set to inverse of current value\r\n      if (typeof multiplier === 'undefined') {\r\n        multiplier = -this.colorMultiplier;\r\n      }\r\n      else {\r\n        multiplier = parseInt(multiplier);\r\n        if (isNaN(multiplier)) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //No change?\r\n      if (multiplier === this.colorMultiplier) {\r\n        return;\r\n      }\r\n\r\n      //Set new value\r\n      this.colorMultiplier = multiplier;\r\n\r\n      //For static board, redraw the whole thing\r\n      if (this.static) {\r\n        this.redraw();\r\n      }\r\n\r\n      //For a dynamic board, only these layers\r\n      else {\r\n        this.redraw('stones');\r\n        this.redraw('markup');\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Theme handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the current theme object\r\n     */\r\n    Board.prototype.getTheme = function() {\r\n      return this.theme;\r\n    };\r\n\r\n    /**\r\n     * Set the theme object\r\n     */\r\n    Board.prototype.setTheme = function(theme) {\r\n      this.theme = theme;\r\n      return this;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Object handling\r\n     ***/\r\n\r\n    /**\r\n     * Add an object to a board layer\r\n     */\r\n    Board.prototype.add = function(layer, x, y, value) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].add(x, y, value);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove an object from a board layer\r\n     */\r\n    Board.prototype.remove = function(layer, x, y) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].remove(x, y);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get something from a board layer\r\n     */\r\n    Board.prototype.get = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].get(x, y));\r\n    };\r\n\r\n    /**\r\n     * Check if we have something at given coordinates for a given layer\r\n     */\r\n    Board.prototype.has = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].has(x, y));\r\n    };\r\n\r\n    /**\r\n     * Set all objects (grid) for a given layer\r\n     */\r\n    Board.prototype.setAll = function(layer, grid) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].setAll(grid);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove all objects from the board, optionally for a given layer\r\n     */\r\n    Board.prototype.removeAll = function(layer) {\r\n      if (layer) {\r\n        if (typeof this.layers[layer] !== 'undefined') {\r\n          this.layers[layer].removeAll();\r\n        }\r\n      }\r\n      else {\r\n        for (layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].removeAll();\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Position handling\r\n     ***/\r\n\r\n    /**\r\n     * Update the board with a new position\r\n     */\r\n    Board.prototype.updatePosition = function(position, pathChanged) {\r\n\r\n      //If we have no grid size yet, use what's in the position\r\n      if (!this.width || !this.height) {\r\n        this.setSize(position.width, position.height);\r\n      }\r\n\r\n      //Remove markup if path changed\r\n      if (pathChanged) {\r\n        this.removeAll('markup');\r\n      }\r\n\r\n      //Set new stones and markup grids\r\n      this.setAll('stones', position.stones);\r\n      this.setAll('markup', position.markup);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state (list of objects per layer)\r\n     */\r\n    Board.prototype.getState = function(layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          return this.layers[layer].getAll();\r\n        }\r\n        return null;\r\n      }\r\n\r\n      //All layers\r\n      var state = {};\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          var grid = this.layers[layer].getAll();\r\n          if (grid && !grid.isEmpty()) {\r\n            state[layer] = grid;\r\n          }\r\n        }\r\n      }\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the board state from given state object\r\n     */\r\n    Board.prototype.restoreState = function(state, layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          this.layers[layer].setAll(state);\r\n        }\r\n        return;\r\n      }\r\n\r\n      //All layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].removeAll();\r\n          if (state[layer]) {\r\n            this.layers[layer].setAll(state[layer]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing control\r\n     ***/\r\n\r\n    /**\r\n     * Clear the whole board\r\n     */\r\n    Board.prototype.clear = function(layer) {\r\n\r\n      //Just clearing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Clear the layer\r\n        this.layers[layer].clear();\r\n        return;\r\n      }\r\n\r\n      //Static? One clear is enough\r\n      if (this.static) {\r\n        this.layers.stones.clear();\r\n        return;\r\n      }\r\n\r\n      //Clear all layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].clear();\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Redraw everything or just a single layer\r\n     */\r\n    Board.prototype.redraw = function(layer) {\r\n\r\n      //The board can only be redrawn when there is a grid size and a draw size\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Just redrawing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Redraw the layer\r\n        this.layers[layer].redraw();\r\n        return;\r\n      }\r\n\r\n      //Clear the board first\r\n      this.clear();\r\n\r\n      //Now draw all layers again in the correct order\r\n      for (var i = 0; i < this.layerOrder.length; i++) {\r\n        layer = this.layerOrder[i];\r\n        this.layers[layer].draw();\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing helpers\r\n     ***/\r\n\r\n    /**\r\n     * Called after a board size change, draw size change, section change or margin change\r\n     */\r\n    Board.prototype.resized = function() {\r\n\r\n      //Determine the new grid\r\n      this.grid = {\r\n        xLeft: 0 + this.section.left,\r\n        xRight: this.width - 1 - this.section.right,\r\n        yTop: 0 + this.section.top,\r\n        yBot: this.height - 1 - this.section.bottom\r\n      };\r\n\r\n      //Only redraw when there is sensible data\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Determine number of cells horizontall and vertically\r\n      //The margin is a factor of the cell size, so let's add it to the number of cells\r\n      var noCellsHor = this.width + this.margin;\r\n      var noCellsVer = this.height + this.margin;\r\n\r\n      //Are we cutting off parts of the grid? Add half a cell of draw size\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff[side]) {\r\n          if (side === 'top' || side === 'bottom') {\r\n            noCellsVer += 0.5;\r\n          }\r\n          else {\r\n            noCellsHor += 0.5;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Determine cell size now\r\n      this.cellSize = Math.floor(Math.min(\r\n        this.drawWidth / noCellsHor,\r\n        this.drawHeight / noCellsVer\r\n      ));\r\n\r\n      //Determine actual grid draw size (taking off the margin again)\r\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\r\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\r\n\r\n      //Determine draw margins\r\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\r\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\r\n\r\n      //Redraw\r\n      this.redraw();\r\n    };\r\n\r\n    /**\r\n     * Get the current cell size\r\n     */\r\n    Board.prototype.getCellSize = function() {\r\n      return this.cellSize;\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsX = function(gridX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsY = function(gridY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridX = function(absX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridY = function(absY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Check if given grid coordinates are on board\r\n     */\r\n    Board.prototype.isOnBoard = function(gridX, gridY) {\r\n      return (\r\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\r\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\r\n      );\r\n    };\r\n\r\n    //Return object\r\n    return Board;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\r\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\r\n * a small rectangular area on the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('DefaultClearHandler', function() {\r\n\r\n  /**\r\n   * Clear handler definition\r\n   *\r\n   * All external handlers are called from the context of the layer that contains the object.\r\n   * First parameter is the canvas2d context, second parameter is the object itself.\r\n   */\r\n  return function(context, obj) {\r\n\r\n    //No context?\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(obj.x);\r\n    var y = this.board.getAbsY(obj.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Clear rectangle the size of the stone radius\r\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\r\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\r\n * stone color values for the game position class. It has built in validation of coordinates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Grid.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.GridChanges.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\r\n\r\n  /**\r\n   * Helper to convert a value at given coordinates to an object\r\n   */\r\n  function toObject(x, y, valueKey) {\r\n\r\n    //Create coordinates object\r\n    var obj = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Already an object?\r\n    if (typeof this.grid[x][y] === 'object') {\r\n      return angular.extend(obj, this.grid[x][y]);\r\n    }\r\n\r\n    //Not an object, set value with given value key and return\r\n    obj[valueKey] = this.grid[x][y];\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardGrid(width, height, emptyValue) {\r\n\r\n    //Initialize size and grid array\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.grid = [];\r\n    this.emptyValue = null;\r\n\r\n    //Set empty value if given\r\n    if (typeof emptyValue !== 'undefined') {\r\n      this.emptyValue = emptyValue;\r\n    }\r\n\r\n    //Size given? Set it\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a value\r\n   */\r\n  BoardGrid.prototype.set = function(x, y, value) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unset a value\r\n   */\r\n  BoardGrid.prototype.unset = function(x, y) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = this.emptyValue;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if we have a non null value on the coordinates\r\n   */\r\n  BoardGrid.prototype.has = function(x, y) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\r\n  };\r\n\r\n  /**\r\n   * Check if we have a specific value on the coordinates\r\n   */\r\n  BoardGrid.prototype.is = function(x, y, value) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\r\n  };\r\n\r\n  /**\r\n   * Get a value, or an object with coordinates and the value in the given value key\r\n   */\r\n  BoardGrid.prototype.get = function(x, y, valueKey) {\r\n\r\n    //Validate\r\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\r\n      return this.emptyValue;\r\n    }\r\n\r\n    //Return as is?\r\n    if (!valueKey) {\r\n      return this.grid[x][y];\r\n    }\r\n\r\n    //Return as object\r\n    return toObject.call(this, x, y, valueKey);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Mass operations\r\n   ***/\r\n\r\n  /**\r\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\r\n   * and the value in the given value key will be returned.\r\n   */\r\n  BoardGrid.prototype.all = function(valueKey) {\r\n\r\n    //Just get the grid?\r\n    if (!valueKey) {\r\n      return this.grid;\r\n    }\r\n\r\n    //Initialize objects list\r\n    var objects = [];\r\n\r\n    //Loop coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          objects.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return objects list\r\n    return objects;\r\n  };\r\n\r\n  /**\r\n   * Check if there is anything\r\n   */\r\n  BoardGrid.prototype.isEmpty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Populate the whole grid with a given value\r\n   */\r\n  BoardGrid.prototype.populate = function(value) {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = value;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Empty the grid\r\n   */\r\n  BoardGrid.prototype.empty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clone ourselves\r\n   */\r\n  BoardGrid.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newGrid = new BoardGrid();\r\n\r\n    //Manually set vars for maximum efficiency\r\n    newGrid.grid = angular.copy(this.grid);\r\n    newGrid.emptyValue = this.emptyValue;\r\n    newGrid.width = this.width;\r\n    newGrid.height = this.height;\r\n\r\n    //Return\r\n    return newGrid;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Comparison\r\n   ***/\r\n\r\n  /**\r\n   * Checks if a given grid is the same as the current grid\r\n   */\r\n  BoardGrid.prototype.isSameAs = function(grid) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== grid.width || this.height !== grid.height) {\r\n      return false;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== grid[x][y]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    //No differences found\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Compares this position with another position and return change object\r\n   */\r\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\r\n\r\n    //Initialize board grid changes object\r\n    var changes = new BoardGridChanges();\r\n\r\n    //Must have the same size\r\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\r\n      console.warn('Trying to compare grids of a different size');\r\n      return changes;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n\r\n        //Something to add?\r\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\r\n        }\r\n\r\n        //Something to remove?\r\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.remove.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return changes grid\r\n    return changes;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to validate coordinates (first param can be an object)\r\n   */\r\n  BoardGrid.prototype.isOnGrid = function(x, y) {\r\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\r\n  };\r\n\r\n  /**\r\n   * Helper to set the empty value\r\n   */\r\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\r\n    this.emptyValue = emptyValue;\r\n  };\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  BoardGrid.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Create grid array\r\n    this.grid = [];\r\n    for (var x = 0; x < this.width; x++) {\r\n      this.grid[x] = [];\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the grid size object\r\n   */\r\n  BoardGrid.prototype.getSize = function() {\r\n    return {width: this.width, height: this.height};\r\n  };\r\n\r\n  //Return\r\n  return BoardGrid;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\r\n * grids. It simply keeps track of what was added and what was removed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.GridChanges.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGridChanges', function() {\r\n\r\n  /**\r\n   * Helper to subtract sets\r\n   */\r\n  function setSubtract(a, b) {\r\n    var n = [];\r\n    var q;\r\n    for (var i = 0; i < a.length; i++) {\r\n      q = true;\r\n      for (var j in b) {\r\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\r\n          q = false;\r\n          break;\r\n        }\r\n      }\r\n      if (q) {\r\n        n.push(a[i]);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /**\r\n   * Grid changes constructor\r\n   */\r\n  return function() {\r\n\r\n    /**\r\n     * Containers\r\n     */\r\n    this.add = [];\r\n    this.remove = [];\r\n\r\n    /**\r\n     * Concatenation helper\r\n     */\r\n    this.concat = function(newChanges) {\r\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\r\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\r\n    };\r\n\r\n    /**\r\n     * Check if there are changes\r\n     */\r\n    this.has = function() {\r\n      return !!(this.add.length || this.remove.length);\r\n    };\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\r\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\r\n * for drawing itself as well as its objects onto the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardLayer(board, context) {\r\n\r\n    //Remember board reference and 2d canvas context\r\n    this.board = board;\r\n    this.context = context;\r\n\r\n    //Initialize grid for board objects\r\n    this.grid = new BoardGrid();\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Generic grid and object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set grid size\r\n   */\r\n  BoardLayer.prototype.setSize = function(width, height) {\r\n\r\n    //Note: since this method is usually only called upon a global board resize,\r\n    //which also triggers the redraw method for layers, the layer is not cleared\r\n    //here, as it will happen anyway during the redraw cycle.\r\n\r\n    //Set it in the grid (removing all objects in the process)\r\n    this.grid.setSize(width, height);\r\n  };\r\n\r\n  /**\r\n   * Get all items\r\n   */\r\n  BoardLayer.prototype.getAll = function() {\r\n    return this.grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Set all items at once\r\n   */\r\n  BoardLayer.prototype.setAll = function(grid) {\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  BoardLayer.prototype.removeAll = function() {\r\n    this.clear();\r\n    this.grid.empty();\r\n  };\r\n\r\n  /**\r\n   * Add a single item\r\n   */\r\n  BoardLayer.prototype.add = function(x, y, value) {\r\n    this.clearCell(x, y);\r\n    this.grid.set(x, y, value);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Remove a single item\r\n   */\r\n  BoardLayer.prototype.remove = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.grid.unset(x, y);\r\n  };\r\n\r\n  /**\r\n   * Get an item\r\n   */\r\n  BoardLayer.prototype.get = function(x, y) {\r\n    return this.grid.get(x, y);\r\n  };\r\n\r\n  /**\r\n   * Check if there is an item\r\n   */\r\n  BoardLayer.prototype.has = function(x, y) {\r\n    return this.grid.has(x, y);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Generic drawing methods\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  BoardLayer.prototype.draw = function() {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\r\n   */\r\n  BoardLayer.prototype.clear = function() {\r\n    if (this.context) {\r\n      this.context.clearRect(\r\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  BoardLayer.prototype.redraw = function() {\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\r\n    //Clearing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Redraw cell\r\n   */\r\n  BoardLayer.prototype.redrawCell = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Set the canvas2d context\r\n   */\r\n  BoardLayer.prototype.setContext = function(context) {\r\n    this.context = context;\r\n  };\r\n\r\n  /**\r\n   * Get the canvas2d context\r\n   */\r\n  BoardLayer.prototype.getContext = function() {\r\n    return this.context;\r\n  };\r\n\r\n  //Return\r\n  return BoardLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardObject :: Base class for drawing board objects\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.DefaultClearHandler.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var BoardObject = {\r\n\r\n    /**\r\n     * Draw method\r\n     */\r\n    draw: function(/*obj*/) {\r\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear method\r\n     */\r\n    clear: function(obj) {\r\n      DefaultClearHandler.call(this, this.context, obj);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return BoardObject;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.ShellPattern.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShellPattern', function() {\r\n\r\n  /**\r\n   * Helper to draw a shell line\r\n   */\r\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\r\n\r\n    //Initialize\r\n    ctx.shadowBlur = 2;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = (radius / 30) * this.thickness;\r\n    ctx.beginPath();\r\n\r\n    //Lower radius\r\n    radius -= Math.max(1, ctx.lineWidth);\r\n\r\n    //Determine coordinates\r\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\r\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\r\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\r\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\r\n\r\n    //Math magic\r\n    var m, angle;\r\n    if (x2 > x1) {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m);\r\n    }\r\n    else if (x2 === x1) {\r\n      angle = Math.PI / 2;\r\n    }\r\n    else {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m) - Math.PI;\r\n    }\r\n\r\n    //Curvature factor\r\n    var c = this.factor * radius;\r\n    var dx = Math.sin(angle) * c;\r\n    var dy = Math.cos(angle) * c;\r\n\r\n    //Curvature coordinates\r\n    var bx1 = x1 + dx;\r\n    var by1 = y1 - dy;\r\n    var bx2 = x2 + dx;\r\n    var by2 = y2 - dy;\r\n\r\n    //Draw shell stroke\r\n    ctx.moveTo(x1, y1);\r\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Shell pattern drawer\r\n   */\r\n  return function(ctx, x, y, radius, angle, strokeStyle) {\r\n\r\n    //Initialize start and end angle\r\n    var startAngle = angle;\r\n    var endAngle = angle;\r\n\r\n    //Loop lines\r\n    for (var i = 0; i < this.lines.length; i++) {\r\n      startAngle += this.lines[i];\r\n      endAngle -= this.lines[i];\r\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\r\n    }\r\n  };\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\r\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\r\n * use static values or dynamic values depending on other properties, like the grid cell size.\r\n * Using the provider, the theme can be configured globally at application launch.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Theme.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\r\n\r\n  /**\r\n   * Default theme\r\n   */\r\n  var defaultTheme = {\r\n\r\n    //Board\r\n    board: {\r\n\r\n      //Board margin factor\r\n      margin: 0.25\r\n    },\r\n\r\n    //Stones\r\n    stone: {\r\n\r\n      //Stone style can be shell, glass, mono, or specify a custom handler service\r\n      style: 'shell',\r\n      shadow: true,\r\n      radius: function(cellSize) {\r\n        return Math.floor(cellSize / 2);\r\n      },\r\n\r\n      //Shell stones\r\n      shell: {\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#111';\r\n          }\r\n          return '#BFBFBA';\r\n        },\r\n        stroke: 'rgba(128,128,128,0.15)',\r\n        types: [\r\n          {\r\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\r\n            factor: 0.15,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\r\n            factor: 0.1,\r\n            thickness: 1.5\r\n          },\r\n          {\r\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\r\n            factor: 0.05,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\r\n            factor: 0.1,\r\n            thickness: 2\r\n          }\r\n        ]\r\n      },\r\n\r\n      //Mono stones\r\n      mono: {\r\n        lineWidth: 1,\r\n        lineColor: function() {\r\n          return '#000';\r\n        },\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#000';\r\n          }\r\n          return '#fff';\r\n        }\r\n      },\r\n\r\n      //Mini stones\r\n      mini: {\r\n        scale: 0.5,\r\n        alpha: 1\r\n      },\r\n\r\n      //Faded stones\r\n      faded: {\r\n        scale: 1,\r\n        alpha: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return 0.3;\r\n          }\r\n          return 0.4;\r\n        }\r\n      }\r\n    },\r\n\r\n    //Shadows\r\n    shadow: {\r\n\r\n      //Shadow gradient colors\r\n      color: 'rgba(40,30,20,0.5)',\r\n\r\n      //Shadow size\r\n      size: function(cellSize) {\r\n        return Math.floor(cellSize / 20);\r\n      },\r\n\r\n      //Shadow blur size\r\n      blur: function(cellSize) {\r\n        return cellSize / 20;\r\n      },\r\n\r\n      //Shadow offset\r\n      offsetX: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      },\r\n      offsetY: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      }\r\n    },\r\n\r\n    //Markup\r\n    markup: {\r\n\r\n      //Standard color\r\n      color: function(stoneColor) {\r\n        if (stoneColor === StoneColor.B) {\r\n          return 'rgba(255,255,255,0.9)';\r\n        }\r\n        return 'rgba(0,0,0,0.9)';\r\n      },\r\n\r\n      //Line width\r\n      lineWidth: function(cellSize) {\r\n        return Math.max(1, Math.floor(cellSize / 16));\r\n      },\r\n\r\n      //Triangle\r\n      triangle: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Square\r\n      square: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Cricle\r\n      circle: {\r\n        scale: 0.55\r\n      },\r\n\r\n      //Mark\r\n      mark: {\r\n        lineCap: 'square',\r\n        scale: 0.75\r\n      },\r\n\r\n      //Last\r\n      last: {\r\n        scale: 0.7\r\n      },\r\n\r\n      //Smiley\r\n      smiley: {\r\n        lineCap: 'round',\r\n        scale: 0.85\r\n      },\r\n\r\n      //Label\r\n      label: {\r\n        font: 'Arial'\r\n      },\r\n\r\n      //Variation markup\r\n      variation: {\r\n        type: MarkupTypes.LABEL,\r\n        text: function(i) {\r\n          return String.fromCharCode(65 + i);\r\n        },\r\n        color: 'rgba(86,114,30,0.9)'\r\n      },\r\n\r\n      //Solution paths markup\r\n      solution: {\r\n        valid: {\r\n          type: MarkupTypes.SELECT,\r\n          text: null,\r\n          color: 'rgba(86,114,30,1)',\r\n          scale: 0.5\r\n        },\r\n        invalid: {\r\n          type: MarkupTypes.MARK,\r\n          text: null,\r\n          color: 'rgba(237,9,15,1)',\r\n          scale: 0.3\r\n        }\r\n      }\r\n    },\r\n\r\n    //Grid\r\n    grid: {\r\n\r\n      //Line properties\r\n      lineColor: 'rgba(60,40,15,1)',\r\n      lineWidth: function(cellSize) {\r\n        if (cellSize > 60) {\r\n          return 2;\r\n        }\r\n        else if (cellSize > 50) {\r\n          return 1.5;\r\n        }\r\n        return 1;\r\n      },\r\n      lineCap: 'square',\r\n\r\n      //Star points\r\n      star: {\r\n\r\n        //Color and radius\r\n        color: 'rgba(60,40,15,1)',\r\n        radius: function(cellSize) {\r\n          if (cellSize > 50) {\r\n            return Math.floor((cellSize / 16) + 1);\r\n          }\r\n          else if (cellSize > 30) {\r\n            return 3;\r\n          }\r\n          else if (cellSize > 15) {\r\n            return 2;\r\n          }\r\n          else if (cellSize > 5) {\r\n            return 1.5;\r\n          }\r\n          return 1;\r\n        },\r\n\r\n        //Locations\r\n        points: function(width, height) {\r\n\r\n          //19x19\r\n          if (width === height && width === 19) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\r\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\r\n            ];\r\n          }\r\n\r\n          //13x13\r\n          if (width === height && width === 13) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }\r\n            ];\r\n          }\r\n\r\n          //9x9\r\n          if (width === height && width === 9) {\r\n            return [\r\n              { x: 4, y: 4}, { x: 2, y: 2},\r\n              { x: 2, y: 6}, { x: 6, y: 2},\r\n              { x: 6, y: 6}\r\n            ];\r\n          }\r\n\r\n          //No star points\r\n          return [];\r\n        }\r\n      }\r\n    },\r\n\r\n    //Coordinates\r\n    coordinates: {\r\n\r\n      //Color\r\n      color: 'rgba(101,69,37,0.5)',\r\n\r\n      //Board margin factor when showing coordinates\r\n      margin: 1.25,\r\n\r\n      //Vertical coordinates style\r\n      vertical: {\r\n        font: 'Arial',\r\n        style: 'numbers',\r\n        inverse: true,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      },\r\n\r\n      //Horizontal coordinates style\r\n      horizontal: {\r\n        font: 'Arial',\r\n        style: 'letters',\r\n        inverse: false,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Set global default theme\r\n   */\r\n  this.setTheme = function(theme) {\r\n    if (theme) {\r\n      defaultTheme = angular.merge(defaultTheme, theme);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = function() {\r\n\r\n    /**\r\n     * Board theme constructor\r\n     */\r\n    function BoardTheme(theme) {\r\n\r\n      //Remember the given instance theme settings and (re)set the theme\r\n      this.instanceTheme = theme;\r\n      this.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the theme to defaults\r\n     */\r\n    BoardTheme.prototype.reset = function() {\r\n\r\n      //Use default theme as a base\r\n      this.theme = angular.copy(defaultTheme);\r\n\r\n      //Add any instance theme properties\r\n      if (this.instanceTheme) {\r\n        angular.merge(this.theme, this.instanceTheme);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get a theme property\r\n     */\r\n    BoardTheme.prototype.get = function(property) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Can't find the property?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          console.warn('Could not find theme property', property);\r\n          return null;\r\n        }\r\n\r\n        //Advance further in the object\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Found what we're looking for\r\n      if (typeof prop !== 'function') {\r\n        return prop;\r\n      }\r\n\r\n      //Prepare arguments\r\n      var args = [];\r\n      if (arguments.length > 1) {\r\n        for (var a = 1; a < arguments.length; a++) {\r\n          args.push(arguments[a]);\r\n        }\r\n      }\r\n\r\n      //Call function\r\n      return prop.apply(this, args);\r\n    };\r\n\r\n    /**\r\n     * Change a theme property dynamically (accepts handler function as value)\r\n     */\r\n    BoardTheme.prototype.set = function(property, value) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Time to set?\r\n        if ((i + 1) === path.length) {\r\n          prop[path[i]] = value;\r\n          break;\r\n        }\r\n\r\n        //Not set?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          prop[path[i]] = {};\r\n        }\r\n\r\n        //Move on\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\r\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\r\n     */\r\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\r\n\r\n      //If no linewidth specified, use the grid line width as a reference\r\n      //to make sure stuff is aligned to the grid\r\n      if (typeof lineWidth === 'undefined') {\r\n        lineWidth = this.get('grid.lineWidth');\r\n      }\r\n\r\n      //Return a translation for uneven widths\r\n      return (lineWidth % 2) * 0.5;\r\n    };\r\n\r\n    //Return\r\n    return BoardTheme;\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Game :: This class represents a game record or a game that is being played/edited. The class\r\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\r\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\r\n * The class also keeps a stack of all board positions in memory and can validate moves to make\r\n * sure they are not repeating or suicide.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Path.Service',\r\n  'ngGo.Game.Node.Service',\r\n  'ngGo.Game.Position.Service',\r\n  'ngGo.Kifu.Blank.Service',\r\n  'ngGo.Kifu.Parser.Service',\r\n  'ngGo.Errors.InvalidDataError.Service',\r\n  'ngGo.Errors.InvalidPositionError.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('Game', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default size of board\r\n    defaultSize: 0,\r\n\r\n    //Default komi and handicap\r\n    defaultKomi: 0,\r\n    defaultHandicap: 0,\r\n\r\n    //Remember last selected variation when traversing nodes\r\n    rememberPath: true,\r\n\r\n    //Check for repeating positions? (KO / ALL / empty)\r\n    checkRepeat: 'KO',\r\n\r\n    //Allow suicide?\r\n    allowSuicide: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\r\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\r\n    KifuBlank, InvalidDataError, InvalidPositionError\r\n  ) {\r\n\r\n    /*****************************************************************************\r\n     * General helpers\r\n     ***/\r\n\r\n    /**\r\n     * Validate the info we have to make sure the properties exist\r\n     */\r\n    function validateInfo() {\r\n\r\n      //Set board info if not set\r\n      if (!this.info.board) {\r\n        this.info.board = {};\r\n      }\r\n\r\n      //Set game info if not set\r\n      if (!this.info.game) {\r\n        this.info.game = {};\r\n      }\r\n\r\n      //Set defaults\r\n      if (typeof this.info.board.width === 'undefined') {\r\n        this.info.board.width = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.board.height === 'undefined') {\r\n        this.info.board.height = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.game.komi === 'undefined') {\r\n        this.info.game.komi = this.config.defaultKomi;\r\n      }\r\n      if (typeof this.info.game.handicap === 'undefined') {\r\n        this.info.game.handicap = this.config.defaultHandicap;\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Node navigation helpers\r\n     ***/\r\n\r\n    /**\r\n     * Navigate to the next node\r\n     */\r\n    function nextNode(i) {\r\n\r\n      //Check if we have children\r\n      if (this.node.children.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      //Remembered the path we took earlier?\r\n      if (i === undefined) {\r\n        i = this.node.rememberedPath;\r\n      }\r\n\r\n      //Determine which child node to process\r\n      i = i || 0;\r\n      if (i === -1) {\r\n        i = 0;\r\n      }\r\n\r\n      //Validate\r\n      if (i >= this.node.children.length || !this.node.children[i]) {\r\n        return false;\r\n      }\r\n\r\n      //Advance path\r\n      this.path.advance(i);\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.children[i];\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the previous node\r\n     */\r\n    function previousNode() {\r\n\r\n      //No parent node?\r\n      if (!this.node.parent) {\r\n        return false;\r\n      }\r\n\r\n      //Retreat path\r\n      this.path.retreat();\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.parent;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the first node\r\n     */\r\n    function firstNode() {\r\n\r\n      //Reset path\r\n      this.path.reset();\r\n\r\n      //Set node pointer back to root\r\n      this.node = this.root;\r\n\r\n      //Set the initial turn depending on handicap\r\n      //Can be overwritten by game record instructions\r\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Position history helpers\r\n     ***/\r\n\r\n    /**\r\n     * Clear the position history and initialize with a blank position\r\n     */\r\n    function initializeHistory() {\r\n\r\n      //Already at beginning?\r\n      if (this.history.length === 1) {\r\n        return;\r\n      }\r\n\r\n      //Clear positions stack and create new blank position\r\n      this.history = [];\r\n      this.history.push(new GamePosition());\r\n\r\n      //Set board size if we have the info\r\n      if (this.info.board) {\r\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add position to stack. If position isn't specified current position is\r\n     * cloned and stacked. Pointer of actual position is moved to the new position.\r\n     */\r\n    function pushPosition(newPosition) {\r\n\r\n      //Position not given?\r\n      if (!newPosition) {\r\n        newPosition = this.position.clone();\r\n      }\r\n\r\n      //Push\r\n      this.history.push(newPosition);\r\n      return newPosition;\r\n    }\r\n\r\n    /**\r\n     * Remove current position from stack\r\n     */\r\n    function popPosition() {\r\n\r\n      //Nothing left?\r\n      if (this.history.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      //Get old position\r\n      return this.history.pop();\r\n    }\r\n\r\n    /**\r\n     * Replace the current position in the stack\r\n     */\r\n    function replacePosition(newPosition) {\r\n      if (newPosition) {\r\n        this.history.pop();\r\n        this.history.push(newPosition);\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Execution helpers\r\n     ***/\r\n\r\n    /**\r\n     * Execute the current node\r\n     */\r\n    function executeNode() {\r\n\r\n      //Remember last selected node if we have a parent\r\n      if (this.node.parent) {\r\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\r\n      }\r\n\r\n      //Initialize new position\r\n      var i;\r\n      var newPosition = this.position.clone();\r\n\r\n      //Handle moves\r\n      if (this.node.isMove()) {\r\n        if (this.node.move.pass) {\r\n          newPosition.setTurn(-this.node.move.color);\r\n        }\r\n        else {\r\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\r\n        }\r\n      }\r\n\r\n      //Handle turn instructions\r\n      if (this.node.turn) {\r\n        newPosition.setTurn(this.node.turn);\r\n      }\r\n\r\n      //Handle setup instructions\r\n      if (this.node.setup) {\r\n        for (i in this.node.setup) {\r\n          if (this.node.setup.hasOwnProperty(i)) {\r\n            newPosition.stones.set(\r\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Handle markup\r\n      if (this.node.markup) {\r\n        for (i in this.node.markup) {\r\n          if (this.node.markup.hasOwnProperty(i)) {\r\n            newPosition.markup.set(\r\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Push the new position into the history now\r\n      pushPosition.call(this, newPosition);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Game class\r\n     ***/\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Game(data, config) {\r\n\r\n      //Extend config\r\n      this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n      //Define property getter/setter for position\r\n      Object.defineProperty(this, 'position', {\r\n\r\n        //Getter returns the last position from the stack\r\n        get: function() {\r\n          return this.history[this.history.length - 1];\r\n        },\r\n\r\n        //Setter adds a new position to the stack\r\n        set: function(newPosition) {\r\n          this.history[this.history.length] = newPosition;\r\n        }\r\n      });\r\n\r\n      //Load data\r\n      if (data) {\r\n        this.load(data);\r\n      }\r\n      else {\r\n        this.init();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Initialize\r\n     */\r\n    Game.prototype.init = function() {\r\n\r\n      //Info properties\r\n      this.info = {};\r\n\r\n      //The rood node and pointer to the current node\r\n      this.root = null;\r\n      this.node = null;\r\n\r\n      //Game path\r\n      this.path = new GamePath();\r\n\r\n      //JGF record we loaded from\r\n      this.jgf = null;\r\n\r\n      //Positions history stack\r\n      this.history = [];\r\n    };\r\n\r\n    /**\r\n     * Load game record data\r\n     */\r\n    Game.prototype.load = function(data) {\r\n\r\n      //Initialize\r\n      this.init();\r\n\r\n      //Try to load game record data\r\n      try {\r\n        this.fromData(data);\r\n      }\r\n      catch (errorCode) {\r\n\r\n        //Just initialize our history with a blank position\r\n        initializeHistory.call(this);\r\n\r\n        //Wrap error code in error object\r\n        throw new InvalidDataError(errorCode);\r\n      }\r\n\r\n      //Go to the first move\r\n      this.first();\r\n    };\r\n\r\n    /**\r\n     * Reload game record\r\n     */\r\n    Game.prototype.reload = function() {\r\n      if (this.jgf) {\r\n        this.load(this.jgf);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if we managed to load a valid game record\r\n     */\r\n    Game.prototype.isLoaded = function() {\r\n      return this.root !== null;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game cloning and conversion\r\n     ***/\r\n\r\n    /**\r\n     * Clone this game\r\n     */\r\n    Game.prototype.clone = function() {\r\n\r\n      //Create new kifu object and get properties\r\n      var clone = new Game();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy all properties\r\n      for (var p = 0; p < props.length; p++) {\r\n        clone[p] = angular.copy(this[p]);\r\n      }\r\n\r\n      //Return clone\r\n      return clone;\r\n    };\r\n\r\n    /**\r\n     * Load from an unknown data source\r\n     */\r\n    Game.prototype.fromData = function(data) {\r\n\r\n      //No data, can't do much\r\n      if (!data) {\r\n        throw ngGo.error.NO_DATA;\r\n      }\r\n\r\n      //String given, could be stringified JGF, an SGF or GIB file\r\n      if (typeof data === 'string') {\r\n        var c = data.charAt(0);\r\n        if (c === '(') {\r\n          return this.fromSgf(data);\r\n        }\r\n        else if (c === '{' || c === '[') {\r\n          return this.fromJgf(data);\r\n        }\r\n        else if (c === '\\\\') {\r\n          return this.fromGib(data);\r\n        }\r\n        else {\r\n          throw ngGo.error.UNKNOWN_DATA;\r\n        }\r\n      }\r\n\r\n      //Object given? Probably a JGF object\r\n      else if (typeof data === 'object') {\r\n        this.fromJgf(data);\r\n      }\r\n\r\n      //Something else?\r\n      else {\r\n        throw ngGo.error.UNKNOWN_DATA;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Load from GIB data\r\n     */\r\n    Game.prototype.fromGib = function(gib) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.gib2jgf(gib);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_GIB;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from SGF data\r\n     */\r\n    Game.prototype.fromSgf = function(sgf) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.sgf2jgf(sgf);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_SGF;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from JGF data\r\n     */\r\n    Game.prototype.fromJgf = function(jgf) {\r\n\r\n      //Parse jgf string\r\n      if (typeof jgf === 'string') {\r\n        try {\r\n          jgf = angular.fromJson(jgf);\r\n        }\r\n        catch (error) {\r\n          throw ngGo.error.INVALID_JGF_JSON;\r\n        }\r\n      }\r\n\r\n      //If array given, convert to object with only tree\r\n      if (angular.isArray(jgf)) {\r\n        jgf = {\r\n          tree: jgf\r\n        };\r\n      }\r\n\r\n      //Parse tree string\r\n      if (typeof jgf.tree === 'string') {\r\n        if (jgf.tree.charAt(0) === '[') {\r\n          try {\r\n            jgf.tree = angular.fromJson(jgf.tree);\r\n          }\r\n          catch (error) {\r\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\r\n          }\r\n        }\r\n        else {\r\n          jgf.tree = [];\r\n        }\r\n      }\r\n\r\n      //Copy all properties except moves tree\r\n      for (var i in jgf) {\r\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\r\n          this.info[i] = angular.copy(jgf[i]);\r\n        }\r\n      }\r\n\r\n      //Validate info\r\n      validateInfo.call(this);\r\n\r\n      //Create root node\r\n      this.root = new GameNode();\r\n\r\n      //Tree given? Load all the moves\r\n      if (jgf.tree) {\r\n        this.root.fromJgf(jgf.tree);\r\n      }\r\n\r\n      //Remember JGF\r\n      this.jgf = jgf;\r\n    };\r\n\r\n    /**\r\n     * Convert to SGF\r\n     */\r\n    Game.prototype.toSgf = function() {\r\n      return KifuParser.jgf2sgf(this.toJgf());\r\n    };\r\n\r\n    /**\r\n     * Convert to JGF (optionally stringified)\r\n     */\r\n    Game.prototype.toJgf = function(stringify) {\r\n\r\n      //Initialize JGF and get properties\r\n      var jgf = KifuBlank.jgf();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy properties\r\n      for (var p = 0; p < props.length; p++) {\r\n\r\n        //Skip root\r\n        if (p === 'root') {\r\n          continue;\r\n        }\r\n\r\n        //Already present on JGF object? Extend\r\n        if (jgf[p]) {\r\n          jgf[p] = angular.extend(jgf[p], this[p]);\r\n        }\r\n\r\n        //Otherwise copy\r\n        else {\r\n          jgf[p] = angular.copy(this[p]);\r\n        }\r\n      }\r\n\r\n      //Build tree\r\n      jgf.tree = this.root.toJgf();\r\n\r\n      //Return\r\n      return stringify ? angular.toJson(jgf) : jgf;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Getters\r\n     ***/\r\n\r\n    /**\r\n     * Get current node\r\n     */\r\n    Game.prototype.getNode = function() {\r\n      return this.node;\r\n    };\r\n\r\n    /**\r\n     * Get nodes array for currently remembered path\r\n     */\r\n    Game.prototype.getNodes = function() {\r\n\r\n      //Initialize node to process\r\n      var node = this.root;\r\n      var nodes = [node];\r\n\r\n      //Process children\r\n      while (node) {\r\n        node = node.getChild(node.rememberedPath);\r\n        if (node) {\r\n          nodes.push(node);\r\n        }\r\n      }\r\n\r\n      //Return nodes\r\n      return nodes;\r\n    };\r\n\r\n    /**\r\n     * Get node for a certain move\r\n     */\r\n    Game.prototype.getMoveNode = function(move) {\r\n      var nodes = this.getMoveNodes(move, move);\r\n      return nodes.length ? nodes[0] : null;\r\n    };\r\n\r\n    /**\r\n     * Get move nodes restricted by given move numbers\r\n     */\r\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\r\n\r\n      //Get all nodes for the current path\r\n      var nodes = this.getNodes();\r\n\r\n      //Use sensible defaults if no from/to moves given\r\n      fromMove = fromMove || 1;\r\n      toMove = toMove || nodes.length;\r\n\r\n      //Filter\r\n      return nodes.filter(function(node) {\r\n        if (node.isMove()) {\r\n          var move = node.getMoveNumber();\r\n          return (move >= fromMove && move <= toMove);\r\n        }\r\n        return false;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Get current move number\r\n     */\r\n    Game.prototype.getMove = function() {\r\n      if (this.node) {\r\n        return this.node.getMoveNumber();\r\n      }\r\n      return 0;\r\n    };\r\n\r\n    /**\r\n     * Get the number of moves in the main branch\r\n     */\r\n    Game.prototype.getMoveCount = function() {\r\n      var moveNodes = this.getMoveNodes();\r\n      return moveNodes.length;\r\n    };\r\n\r\n    /**\r\n     * Get the move variation for given coordinates\r\n     */\r\n    Game.prototype.getMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.getMoveVariation(x, y);\r\n      }\r\n      return -1;\r\n    };\r\n\r\n    /**\r\n     * Get the current game position\r\n     */\r\n    Game.prototype.getPosition = function() {\r\n      return this.position;\r\n    };\r\n\r\n    /**\r\n     * Get the game path\r\n     */\r\n    Game.prototype.getPath = function(clone) {\r\n      if (clone) {\r\n        return this.path.clone();\r\n      }\r\n      return this.path;\r\n    };\r\n\r\n    /**\r\n     * Clone the current game path\r\n     */\r\n    Game.prototype.clonePath = function() {\r\n      return this.path.clone();\r\n    };\r\n\r\n    /**\r\n     * Get the game path to a certain named node\r\n     */\r\n    Game.prototype.getPathToNode = function(nodeName) {\r\n      return GamePath.findNode(nodeName, this.root);\r\n    };\r\n\r\n    /**\r\n     * Get the game komi\r\n     */\r\n    Game.prototype.getKomi = function() {\r\n      var komi = this.get('game.komi', 0);\r\n      return parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Set the game komi\r\n     */\r\n    Game.prototype.setKomi = function(komi) {\r\n      if (typeof komi === 'undefined') {\r\n        komi = this.config.defaultKomi;\r\n      }\r\n      this.info.game.komi = parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Get the game name\r\n     */\r\n    Game.prototype.getName = function() {\r\n      return this.get('game.name', '');\r\n    };\r\n\r\n    /**\r\n     * Get the game result\r\n     */\r\n    Game.prototype.getResult = function() {\r\n      return this.get('game.result', '');\r\n    };\r\n\r\n    /**\r\n     * Get the player turn for this position\r\n     */\r\n    Game.prototype.getTurn = function() {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return StoneColor.B;\r\n      }\r\n\r\n      //Get from position\r\n      return this.position.getTurn();\r\n    };\r\n\r\n    /**\r\n     * Set the player turn for the current position\r\n     */\r\n    Game.prototype.setTurn = function(color) {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return;\r\n      }\r\n\r\n      //Set in position\r\n      this.position.setTurn(color);\r\n    };\r\n\r\n    /**\r\n     * Get the total capture count up to the current position\r\n     */\r\n    Game.prototype.getCaptureCount = function() {\r\n\r\n      //Initialize\r\n      var captures = {};\r\n      captures[StoneColor.B] = 0;\r\n      captures[StoneColor.W] = 0;\r\n\r\n      //Loop all positions and increment capture count\r\n      for (var i = 0; i < this.history.length; i++) {\r\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\r\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\r\n      }\r\n\r\n      //Return\r\n      return captures;\r\n    };\r\n\r\n    /**\r\n     * Get an info property\r\n     */\r\n    Game.prototype.get = function(property, defaultValue) {\r\n\r\n      //Must have a property\r\n      if (!property) {\r\n        return;\r\n      }\r\n\r\n      //The item's property in the object is given by dot separated strings\r\n      if (typeof property === 'string') {\r\n        property = property.split('.');\r\n      }\r\n\r\n      //Initialize object we're getting info from\r\n      var obj = this.info;\r\n      var key;\r\n\r\n      //Loop the properties\r\n      for (var p = 0; p < property.length; p++) {\r\n\r\n        //Get actual key\r\n        key = property[p];\r\n\r\n        //Last key reached? Done, get value\r\n        if ((p + 1) === property.length) {\r\n          if (typeof obj[key] === 'undefined') {\r\n            return defaultValue;\r\n          }\r\n          return obj[key];\r\n        }\r\n\r\n        //Must be object container\r\n        if (typeof obj[key] !== 'object') {\r\n          console.warn('Game info property', key, 'is not an object');\r\n          return defaultValue;\r\n        }\r\n\r\n        //Move up in tree\r\n        obj = obj[key];\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Checkers\r\n     ***/\r\n\r\n    /**\r\n     * Check if coordinates are on the board\r\n     */\r\n    Game.prototype.isOnBoard = function(x, y) {\r\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\r\n    };\r\n\r\n    /**\r\n     * Check if given coordinates are one of the next child node coordinates\r\n     */\r\n    Game.prototype.isMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.isMoveVariation(x, y);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Check if a given position is repeating within this game\r\n     */\r\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\r\n\r\n      //Init\r\n      var stop;\r\n\r\n      //Check for ko only? (Last two positions)\r\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\r\n        stop = this.history.length - 2;\r\n      }\r\n\r\n      //Check all history?\r\n      else if (this.checkRepeat === 'ALL') {\r\n        stop = 0;\r\n      }\r\n\r\n      //Not repeating\r\n      else {\r\n        return false;\r\n      }\r\n\r\n      //Loop history of positions to check\r\n      for (var i = this.history.length - 2; i >= stop; i--) {\r\n        if (checkPosition.isSameAs(this.history[i])) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      //Not repeating\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Wrapper for validateMove() returning a boolean and catching any errors\r\n     */\r\n    Game.prototype.isValidMove = function(x, y, color) {\r\n      try {\r\n        this.validateMove(x, y, color);\r\n        return true;\r\n      }\r\n      catch (error) {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if a move is valid. If valid, the new game position object is returned.\r\n     * You can supply a pre-created position to use, or the current position is cloned.\r\n     */\r\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Something already here?\r\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\r\n      }\r\n\r\n      //Set color of move to make\r\n      color = color || this.position.getTurn();\r\n\r\n      //Determine position to use\r\n      newPosition = newPosition || this.position.clone();\r\n\r\n      //Place the stone\r\n      newPosition.stones.set(x, y, color);\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = newPosition.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created?\r\n        if (!newPosition.hasLiberties(x, y)) {\r\n\r\n          //Capture the group if it's allowed\r\n          if (this.allowSuicide) {\r\n            newPosition.captureGroup(x, y);\r\n          }\r\n\r\n          //Invalid move\r\n          else {\r\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Check history for repeating moves\r\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\r\n      }\r\n\r\n      //Set proper turn\r\n      newPosition.setTurn(-color);\r\n\r\n      //Move is valid\r\n      return newPosition;\r\n    };\r\n\r\n    /**\r\n     * Check if a stone (setup) placement is valid.\r\n     */\r\n    Game.prototype.validatePlacement = function(x, y, color, position) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Place the stone\r\n      position.stones.set(x, y, color);\r\n\r\n      //Empty spot? Don't need to check for captures\r\n      if (color === StoneColor.EMPTY) {\r\n        return;\r\n      }\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = position.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created? Capture it\r\n        if (!position.hasLiberties(x, y)) {\r\n          position.captureGroup(x, y);\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Stone and markup handling\r\n     ***/\r\n\r\n    /**\r\n     * Add a stone\r\n     */\r\n    Game.prototype.addStone = function(x, y, color) {\r\n\r\n      //Check if there's anything to do at all\r\n      if (this.position.stones.is(x, y, color)) {\r\n        return;\r\n      }\r\n\r\n      //Create temporary position\r\n      var tempPosition = this.position.clone();\r\n\r\n      //Validate placement on temp position\r\n      this.validatePlacement(x, y, color, tempPosition);\r\n\r\n      //No setup instructions container in this node?\r\n      if (typeof this.node.setup === 'undefined') {\r\n\r\n        //Is this a move node?\r\n        if (this.node.isMove()) {\r\n\r\n          //Clone our position\r\n          pushPosition.call(this);\r\n\r\n          //Create new node\r\n          var node = new GameNode();\r\n\r\n          //Append it to the current node and change the pointer\r\n          var i = node.appendTo(this.node);\r\n          this.node = node;\r\n\r\n          //Advance path to the added node index\r\n          this.path.advance(i);\r\n        }\r\n\r\n        //Create setup container in this node\r\n        this.node.setup = [];\r\n      }\r\n\r\n      //Replace current position\r\n      replacePosition.call(this, tempPosition);\r\n\r\n      //Add setup instructions to node\r\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\r\n    };\r\n\r\n    /**\r\n     * Add markup\r\n     */\r\n    Game.prototype.addMarkup = function(x, y, markup) {\r\n\r\n      //No markup instructions container in this node?\r\n      if (typeof this.node.markup === 'undefined') {\r\n        this.node.markup = [];\r\n      }\r\n\r\n      //Add markup to game position\r\n      this.position.markup.set(x, y, markup);\r\n\r\n      //Add markup instructions to node\r\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\r\n    };\r\n\r\n    /**\r\n     * Remove a stone\r\n     */\r\n    Game.prototype.removeStone = function(x, y) {\r\n\r\n      //Check if the stone is found in setup instructions\r\n      var foundInSetup = false;\r\n\r\n      //Remove from node setup instruction\r\n      if (typeof this.node.setup !== 'undefined') {\r\n        for (var i = 0; i < this.node.setup.length; i++) {\r\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\r\n\r\n            //Remove from node and unset in position\r\n            this.node.setup.splice(i, 1);\r\n            this.position.stones.unset(x, y);\r\n\r\n            //Mark as found\r\n            foundInSetup = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Not found in setup? Add as no stone color\r\n      if (!foundInSetup) {\r\n        this.addStone(x, y, StoneColor.EMPTY);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove markup\r\n     */\r\n    Game.prototype.removeMarkup = function(x, y) {\r\n\r\n      //Remove from node\r\n      if (typeof this.node.markup !== 'undefined') {\r\n        for (var i = 0; i < this.node.markup.length; i++) {\r\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\r\n            this.node.markup.splice(i, 1);\r\n            this.position.markup.unset(x, y);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if there is a stone at the given coordinates for the current position\r\n     */\r\n    Game.prototype.hasStone = function(x, y, color) {\r\n      if (typeof color !== 'undefined') {\r\n        return this.position.stones.is(x, y, color);\r\n      }\r\n      return this.position.stones.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Check if there is markup at the given coordinate for the current position\r\n     */\r\n    Game.prototype.hasMarkup = function(x, y, type) {\r\n      if (typeof type !== 'undefined') {\r\n        return this.position.markup.is(x, y, type);\r\n      }\r\n      return this.position.markup.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get stone on coordinates\r\n     */\r\n    Game.prototype.getStone = function(x, y) {\r\n      return this.position.stones.get(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get markup on coordinates\r\n     */\r\n    Game.prototype.getMarkup = function(x, y) {\r\n      return this.position.markup.get(x, y);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Move handling\r\n     ***/\r\n\r\n    /**\r\n     * Play move\r\n     */\r\n    Game.prototype.play = function(x, y, color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Validate move and get new position\r\n      var newPosition = this.validateMove(x, y, color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          x: x,\r\n          y: y,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n\r\n      //Valid move\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Play pass\r\n     */\r\n    Game.prototype.pass = function(color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Initialize new position and switch the turn\r\n      var newPosition = this.position.clone();\r\n      newPosition.setTurn(-color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          pass: true,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game tree navigation\r\n     ***/\r\n\r\n    /**\r\n     * Go to the next position\r\n     */\r\n    Game.prototype.next = function(i) {\r\n\r\n      //Object (node) given as parameter? Find index\r\n      if (typeof i === 'object') {\r\n        i = this.node.children.indexOf(i);\r\n      }\r\n\r\n      //Go to the next node\r\n      if (nextNode.call(this, i)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n          return true;\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      //Didn't go to next position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the previous position\r\n     */\r\n    Game.prototype.previous = function() {\r\n\r\n      //Go to the previous node\r\n      if (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        return true;\r\n      }\r\n\r\n      //Didn't go to previous position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the last position\r\n     */\r\n    Game.prototype.last = function() {\r\n\r\n      //Keep going to the next node until we reach the end\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the first position\r\n     */\r\n    Game.prototype.first = function() {\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      executeNode.call(this);\r\n    };\r\n\r\n    /**\r\n     * Go to position specified by a path object, a numeric move numer, or a node name string\r\n     */\r\n    Game.prototype.goto = function(target) {\r\n\r\n      //Must have a tree\r\n      if (this.root === null) {\r\n        return;\r\n      }\r\n\r\n      //Nothing given?\r\n      if (typeof target === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      //Function given? Call now\r\n      if (typeof target === 'function') {\r\n        target = target.call(this);\r\n      }\r\n\r\n      //Initialize path\r\n      var path;\r\n\r\n      //Simple move number? Convert to path object\r\n      if (typeof target === 'number') {\r\n        path = this.path.clone();\r\n        path.setMove(target);\r\n      }\r\n\r\n      //String? Named node\r\n      else if (typeof target === 'string') {\r\n\r\n        //Already here?\r\n        if (this.node.name === target) {\r\n          return;\r\n        }\r\n\r\n        //Find path to node\r\n        path = this.getPathToNode(target);\r\n        if (path === null) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Otherwise assume path object\r\n      else {\r\n        path = target;\r\n      }\r\n\r\n      //Already here?\r\n      if (this.path.compare(path)) {\r\n        return;\r\n      }\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      pushPosition.call(this);\r\n      executeNode.call(this);\r\n\r\n      //Loop path\r\n      var n = path.getMove();\r\n      for (var i = 0; i < n; i++) {\r\n\r\n        //Try going to the next node\r\n        if (!nextNode.call(this, path.nodeAt(i))) {\r\n          break;\r\n        }\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next fork\r\n     */\r\n    Game.prototype.nextFork = function() {\r\n\r\n      //Keep going to the next node until we reach one with multiple children\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Have multiple children?\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous fork\r\n     */\r\n    Game.prototype.previousFork = function() {\r\n\r\n      //Loop until we find a node with more than one child\r\n      while (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next move with comments\r\n     */\r\n    Game.prototype.nextComment = function() {\r\n\r\n      //Keep going to the next node until we find one with comments\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous move with comments\r\n     */\r\n    Game.prototype.previousComment = function() {\r\n\r\n      //Go back until we find a node with comments\r\n      while (previousNode.call(this)) {\r\n\r\n        //Pop the position\r\n        popPosition.call(this);\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state\r\n     */\r\n    Game.prototype.getState = function() {\r\n\r\n      //Can only create when we have a JGF and path\r\n      if (!this.jgf || !this.path) {\r\n        return null;\r\n      }\r\n\r\n      //Create state\r\n      var state = {\r\n        jgf: this.jgf,\r\n        path: this.path.clone()\r\n      };\r\n\r\n      //Return\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the game state\r\n     */\r\n    Game.prototype.restoreState = function(state) {\r\n\r\n      //Must have jgf and path\r\n      if (!state || !state.jgf || !state.path) {\r\n        return;\r\n      }\r\n\r\n      //Restore state\r\n      this.load(state.jgf);\r\n      this.goto(state.path);\r\n    };\r\n\r\n    //Return object\r\n    return Game;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameNode :: This class represents a single node in the game moves tree. It contains\r\n * properties like the x and y grid coordinates, the move played, board setup instructions,\r\n * markup, player turn and comments. The moves tree in the game record is represented by a\r\n * string of GameNodes, each with pointers to their parent and children. Each node can have\r\n * multiple children (move variations), but only one parent.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Node.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameNode', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /**\r\n   * Helper to construct a coordinates base object\r\n   */\r\n  function coordinatesObject(coords, baseObject) {\r\n    baseObject = baseObject || {};\r\n    if (coords === '' || coords === 'pass') {\r\n      baseObject.pass = true;\r\n    }\r\n    else {\r\n\r\n      //Backwards compatibility with SGF string coordinates in JGF\r\n      if (typeof coords === 'string') {\r\n        coords = convertCoordinates(coords);\r\n      }\r\n\r\n      //Append coordinates\r\n      baseObject.x = coords[0] * 1;\r\n      baseObject.y = coords[1] * 1;\r\n    }\r\n    return baseObject;\r\n  }\r\n\r\n  /**\r\n   * Convert a numeric color value (color constant) to a string\r\n   */\r\n  function toStringColor(color) {\r\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\r\n  }\r\n\r\n  /**\r\n   * Convert a string color value to a numeric color constant\r\n   */\r\n  function toColorConstant(color) {\r\n    if (color === 'B') {\r\n      return StoneColor.B;\r\n    }\r\n    else if (color === 'W') {\r\n      return StoneColor.W;\r\n    }\r\n    return StoneColor.E;\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Helpers for conversion between JGF / KIFU format\r\n   ***/\r\n\r\n  /**\r\n   * Convert move object to JGF format\r\n   */\r\n  function convertMoveToJgf(move) {\r\n\r\n    //Initialize JGF move object and determine color\r\n    var jgfMove = angular.copy(move);\r\n    var color = toStringColor(move.color);\r\n\r\n    //No color?\r\n    if (color === '') {\r\n      return null;\r\n    }\r\n\r\n    //Pass move?\r\n    if (move.pass === true) {\r\n      jgfMove[color] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      jgfMove[color] = [move.x, move.y];\r\n    }\r\n\r\n    //Delete coordinates and color\r\n    delete jgfMove.x;\r\n    delete jgfMove.y;\r\n    delete jgfMove.color;\r\n\r\n    //Return move\r\n    return jgfMove;\r\n  }\r\n\r\n  /**\r\n   * Convert move from JGF format\r\n   */\r\n  function convertMoveFromJgf(move) {\r\n\r\n    //Prepare color, coordinates\r\n    var color, coords;\r\n\r\n    //Check whose move it was\r\n    if (move.W) {\r\n      color = 'W';\r\n      coords = move.W;\r\n    }\r\n    else if (move.B) {\r\n      color = 'B';\r\n      coords = move.B;\r\n    }\r\n\r\n    //No coordinates?\r\n    if (!coords) {\r\n      return null;\r\n    }\r\n\r\n    //Return coordinates object\r\n    return coordinatesObject(coords, {\r\n      color: toColorConstant(color)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert setup object to JGF format\r\n   */\r\n  function convertSetupToJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var i, color;\r\n    var jgfSetup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in setup) {\r\n      if (setup.hasOwnProperty(i)) {\r\n\r\n        //Get color\r\n        color = toStringColor(setup[i].color) || 'E';\r\n\r\n        //Initialize array\r\n        if (typeof jgfSetup[color] === 'undefined') {\r\n          jgfSetup[color] = [];\r\n        }\r\n\r\n        //Add coordinates\r\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert setup from JGF format\r\n   */\r\n  function convertSetupFromJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var c, key, color;\r\n    var gameSetup = [];\r\n\r\n    //Loop setup\r\n    for (key in setup) {\r\n      if (setup.hasOwnProperty(key)) {\r\n\r\n        //Get color constant\r\n        color = toColorConstant(key);\r\n\r\n        //Loop coordinates\r\n        for (c in setup[key]) {\r\n          if (setup[key].hasOwnProperty(c)) {\r\n            gameSetup.push(coordinatesObject(setup[key][c], {\r\n              color: color\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup object to JGF format\r\n   */\r\n  function convertMarkupToJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var i, type;\r\n    var jgfMarkup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in markup) {\r\n      if (markup.hasOwnProperty(i)) {\r\n\r\n        //Get type\r\n        type = markup[i].type;\r\n\r\n        //Initialize array\r\n        if (typeof jgfMarkup[type] === 'undefined') {\r\n          jgfMarkup[type] = [];\r\n        }\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\r\n        }\r\n        else {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup from JGF format\r\n   */\r\n  function convertMarkupFromJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var l, type;\r\n    var gameMarkup = [];\r\n\r\n    //Loop markup types\r\n    for (type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          for (l = 0; l < markup[type].length; l++) {\r\n\r\n            //Validate\r\n            if (!angular.isArray(markup[type][l])) {\r\n              continue;\r\n            }\r\n\r\n            //SGF type coordinates?\r\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\r\n              var text = markup[type][l][1];\r\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\r\n              markup[type][l].push(text);\r\n            }\r\n\r\n            //Validate length\r\n            if (markup[type][l].length < 3) {\r\n              continue;\r\n            }\r\n\r\n            //Add to stack\r\n            gameMarkup.push(coordinatesObject(markup[type][l], {\r\n              type: type,\r\n              text: markup[type][l][2]\r\n            }));\r\n          }\r\n        }\r\n        else {\r\n\r\n          //Loop coordinates\r\n          for (l in markup[type]) {\r\n            if (markup[type].hasOwnProperty(l)) {\r\n              gameMarkup.push(coordinatesObject(markup[type][l], {\r\n                type: type\r\n              }));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert turn object to JGF format\r\n   */\r\n  function convertTurnToJgf(turn) {\r\n    switch (turn) {\r\n      case StoneColor.W:\r\n        return 'W';\r\n      case StoneColor.B:\r\n        return 'B';\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert turn from JGF format\r\n   */\r\n  function convertTurnFromJgf(turn) {\r\n    switch (turn) {\r\n      case 'W':\r\n        return StoneColor.W;\r\n      case 'B':\r\n        return StoneColor.B;\r\n      default:\r\n        return StoneColor.EMPTY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Conversions map\r\n   */\r\n  var conversionMap = {\r\n    toJgf: {\r\n      move: convertMoveToJgf,\r\n      setup: convertSetupToJgf,\r\n      markup: convertMarkupToJgf,\r\n      turn: convertTurnToJgf\r\n    },\r\n    fromJgf: {\r\n      move: convertMoveFromJgf,\r\n      setup: convertSetupFromJgf,\r\n      markup: convertMarkupFromJgf,\r\n      turn: convertTurnFromJgf\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameNode(properties, parent) {\r\n\r\n    //Set parent and children\r\n    this.parent = parent || null;\r\n    this.children = [];\r\n\r\n    //Save properties\r\n    if (properties) {\r\n      for (var key in properties) {\r\n        if (properties.hasOwnProperty(key)) {\r\n          this[key] = properties[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get node's child specified by index or null if doesn't exist\r\n   */\r\n  GameNode.prototype.getChild = function(i) {\r\n    i = i || 0;\r\n    if (this.children[i]) {\r\n      return this.children[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Get all the children\r\n   */\r\n  GameNode.prototype.getChildren = function() {\r\n    return this.children;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has any chilren\r\n   */\r\n  GameNode.prototype.hasChildren = function() {\r\n    return (this.children.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Get parent node\r\n   */\r\n  GameNode.prototype.getParent = function() {\r\n    return this.parent;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has more than one move variation\r\n   */\r\n  GameNode.prototype.hasMoveVariations = function() {\r\n\r\n    //Less than two child nodes?\r\n    if (this.children.length <= 1) {\r\n      return false;\r\n    }\r\n\r\n    //Loop children\r\n    var moveVariations = 0;\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations++;\r\n      }\r\n\r\n      //More than one move node present?\r\n      if (moveVariations > 1) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //No move variations\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Get all the move variation nodes\r\n   */\r\n  GameNode.prototype.getMoveVariations = function() {\r\n\r\n    //No child nodes?\r\n    if (this.children.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize\r\n    var moveVariations = [];\r\n\r\n    //Loop child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations.push(this.children[i]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return moveVariations;\r\n  };\r\n\r\n  /**\r\n   * Get the move variation for given coordinates\r\n   */\r\n  GameNode.prototype.getMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return -1;\r\n  };\r\n\r\n  /**\r\n   * Check if given coordinates are one of the next child node coordinates\r\n   */\r\n  GameNode.prototype.isMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if we have comments\r\n   */\r\n  GameNode.prototype.hasComments = function() {\r\n    return (this.comments && this.comments.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Check if this is a move node\r\n   */\r\n  GameNode.prototype.isMove = function() {\r\n    return !!this.move;\r\n  };\r\n\r\n  /**\r\n   * Get move number\r\n   */\r\n  GameNode.prototype.getMoveNumber = function() {\r\n\r\n    //Move node?\r\n    if (this.isMove()) {\r\n      if (this.parent) {\r\n        return this.parent.getMoveNumber() + 1;\r\n      }\r\n      return 1;\r\n    }\r\n\r\n    //Use parent move number if we have one\r\n    if (this.parent) {\r\n      return this.parent.getMoveNumber();\r\n    }\r\n\r\n    //No parent\r\n    return 0;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Node manipulation\r\n   ***/\r\n\r\n  /**\r\n   * Remove this node from its parent\r\n   */\r\n  GameNode.prototype.remove = function() {\r\n\r\n    //Can't remove if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found remove it\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1) {\r\n      this.parent.children.splice(i, 1);\r\n    }\r\n\r\n    //Clear parent reference\r\n    this.parent = null;\r\n  };\r\n\r\n  /**\r\n   * Move the node up in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveUp = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i > 0) {\r\n      var temp = this.parent.children[i - 1];\r\n      this.parent.children[i - 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Move the node down in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveDown = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\r\n      var temp = this.parent.children[i + 1];\r\n      this.parent.children[i + 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Append this node to another node\r\n   */\r\n  GameNode.prototype.appendTo = function(node) {\r\n\r\n    //Remove from existing parent\r\n    this.remove();\r\n\r\n    //Set new parent\r\n    this.parent = node;\r\n    node.children.push(this);\r\n    return node.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Append child node to this node.\r\n   */\r\n  GameNode.prototype.appendChild = function(node) {\r\n    node.parent = this;\r\n    this.children.push(node);\r\n    return this.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Insert another node after this one\r\n   */\r\n  GameNode.prototype.insertNode = function(node) {\r\n\r\n    //Loop our children and change parent node\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      this.children[i].parent = node;\r\n    }\r\n\r\n    //Merge children, set this node as the parent of given node\r\n    node.children = node.children.concat(this.children);\r\n    node.parent = this;\r\n\r\n    //Set given node as the child of this node\r\n    this.children = [node];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * JGF conversion\r\n   ***/\r\n\r\n  /**\r\n   * Build a Game Node from a given JGF tree\r\n   */\r\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\r\n\r\n    //Root JGF file given?\r\n    if (typeof jgf.tree !== 'undefined') {\r\n      return GameNode.fromJgf(jgf.tree, gameNode);\r\n    }\r\n\r\n    //Initialize helper vars\r\n    var variationNode, nextNode, i, j;\r\n\r\n    //Node to work with given? Otherwise, work with ourselves\r\n    gameNode = gameNode || this;\r\n\r\n    //Loop moves in the JGF tree\r\n    for (i = 0; i < jgf.length; i++) {\r\n\r\n      //Array? That means a variation branch\r\n      if (angular.isArray(jgf[i])) {\r\n\r\n        //Loop variation stacks\r\n        for (j = 0; j < jgf[i].length; j++) {\r\n\r\n          //Build the variation node\r\n          variationNode = new GameNode();\r\n          variationNode.fromJgf(jgf[i][j]);\r\n\r\n          //Append to working node\r\n          gameNode.appendChild(variationNode);\r\n        }\r\n      }\r\n\r\n      //Regular node\r\n      else {\r\n\r\n        //Get properties to copy\r\n        var properties = Object.getOwnPropertyNames(jgf[i]);\r\n\r\n        //Copy node properties\r\n        for (var key in properties) {\r\n          if (properties.hasOwnProperty(key)) {\r\n            var prop = properties[key];\r\n\r\n            //Conversion function present?\r\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\r\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\r\n            }\r\n            else if (typeof jgf[i][prop] === 'object') {\r\n              gameNode[prop] = angular.copy(jgf[i][prop]);\r\n            }\r\n            else {\r\n              gameNode[prop] = jgf[i][prop];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Next element is a regular node? Prepare new working node\r\n      //Otherwise, if there are no more nodes or if the next element is\r\n      //an array (e.g. variations), we keep our working node as the current one\r\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\r\n        nextNode = new GameNode();\r\n        gameNode.appendChild(nextNode);\r\n        gameNode = nextNode;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Convert this node to a JGF node container\r\n   */\r\n  GameNode.prototype.toJgf = function(container) {\r\n\r\n    //Initialize container to add nodes to\r\n    container = container || [];\r\n\r\n    //Initialize node and get properties\r\n    var node = {};\r\n    var properties = Object.getOwnPropertyNames(this);\r\n\r\n    //Copy node properties\r\n    for (var key in properties) {\r\n      if (properties.hasOwnProperty(key)) {\r\n        var prop = properties[key];\r\n\r\n        //Skip some properties\r\n        if (prop === 'parent' || prop === 'children') {\r\n          continue;\r\n        }\r\n\r\n        //Conversion function present?\r\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\r\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\r\n        }\r\n        else if (typeof this[prop] === 'object') {\r\n          node[prop] = angular.copy(this[prop]);\r\n        }\r\n        else {\r\n          node[prop] = this[prop];\r\n        }\r\n      }\r\n    }\r\n\r\n    //Add node to container\r\n    container.push(node);\r\n\r\n    //Variations present?\r\n    if (this.children.length > 1) {\r\n\r\n      //Create variations container\r\n      var variationsContainer = [];\r\n      container.push(variationsContainer);\r\n\r\n      //Loop child (variation) nodes\r\n      for (var i = 0; i < this.children.length; i++) {\r\n\r\n        //Create container for this variation\r\n        var variationContainer = [];\r\n        variationsContainer.push(variationContainer);\r\n\r\n        //Call child node converter\r\n        this.children[i].toJgf(variationContainer);\r\n      }\r\n    }\r\n\r\n    //Just one child?\r\n    else if (this.children.length === 1) {\r\n      this.children[0].toJgf(container);\r\n    }\r\n\r\n    //Return container\r\n    return container;\r\n  };\r\n\r\n  //Return object\r\n  return GameNode;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePath :: A simple class that keeps track of a path taken in a game.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Path.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePath', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePath() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Reset\r\n   */\r\n  GamePath.prototype.reset = function() {\r\n    this.move = 0;\r\n    this.path = {};\r\n    this.branches = 0;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Advance a move\r\n   */\r\n  GamePath.prototype.advance = function(i) {\r\n\r\n    //Different child variation chosen? Remember\r\n    if (i > 0) {\r\n      this.branches++;\r\n    }\r\n    this.path[this.move] = i;\r\n\r\n    //Increment move\r\n    this.move++;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Retreat a move\r\n   */\r\n  GamePath.prototype.retreat = function() {\r\n\r\n    //At start?\r\n    if (this.move === 0) {\r\n      return;\r\n    }\r\n\r\n    //Decrement move\r\n    this.move--;\r\n\r\n    //Delete path choice\r\n    if (this.path[this.move]) {\r\n      delete this.path[this.move];\r\n      this.branches--;\r\n    }\r\n\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Go to a specific move number\r\n   */\r\n  GamePath.prototype.setMove = function(no) {\r\n\r\n    //Less than our current move? We need to erase any paths above the move number\r\n    if (no < this.move) {\r\n      for (var i in this.path) {\r\n        if (i > no) {\r\n          delete this.path[i];\r\n          this.branches--;\r\n        }\r\n      }\r\n    }\r\n\r\n    //Set move number\r\n    this.move = no;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the move number\r\n   */\r\n  GamePath.prototype.getMove = function() {\r\n    return this.move;\r\n  };\r\n\r\n  /**\r\n   * Get the node choice at a specific move number\r\n   */\r\n  GamePath.prototype.nodeAt = function(no) {\r\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\r\n  };\r\n\r\n  /**\r\n   * Compare to another path\r\n   */\r\n  GamePath.prototype.compare = function(otherPath) {\r\n\r\n    //Invalid object?\r\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    //Different move number or path length?\r\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\r\n      return false;\r\n    }\r\n\r\n    //Check path\r\n    for (var i in this.path) {\r\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    //Same path!\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clone\r\n   */\r\n  GamePath.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newPath = new GamePath();\r\n\r\n    //Set vars\r\n    newPath.move = this.move;\r\n    newPath.branches = this.branches;\r\n    newPath.path = angular.copy(this.path);\r\n\r\n    //Return\r\n    return newPath;\r\n  };\r\n\r\n  /**\r\n   * Helper to find node name recursively\r\n   */\r\n  function findNodeName(node, nodeName, path) {\r\n\r\n    //Found in this node?\r\n    if (node.name && node.name === nodeName) {\r\n      return true;\r\n    }\r\n\r\n    //Loop children\r\n    for (var i = 0; i < node.children.length; i++) {\r\n\r\n      //Advance path\r\n      path.advance(i);\r\n\r\n      //Found in child node?\r\n      if (findNodeName(node.children[i], nodeName, path)) {\r\n        return true;\r\n      }\r\n\r\n      //Not found in this child node, retreat path\r\n      path.retreat();\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Static helper to create a path object to reach a certain node\r\n   */\r\n  GamePath.findNode = function(nodeName, rootNode) {\r\n\r\n    //Create new instance\r\n    var path = new GamePath();\r\n\r\n    //Find the node name\r\n    if (findNodeName(rootNode, nodeName, path)) {\r\n      return path;\r\n    }\r\n\r\n    //Not found\r\n    return null;\r\n  };\r\n\r\n  //Return\r\n  return GamePath;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\r\n * markup on the board in this position, as well as any captures that were made and which player's\r\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\r\n * compare changes to other positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Position.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePosition(width, height) {\r\n\r\n    //Initialize\r\n    this.error = 0;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.stones = new BoardGrid();\r\n    this.markup = new BoardGrid();\r\n    this.turn = StoneColor.B;\r\n\r\n    //Initialize captures\r\n    this.captures = {};\r\n    this.captures[StoneColor.B] = [];\r\n    this.captures[StoneColor.W] = [];\r\n\r\n    //Set empty value for stones grid\r\n    this.stones.whenEmpty(StoneColor.EMPTY);\r\n\r\n    //Set size\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  GamePosition.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Set in grids\r\n    this.stones.setSize(width, height);\r\n    this.markup.setSize(width, height);\r\n\r\n    //Empty the position\r\n    this.empty();\r\n  };\r\n\r\n  /**\r\n   * Clear the whole position\r\n   */\r\n  GamePosition.prototype.empty = function() {\r\n    this.stones.empty();\r\n    this.markup.empty();\r\n  };\r\n\r\n  /**\r\n   * Sets stone color at given coordinates.\r\n   */\r\n  GamePosition.prototype.setStone = function(x, y, color) {\r\n    this.stones.set(x, y, color);\r\n  };\r\n\r\n  /**\r\n   * Sets markup type at given coordinates.\r\n   */\r\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\r\n    this.markup.set(x, y, markup);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Liberties and capturing\r\n   ***/\r\n\r\n  /**\r\n   * Check if a group of given color has liberties, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\r\n\r\n    //Out of bounds? No liberties outside of the board\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize tested grid if needed\r\n    tested = tested || new BoardGrid(this.width, this.height);\r\n\r\n    //See what color is present on the coordinates\r\n    var color = this.stones.get(x, y);\r\n\r\n    //If no group color was given, use what's on the position\r\n    groupColor = groupColor || color;\r\n\r\n    //Already tested, or enemy stone? Not giving any liberties\r\n    if (tested.get(x, y) === true || color === -groupColor) {\r\n      return false;\r\n    }\r\n\r\n    //Empty? That's a liberty\r\n    if (color === StoneColor.EMPTY) {\r\n      return true;\r\n    }\r\n\r\n    //Mark this position as tested now\r\n    tested.set(x, y, true);\r\n\r\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\r\n    //If we get at least one true, we have a liberty\r\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\r\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\r\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\r\n        this.hasLiberties(x + 1, y, groupColor, tested);\r\n  };\r\n\r\n  /**\r\n   * Helper to capture adjacent groups\r\n   */\r\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    friendlyColor = friendlyColor || this.stones.get(x, y);\r\n\r\n    //Can't capture empty spots\r\n    if (friendlyColor === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Flag to see if we captured stuff\r\n    var captured = false;\r\n\r\n    //Check adjacent positions now, capturing stones in the process if possible\r\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n\r\n    //Return\r\n    return captured;\r\n  };\r\n\r\n  /**\r\n   * Helper if we can capture a certain group\r\n   */\r\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\r\n\r\n    //Out of bounds? Nothing to capture\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Empty spot? Can't capture\r\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //We need to have a stone of matching group color in order to be able to capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //There is a capturable stone, let's see if it has any liberties left\r\n    if (this.hasLiberties(x, y, enemyColor)) {\r\n      return false;\r\n    }\r\n\r\n    //No liberties left, the group is capturable. Capture if we want to\r\n    if (doCapture) {\r\n      this.captureGroup(x, y, enemyColor);\r\n    }\r\n\r\n    //Capturable\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a group of certain color, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //If no group color was given, use what's on the position\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //Stone at position does not match the given group color? Can't capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //Capture the stone\r\n    this.captureStone(x, y);\r\n\r\n    //Capture the rest of the group\r\n    this.captureGroup(x, y - 1, enemyColor);\r\n    this.captureGroup(x, y + 1, enemyColor);\r\n    this.captureGroup(x - 1, y, enemyColor);\r\n    this.captureGroup(x + 1, y, enemyColor);\r\n\r\n    //At least one stone was captured\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a stone at given coordinates\r\n   */\r\n  GamePosition.prototype.captureStone = function(x, y) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get color\r\n    var color = this.stones.get(x, y);\r\n\r\n    //Empty?\r\n    if (color === StoneColor.EMPTY) {\r\n      return;\r\n    }\r\n\r\n    //Ok, stone present, capture it\r\n    this.stones.set(x, y, StoneColor.EMPTY);\r\n    this.captures[color].push({x: x, y: y});\r\n  };\r\n\r\n  /**\r\n   * Set captures for a color (expects array with capture object coordinates)\r\n   */\r\n  GamePosition.prototype.setCaptures = function(color, captures) {\r\n    this.captures[color] = captures;\r\n  };\r\n\r\n  /**\r\n   * Get captures for a color\r\n   */\r\n  GamePosition.prototype.getCaptures = function(color) {\r\n    return this.captures[color] || [];\r\n  };\r\n\r\n  /**\r\n   * Get the capture count for a color (= the number of captures of the opposing color)\r\n   */\r\n  GamePosition.prototype.getCaptureCount = function(color) {\r\n    return this.captures[-color].length;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Turn control\r\n   ***/\r\n\r\n  /**\r\n   * Set color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.setTurn = function(color) {\r\n    this.turn = color;\r\n  };\r\n\r\n  /**\r\n   * Get color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.getTurn = function() {\r\n    return this.turn;\r\n  };\r\n\r\n  /**\r\n   * Switch the player turn on this position\r\n   */\r\n  GamePosition.prototype.switchTurn = function() {\r\n    this.turn = -this.turn;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Cloning and comparison\r\n   ***/\r\n\r\n  /**\r\n   * Clones the whole position except turn and captures\r\n   */\r\n  GamePosition.prototype.clone = function() {\r\n\r\n    //Create a new position\r\n    var newPosition = new GamePosition();\r\n\r\n    //Set vars manually for maximum efficiency\r\n    newPosition.turn = this.turn;\r\n    newPosition.width = this.width;\r\n    newPosition.height = this.height;\r\n    newPosition.stones = this.stones.clone();\r\n    newPosition.markup = new BoardGrid(this.width, this.height);\r\n\r\n    //Return\r\n    return newPosition;\r\n  };\r\n\r\n  /**\r\n   * Checks if a given position is the same as the current position\r\n   */\r\n  GamePosition.prototype.isSameAs = function(newPosition) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\r\n      return false;\r\n    }\r\n\r\n    //Compare the grids\r\n    return this.stones.isSameAs(newPosition.stones);\r\n  };\r\n\r\n  //Return\r\n  return GamePosition;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScore :: A simple class that contains a game score\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Score.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScore', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Helper to calculate the total points\r\n   */\r\n  function calcTotal() {\r\n    return parseInt(this.stones) + parseInt(this.territory) +\r\n      parseInt(this.captures) + parseInt(this.komi);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameScore() {\r\n\r\n    //Get self\r\n    var self = this;\r\n\r\n    //Setup score containers\r\n    this.black = {};\r\n    this.white = {};\r\n\r\n    //Initialize\r\n    this.reset();\r\n\r\n    //Add total handlers\r\n    this.black.total = function() {\r\n      return calcTotal.call(self.black);\r\n    };\r\n    this.white.total = function() {\r\n      return calcTotal.call(self.white);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the game score\r\n   */\r\n  GameScore.prototype.reset = function() {\r\n\r\n    //Get properties to loop\r\n    var props = ['stones', 'territory', 'captures', 'komi'];\r\n\r\n    //Score for black player\r\n    for (var i = 0; i < props.length; i++) {\r\n      this.black[props[i]] = 0;\r\n      this.white[props[i]] = 0;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the winner\r\n   */\r\n  GameScore.prototype.winner = function() {\r\n\r\n    //Get totals\r\n    var b = this.black.total();\r\n    var w = this.white.total();\r\n\r\n    //Determine winner\r\n    if (w > b) {\r\n      return StoneColor.W;\r\n    }\r\n    else if (b > w) {\r\n      return StoneColor.B;\r\n    }\r\n    return StoneColor.E;\r\n  };\r\n\r\n  //Return\r\n  return GameScore;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScorer :: This class is used to determine the score of a certain game position. It also\r\n * provides handling of manual adjustment of dead / living groups.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Scorer.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Score.Service',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Possible score states\r\n   */\r\n  var scoreState = {\r\n    UNKNOWN: StoneColor.EMPTY,\r\n    BLACK_STONE: StoneColor.B,\r\n    WHITE_STONE: StoneColor.W,\r\n    BLACK_CANDIDATE: StoneColor.B * 2,\r\n    WHITE_CANDIDATE: StoneColor.W * 2,\r\n    NEUTRAL: StoneColor.B * 3\r\n  };\r\n\r\n  /**\r\n   * Helper to set territory\r\n   */\r\n  function territorySet(x, y, candidateColor, boundaryColor) {\r\n\r\n    //Get color at given position\r\n    var posColor = this.stones.get(x, y);\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //If border reached, or a position which is already this color, or boundary color, can't set\r\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\r\n      return;\r\n    }\r\n\r\n    //Don't turn stones which are already this color into candidates, instead\r\n    //reset their color to what they were\r\n    if (origColor * 2 === candidateColor) {\r\n      this.stones.set(x, y, origColor);\r\n    }\r\n\r\n    //Otherwise, mark as candidate\r\n    else {\r\n      this.stones.set(x, y, candidateColor);\r\n    }\r\n\r\n    //Set adjacent squares\r\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\r\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\r\n  }\r\n\r\n  /**\r\n   * Helper to reset territory\r\n   */\r\n  function territoryReset(x, y) {\r\n\r\n    //Get original color from this position\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //Not on grid, or already this color?\r\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\r\n      return;\r\n    }\r\n\r\n    //Reset the color\r\n    this.stones.set(x, y, origColor);\r\n\r\n    //Set adjacent squares\r\n    territoryReset.call(this, x - 1, y);\r\n    territoryReset.call(this, x, y - 1);\r\n    territoryReset.call(this, x + 1, y);\r\n    territoryReset.call(this, x, y + 1);\r\n  }\r\n\r\n  /**\r\n   * Helper to determine score state\r\n   */\r\n  function determineScoreState() {\r\n\r\n    //Initialize vars\r\n    var change = true;\r\n    var curState, newState, adjacent, b, w, a, x, y;\r\n\r\n    //Loop while there is change\r\n    while (change) {\r\n\r\n      //Set to false\r\n      change = false;\r\n\r\n      //Go through the whole position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get current state at position\r\n          curState = this.stones.get(x, y);\r\n\r\n          //Unknown or candiates?\r\n          if (\r\n            curState === scoreState.UNKNOWN ||\r\n            curState === scoreState.BLACK_CANDIDATE ||\r\n            curState === scoreState.WHITE_CANDIDATE\r\n          ) {\r\n\r\n            //Get state in adjacent positions\r\n            adjacent = [\r\n              this.stones.get(x - 1, y),\r\n              this.stones.get(x, y - 1),\r\n              this.stones.get(x + 1, y),\r\n              this.stones.get(x, y + 1)\r\n            ];\r\n\r\n            //Reset\r\n            b = w = false;\r\n\r\n            //Loop adjacent squares\r\n            for (a = 0; a < 4; a++) {\r\n              if (\r\n                adjacent[a] === scoreState.BLACK_STONE ||\r\n                adjacent[a] === scoreState.BLACK_CANDIDATE\r\n              ) {\r\n                b = true;\r\n              }\r\n              else if (\r\n                adjacent[a] === scoreState.WHITE_STONE ||\r\n                adjacent[a] === scoreState.WHITE_CANDIDATE\r\n              ) {\r\n                w = true;\r\n              }\r\n              else if (adjacent[a] === scoreState.NEUTRAL) {\r\n                b = w = true;\r\n              }\r\n            }\r\n\r\n            //Determine new state\r\n            if (b && w) {\r\n              newState = scoreState.NEUTRAL;\r\n            }\r\n            else if (b) {\r\n              newState = scoreState.BLACK_CANDIDATE;\r\n            }\r\n            else if (w) {\r\n              newState = scoreState.WHITE_CANDIDATE;\r\n            }\r\n            else {\r\n              newState = false;\r\n            }\r\n\r\n            //Change?\r\n            if (newState !== false && newState !== curState) {\r\n              change = true;\r\n              this.stones.set(x, y, newState);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * this.game scorer class\r\n   */\r\n  var GameScorer = {\r\n\r\n    //Game to score\r\n    game: null,\r\n\r\n    //Score\r\n    score: null,\r\n\r\n    //Stones, captures and points grids\r\n    stones: null,\r\n    captures: null,\r\n    points: null,\r\n\r\n    /**\r\n     * Load a game to score\r\n     */\r\n    load: function(game) {\r\n\r\n      //Reset score\r\n      this.score = new GameScore();\r\n\r\n      //Remember\r\n      this.game = game;\r\n\r\n      //Clone position to work with\r\n      this.stones = this.game.position.stones.clone();\r\n\r\n      //Create grids\r\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n    },\r\n\r\n    /**\r\n     * Get the calculated score\r\n     */\r\n    getScore: function() {\r\n      return this.score;\r\n    },\r\n\r\n    /**\r\n     * Get the points grid\r\n     */\r\n    getPoints: function() {\r\n      return this.points;\r\n    },\r\n\r\n    /**\r\n     * Get the captures grid\r\n     */\r\n    getCaptures: function() {\r\n      return this.captures;\r\n    },\r\n\r\n    /**\r\n     * Run score calculation routine\r\n     */\r\n    calculate: function() {\r\n\r\n      //No game?\r\n      if (!this.game) {\r\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\r\n        return;\r\n      }\r\n\r\n      //Empty grids\r\n      this.points.empty();\r\n      this.captures.empty();\r\n\r\n      //Determine score state\r\n      determineScoreState.call(this);\r\n\r\n      //Get komi and captures\r\n      var komi = this.game.get('game.komi');\r\n      var captures = this.game.getCaptureCount();\r\n\r\n      //Reset score\r\n      this.score.reset();\r\n\r\n      //Set captures and komi\r\n      this.score.black.captures = captures[StoneColor.B];\r\n      this.score.white.captures = captures[StoneColor.W];\r\n      this.score.black.komi = komi < 0 ? komi : 0;\r\n      this.score.white.komi = komi > 0 ? komi : 0;\r\n\r\n      //Init helper vars\r\n      var x, y, state, color;\r\n\r\n      //Loop position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get state and color on original position\r\n          state = this.stones.get(x, y);\r\n          color = this.game.position.stones.get(x, y);\r\n\r\n          //Black stone\r\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\r\n            this.score.black.stones++;\r\n            continue;\r\n          }\r\n\r\n          //White stone\r\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\r\n            this.score.white.stones++;\r\n            continue;\r\n          }\r\n\r\n          //Black candidate\r\n          if (state === scoreState.BLACK_CANDIDATE) {\r\n            this.score.black.territory++;\r\n            this.points.set(x, y, StoneColor.B);\r\n\r\n            //White stone underneath?\r\n            if (color === StoneColor.W) {\r\n              this.score.black.captures++;\r\n              this.captures.set(x, y, StoneColor.W);\r\n            }\r\n            continue;\r\n          }\r\n\r\n          //White candidate\r\n          if (state === scoreState.WHITE_CANDIDATE) {\r\n            this.score.white.territory++;\r\n            this.points.set(x, y, StoneColor.W);\r\n\r\n            //Black stone underneath?\r\n            if (color === StoneColor.B) {\r\n              this.score.white.captures++;\r\n              this.captures.set(x, y, StoneColor.B);\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mark stones dead or alive\r\n     */\r\n    mark: function(x, y) {\r\n\r\n      //Get color of original position and state of the count position\r\n      var color = this.game.position.stones.get(x, y);\r\n      var state = this.stones.get(x, y);\r\n\r\n      //White stone\r\n      if (color === StoneColor.W) {\r\n\r\n        //Was white, mark it and any territory it's in as black's\r\n        if (state === scoreState.WHITE_STONE) {\r\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\r\n        }\r\n\r\n        //Was marked as not white, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n\r\n      //Black stone\r\n      else if (color === StoneColor.B) {\r\n\r\n        //Was black, mark it and any territory it's in as white's\r\n        if (state === scoreState.BLACK_STONE) {\r\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\r\n        }\r\n\r\n        //Was marked as not black, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return GameScorer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Blank.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuBlank', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Blank JGF\r\n   */\r\n  var blankJgf = {\r\n    record: {\r\n      application: ngGo.name + ' v' + ngGo.version,\r\n      version: 1,\r\n      charset: 'UTF-8'\r\n    },\r\n    game: {\r\n      type: 'go',\r\n      players: [\r\n        {\r\n          color: 'black',\r\n          name: 'Black'\r\n        },\r\n        {\r\n          color: 'white',\r\n          name: 'White'\r\n        }\r\n      ]\r\n    },\r\n    board: {\r\n      width: 19,\r\n      height: 19\r\n    },\r\n    tree: []\r\n  };\r\n\r\n  /**\r\n   * Blank SGF\r\n   */\r\n  var blankSgf = {\r\n    AP: ngGo.name + ':' + ngGo.version,\r\n    CA: 'UTF-8',\r\n    FF: '4',\r\n    GM: '1',\r\n    SZ: '19',\r\n    PB: 'Black',\r\n    PW: 'White'\r\n  };\r\n\r\n  /**\r\n   * Blank JGF/SGF container\r\n   */\r\n  var KifuBlank = {\r\n\r\n    /**\r\n     * Get blank JGF\r\n     */\r\n    jgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankJgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    },\r\n\r\n    /**\r\n     * Get blank SGF\r\n     */\r\n    sgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankSgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = base[p];\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuBlank;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\r\n * constants used by the parsers to aid conversion.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parser.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\r\n])\r\n\r\n/**\r\n * SGF/JGF aliases constant for conversion between the two formats\r\n * Note: not all properties can be translated directly, so some are\r\n * not present here in this constant\r\n */\r\n.constant('sgfAliases', {\r\n\r\n  //Record properties\r\n  'AP': 'record.application',\r\n  'CA': 'record.charset',\r\n  'CP': 'record.copyright',\r\n  'SO': 'record.source',\r\n  'US': 'record.transcriber',\r\n  'AN': 'record.annotator',\r\n\r\n  //Game properties\r\n  'GM': 'game.type',\r\n  'GN': 'game.name',\r\n  'KM': 'game.komi',\r\n  'HA': 'game.handicap',\r\n  'RE': 'game.result',\r\n  'RU': 'game.rules',\r\n  'TM': 'game.time.main',\r\n  'OT': 'game.time.overtime',\r\n  'DT': 'game.dates',\r\n  'PC': 'game.location',\r\n  'EV': 'game.event',\r\n  'RO': 'game.round',\r\n  'ON': 'game.opening',\r\n  'GC': 'game.comment',\r\n\r\n  //Player info properties\r\n  'PB': 'name',\r\n  'PW': 'name',\r\n  'BT': 'team',\r\n  'WT': 'team',\r\n  'BR': 'rank',\r\n  'WR': 'rank',\r\n\r\n  //Node annotation\r\n  'N': 'name',\r\n  'C': 'comments',\r\n  'CR': 'circle',\r\n  'TR': 'triangle',\r\n  'SQ': 'square',\r\n  'MA': 'mark',\r\n  'SL': 'select',\r\n  'LB': 'label'\r\n})\r\n\r\n/**\r\n * SGF game definitions\r\n */\r\n.constant('sgfGames', {\r\n  1: 'go',\r\n  2: 'othello',\r\n  3: 'chess',\r\n  4: 'renju',\r\n  6: 'backgammon',\r\n  7: 'chinese chess',\r\n  8: 'shogi'\r\n})\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\r\n\r\n  /**\r\n   * Parser wrapper class\r\n   */\r\n  var KifuParser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    gib2jgf: function(gib, stringified) {\r\n      return Gib2Jgf.parse(gib, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    sgf2jgf: function(sgf, stringified) {\r\n      return Sgf2Jgf.parse(sgf, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    jgf2sgf: function(jgf) {\r\n      return Jgf2Sgf.parse(jgf);\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuParser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Directive', [\r\n  'ngGo.Board.Directive'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('player', ['Player', function(Player) {\r\n  return {\r\n    restrict: 'E',\r\n\r\n    /**\r\n     * Controller\r\n     */\r\n    controller: ['$scope', function($scope) {\r\n\r\n      //Set player in scope\r\n      if (!$scope.Player) {\r\n        $scope.Player = Player;\r\n      }\r\n    }],\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Link the element\r\n      Player.linkElement(element);\r\n\r\n      //Observe mode and tool attributes\r\n      attrs.$observe('mode', function(mode) {\r\n        Player.switchMode(mode);\r\n      });\r\n      attrs.$observe('tool', function(tool) {\r\n        Player.switchTool(tool);\r\n      });\r\n\r\n      //Observe other settings attributes\r\n      attrs.$observe('variationMarkup', function(attr) {\r\n        Player.setVariationMarkup(attr === 'true');\r\n      });\r\n      attrs.$observe('solutionPaths', function(attr) {\r\n        Player.toggleSolutionPaths(attr === 'true');\r\n      });\r\n      attrs.$observe('lastMoveMarker', function(attr) {\r\n        Player.setLastMoveMarker(attr);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Player :: This class brings the board to life and allows a user to interact with it. It\r\n * handles user input, controls objects going to the board, can load game records, and allows the\r\n * user to manipulate the board according to the current player mode.\r\n * Unless you want to display static positions, this is the class you'd use by default.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Service', [\r\n  'ngGo',\r\n  'ngGo.Player.Directive',\r\n  'ngGo.Player.Mode.Common.Service',\r\n  'ngGo.Board.Service',\r\n  'ngGo.Game.Service',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default mode/tool\r\n    mode: PlayerModes.REPLAY,\r\n    tool: PlayerTools.MOVE,\r\n\r\n    //Keys/scrollwheel navigation\r\n    arrowKeysNavigation: true,\r\n    scrollWheelNavigation: true,\r\n\r\n    //Last move marker, leave empty for none\r\n    lastMoveMarker: MarkupTypes.LAST,\r\n\r\n    //Indicate variations with markup on the board, and show\r\n    //successor node variations or current node variations\r\n    variationMarkup: true,\r\n    variationChildren: true,\r\n    variationSiblings: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\r\n\r\n    /**\r\n     * Helper to append board grid coordinatess to the broadcast event object\r\n     */\r\n    function processMouseEvent(broadcastEvent, mouseEvent) {\r\n\r\n      //Can only do this with a board and mouse event\r\n      if (!this.board || !mouseEvent) {\r\n        broadcastEvent.x = -1;\r\n        broadcastEvent.y = -1;\r\n        return;\r\n      }\r\n\r\n      //Init\r\n      var x = 0;\r\n      var y = 0;\r\n\r\n      //Set x\r\n      if (typeof mouseEvent.offsetX !== 'undefined') {\r\n        x = mouseEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.layerX;\r\n      }\r\n\r\n      //Set y\r\n      if (typeof mouseEvent.offsetY !== 'undefined') {\r\n        y = mouseEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.layerY;\r\n      }\r\n\r\n      //Apply pixel ratio factor\r\n      x *= (window.devicePixelRatio || 1);\r\n      y *= (window.devicePixelRatio || 1);\r\n\r\n      //Append coords\r\n      broadcastEvent.x = this.board.getGridX(x);\r\n      broadcastEvent.y = this.board.getGridY(y);\r\n\r\n      //Did we drag?\r\n      if (mouseEvent.drag) {\r\n        broadcastEvent.drag = mouseEvent.drag;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player class\r\n     */\r\n    var Player = {\r\n\r\n      //Player configuration\r\n      config: {},\r\n\r\n      //Board and game instances\r\n      board: null,\r\n      game: null,\r\n\r\n      //Available modes and tools\r\n      modes: {},\r\n      tools: [],\r\n\r\n      //Player mode and active tool\r\n      mode: '',\r\n      tool: '',\r\n\r\n      //Current path\r\n      path: null,\r\n\r\n      /**\r\n       * Initialization\r\n       */\r\n      init: function() {\r\n\r\n        //Unlink board instance, create new game\r\n        this.board = null;\r\n        this.game = new Game();\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Player mode and active tool\r\n        this.mode = '';\r\n        this.tool = '';\r\n\r\n        //Arrow keys / scroll wheel navigation\r\n        this.arrowKeysNavigation = false;\r\n        this.scrollWheelNavigation = false;\r\n\r\n        //Last move marker\r\n        this.lastMoveMarker = '';\r\n\r\n        //Variation markup\r\n        this.variationMarkup = false;\r\n        this.variationChildren = false;\r\n        this.variationSiblings = false;\r\n\r\n        //Restricted nodes\r\n        this.restrictNodeStart = null;\r\n        this.restrictNodeEnd = null;\r\n\r\n        //Parse config\r\n        this.parseConfig();\r\n      },\r\n\r\n      /**\r\n       * Link the player to a HTML element\r\n       */\r\n      linkElement: function(element) {\r\n\r\n        //Set element\r\n        this.element = element;\r\n\r\n        //Register document event\r\n        this.registerElementEvent('keydown', $document);\r\n\r\n        //Register element events\r\n        this.registerElementEvent('click');\r\n        this.registerElementEvent('mousedown');\r\n        this.registerElementEvent('mouseup');\r\n        this.registerElementEvent('mousemove');\r\n        this.registerElementEvent('mouseout');\r\n        this.registerElementEvent('mousewheel');\r\n        this.registerElementEvent('wheel');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Configuration\r\n       ***/\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.switchMode(this.config.mode);\r\n        this.switchTool(this.config.tool);\r\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\r\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\r\n        this.setLastMoveMarker(this.config.lastMoveMarker);\r\n        this.setVariationMarkup(\r\n          this.config.variationMarkup,\r\n          this.config.variationChildren,\r\n          this.config.variationSiblings\r\n        );\r\n\r\n        //Let the modes parse their config\r\n        for (var mode in this.modes) {\r\n          if (this.modes[mode].parseConfig) {\r\n            this.modes[mode].parseConfig.call(this, this.config);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set arrow keys navigation\r\n       */\r\n      setArrowKeysNavigation: function(arrowKeys) {\r\n        if (arrowKeys !== this.arrowKeysNavigation) {\r\n          this.arrowKeysNavigation = arrowKeys;\r\n          this.broadcast('settingChange', 'arrowKeysNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set scroll wheel navigation\r\n       */\r\n      setScrollWheelNavigation: function(scrollWheel) {\r\n        if (scrollWheel !== this.scrollWheelNavigation) {\r\n          this.scrollWheelNavigation = scrollWheel;\r\n          this.broadcast('settingChange', 'scrollWheelNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the last move marker\r\n       */\r\n      setLastMoveMarker: function(lastMoveMarker) {\r\n        if (lastMoveMarker !== this.lastMoveMarker) {\r\n          this.lastMoveMarker = lastMoveMarker;\r\n          this.broadcast('settingChange', 'lastMoveMarker');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set variation markup on the board\r\n       */\r\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\r\n\r\n        //One change event for these three settings\r\n        var change = false;\r\n\r\n        //Markup setting change?\r\n        if (variationMarkup !== this.variationMarkup) {\r\n          this.variationMarkup = variationMarkup;\r\n          change = true;\r\n        }\r\n\r\n        //Children setting change?\r\n        if (\r\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\r\n        ) {\r\n          this.variationChildren = variationChildren;\r\n          change = true;\r\n        }\r\n\r\n        //Siblings setting change?\r\n        if (\r\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\r\n        ) {\r\n          this.variationSiblings = variationSiblings;\r\n          change = true;\r\n        }\r\n\r\n        //Did anything change?\r\n        if (change) {\r\n          this.broadcast('settingChange', 'variationMarkup');\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Mode and tool handling\r\n       ***/\r\n\r\n      /**\r\n       * Register a player mode\r\n       */\r\n      registerMode: function(mode, PlayerMode) {\r\n\r\n        //Register the mode and let it parse the configuration\r\n        this.modes[mode] = PlayerMode;\r\n\r\n        //Parse config if we have a handler\r\n        if (this.modes[mode].parseConfig) {\r\n          this.modes[mode].parseConfig.call(this, this.config);\r\n        }\r\n\r\n        //Force switch the mode now, if it matches the initial mode\r\n        if (this.mode === mode) {\r\n          this.switchMode(this.mode, true);\r\n          this.switchTool(this.tool, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set available tools\r\n       */\r\n      setTools: function(tools) {\r\n        this.tools = tools || [PlayerTools.NONE];\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player mode\r\n       */\r\n      hasMode: function(mode) {\r\n        return this.modes[mode] ? true : false;\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player tool\r\n       */\r\n      hasTool: function(tool) {\r\n        return (this.tools.indexOf(tool) !== -1);\r\n      },\r\n\r\n      /**\r\n       * Switch player mode\r\n       */\r\n      switchMode: function(mode, force) {\r\n\r\n        //No change?\r\n        if (!force && (!mode || this.mode === mode)) {\r\n          return false;\r\n        }\r\n\r\n        //Broadcast mode exit\r\n        if (this.mode) {\r\n          this.broadcast('modeExit', this.mode);\r\n        }\r\n\r\n        //Set mode, reset tools and active tool\r\n        this.mode = mode;\r\n        this.tools = [];\r\n        this.tool = PlayerTools.NONE;\r\n\r\n        //Broadcast mode entry\r\n        this.broadcast('modeEnter', this.mode);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Switch player tool\r\n       */\r\n      switchTool: function(tool, force) {\r\n\r\n        //No change?\r\n        if (!force && (!tool || this.tool === tool)) {\r\n          return false;\r\n        }\r\n\r\n        //Validate tool switch (only when there is a mode)\r\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\r\n          return false;\r\n        }\r\n\r\n        //Change tool\r\n        this.tool = tool;\r\n        this.broadcast('toolSwitch', this.tool);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Save the full player state\r\n       */\r\n      saveState: function() {\r\n\r\n        //Save player state\r\n        this.playerState = {\r\n          mode: this.mode,\r\n          tool: this.tool,\r\n          restrictNodeStart: this.restrictNodeStart,\r\n          restrictNodeEnd: this.restrictNodeEnd\r\n        };\r\n\r\n        //Save game state\r\n        this.saveGameState();\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved player state\r\n       */\r\n      restoreState: function() {\r\n\r\n        //Must have player state\r\n        if (!this.playerState) {\r\n          return;\r\n        }\r\n\r\n        //Restore\r\n        this.switchMode(this.playerState.mode);\r\n        this.switchTool(this.playerState.tool);\r\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\r\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\r\n\r\n        //Restore game state\r\n        this.restoreGameState();\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game record handling\r\n       ***/\r\n\r\n      /**\r\n       * Load game record\r\n       */\r\n      load: function(data, allowPlayerConfig) {\r\n\r\n        //Try to load the game record data\r\n        try {\r\n          this.game.load(data);\r\n        }\r\n        catch (error) {\r\n          throw error;\r\n        }\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Parse configuration from JGF if allowed\r\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\r\n          this.parseConfig(this.game.get('settings'));\r\n        }\r\n\r\n        //Dispatch game loaded event\r\n        this.broadcast('gameLoaded', this.game);\r\n\r\n        //Board present?\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n\r\n        //Loaded ok\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Reload the existing game record\r\n       */\r\n      reload: function() {\r\n\r\n        //Must have game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reload game\r\n        this.game.reload();\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Save the current state\r\n       */\r\n      saveGameState: function() {\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.gameState = this.game.getState();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved state\r\n       */\r\n      restoreGameState: function() {\r\n\r\n        //Must have game and saved state\r\n        if (!this.game || !this.gameState) {\r\n          return;\r\n        }\r\n\r\n        //Restore state\r\n        this.game.restoreState(this.gameState);\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Navigation\r\n       ***/\r\n\r\n      /**\r\n       * Go to the next position\r\n       */\r\n      next: function(i) {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.next(i);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position\r\n       */\r\n      previous: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previous();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the last position\r\n       */\r\n      last: function() {\r\n        if (this.game) {\r\n          this.game.last();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the first position\r\n       */\r\n      first: function() {\r\n        if (this.game) {\r\n          this.game.first();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to a specific move number, tree path or named node\r\n       */\r\n      goto: function(target) {\r\n        if (this.game && target) {\r\n          this.game.goto(target);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the previous fork\r\n       */\r\n      previousFork: function() {\r\n        if (this.game) {\r\n          this.game.previousFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next fork\r\n       */\r\n      nextFork: function() {\r\n        if (this.game) {\r\n          this.game.nextFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next position with a comment\r\n       */\r\n      nextComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.nextComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position with a comment\r\n       */\r\n      previousComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previousComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restrict navigation to the current node\r\n       */\r\n      restrictNode: function(end) {\r\n\r\n        //Must have game and node\r\n        if (!this.game || !this.game.node) {\r\n          return;\r\n        }\r\n\r\n        //Restrict to current node\r\n        if (end) {\r\n          this.restrictNodeEnd = this.game.node;\r\n        }\r\n        else {\r\n          this.restrictNodeStart = this.game.node;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Process a new game position\r\n       */\r\n      processPosition: function() {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Get current node and game position\r\n        var node = this.game.getNode();\r\n        var path = this.game.getPath();\r\n        var position = this.game.getPosition();\r\n        var pathChanged = !path.compare(this.path);\r\n\r\n        //Update board\r\n        this.updateBoard(node, position, pathChanged);\r\n\r\n        //Path change?\r\n        if (pathChanged) {\r\n\r\n          //Copy new path and broadcast path change\r\n          this.path = path.clone();\r\n          this.broadcast('pathChange', node);\r\n\r\n          //Named node reached? Broadcast event\r\n          if (node.name) {\r\n            this.broadcast('reachedNode.' + node.name, node);\r\n          }\r\n        }\r\n\r\n        //Passed?\r\n        if (node.move && node.move.pass) {\r\n          this.broadcast('movePassed', node);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Show move numbers\r\n       */\r\n      showMoveNumbers: function(fromMove, toMove) {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Use sensible defaults if no from/to moves given\r\n        fromMove = fromMove || 1;\r\n        toMove = toMove || this.game.getMove();\r\n\r\n        //Get nodes for these moves\r\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\r\n        var move = fromMove;\r\n\r\n        //Loop nodes\r\n        angular.forEach(nodes, function(node) {\r\n          this.board.add('markup', node.move.x, node.move.y, {\r\n            type: MarkupTypes.LABEL,\r\n            text: move++\r\n          });\r\n        }, this);\r\n\r\n        //Redraw board markup\r\n        this.board.redraw('markup');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game handling\r\n       ***/\r\n\r\n      /**\r\n       * Start a new game\r\n       */\r\n      newGame: function() {\r\n        this.game = new Game();\r\n        this.processPosition();\r\n      },\r\n\r\n      /**\r\n       * Score the current game position\r\n       */\r\n      scoreGame: function() {\r\n\r\n        //Calculate score\r\n        GameScorer.calculate();\r\n\r\n        //Get score, points and captures\r\n        var score = GameScorer.getScore();\r\n        var points = GameScorer.getPoints();\r\n        var captures = GameScorer.getCaptures();\r\n\r\n        //Remove all markup, and set captures and points\r\n        this.board.layers.markup.removeAll();\r\n        this.board.layers.score.setAll(points, captures);\r\n\r\n        //Broadcast score\r\n        this.broadcast('scoreCalculated', score);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Board handling\r\n       ***/\r\n\r\n      /**\r\n       * Get the board\r\n       */\r\n      getBoard: function() {\r\n        return this.board;\r\n      },\r\n\r\n      /**\r\n       * Set the board\r\n       */\r\n      setBoard: function(Board) {\r\n\r\n        //Set the board\r\n        this.board = Board;\r\n\r\n        //Board ready\r\n        if (this.board) {\r\n          this.broadcast('boardReady', this.board);\r\n        }\r\n\r\n        //If a game has been loaded already, parse config and update the board\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Update the board\r\n       */\r\n      updateBoard: function(node, position, pathChanged) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Update board with new position\r\n        this.board.updatePosition(position, pathChanged);\r\n\r\n        //Mark last move\r\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\r\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\r\n        }\r\n\r\n        //Broadcast board update event\r\n        this.broadcast('boardUpdate', node);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Event handling\r\n       ***/\r\n\r\n      /**\r\n       * Register an element event\r\n       */\r\n      registerElementEvent: function(event, element) {\r\n\r\n        //Which element to use\r\n        if (typeof element === 'undefined' || !element.on) {\r\n          element = this.element;\r\n        }\r\n\r\n        //Remove any existing event listener and apply new one\r\n        //TODO: Namespacing events doesn't work with Angular's jqLite\r\n        element.off(event/* + '.ngGo.player'*/);\r\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\r\n      },\r\n\r\n      /**\r\n       * Event listener\r\n       */\r\n      on: function(type, listener, mode, $scope) {\r\n\r\n        //Must have valid listener\r\n        if (typeof listener !== 'function') {\r\n          console.warn('Listener is not a function:', listener);\r\n          return;\r\n        }\r\n\r\n        //Scope given as 3rd parameter?\r\n        if (mode && mode.$parent) {\r\n          $scope = mode;\r\n          mode = '';\r\n        }\r\n\r\n        //Multiple events?\r\n        if (type.indexOf(' ') !== -1) {\r\n          var types = type.split(' ');\r\n          for (var t = 0; t < types.length; t++) {\r\n            this.on(types[t], listener, mode, $scope);\r\n          }\r\n          return;\r\n        }\r\n\r\n        //Get self and determine scope to use\r\n        var self = this;\r\n        var scope = $scope || $rootScope;\r\n\r\n        //Create listener and return de-registration function\r\n        return scope.$on('ngGo.player.' + type, function() {\r\n\r\n          //Filter on mode\r\n          if (mode) {\r\n            if (\r\n              (typeof mode === 'string' && mode !== self.mode) ||\r\n              mode.indexOf(self.mode) === -1\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          //Inside a text field?\r\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\r\n            return;\r\n          }\r\n\r\n          //Append grid coordinates for mouse events\r\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\r\n            processMouseEvent.call(self, arguments[0], arguments[1]);\r\n          }\r\n\r\n          //Dragging? Prevent click events from firing\r\n          if (self.preventClickEvent && type === 'click') {\r\n            delete self.preventClickEvent;\r\n            return;\r\n          }\r\n          else if (type === 'mousedrag') {\r\n            self.preventClickEvent = true;\r\n          }\r\n\r\n          //Call listener\r\n          listener.apply(self, arguments);\r\n        });\r\n      },\r\n\r\n      /**\r\n       * Event broadcaster\r\n       */\r\n      broadcast: function(type, args) {\r\n\r\n        //Must have type\r\n        if (!type) {\r\n          return;\r\n        }\r\n\r\n        //Make sure we are in a digest cycle\r\n        if (!$rootScope.$$phase) {\r\n          $rootScope.$apply(function() {\r\n            $rootScope.$broadcast('ngGo.player.' + type, args);\r\n          });\r\n        }\r\n        else {\r\n          $rootScope.$broadcast('ngGo.player.' + type, args);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Initialize\r\n    Player.init();\r\n\r\n    //Return object\r\n    return Player;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\r\n * gridlines, starpoints and coordinates via the Coordinates class.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Coordinates.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\r\n\r\n  /**\r\n   * Helper for drawing starpoints\r\n   */\r\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\r\n\r\n    //Don't draw if it falls outsize of the board grid\r\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\r\n      return;\r\n    }\r\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\r\n      return;\r\n    }\r\n\r\n    //Get absolute coordinates and star point radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n\r\n    //Draw star point\r\n    this.context.beginPath();\r\n    this.context.fillStyle = starColor;\r\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GridLayer(board, context) {\r\n\r\n    //Set coordinates setting\r\n    this.coordinates = false;\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Show or hide the coordinates.\r\n   */\r\n  GridLayer.prototype.setCoordinates = function(show) {\r\n    this.coordinates = show;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Get all has nothing to return\r\n   */\r\n  GridLayer.prototype.getAll = function() {\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Set all has nothing to set\r\n   */\r\n  GridLayer.prototype.setAll = function(/*grid*/) {\r\n    return;\r\n  };\r\n\r\n  /**\r\n   * Remove all has nothing to remove\r\n   */\r\n  GridLayer.prototype.removeAll = function() {\r\n    return;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw method\r\n   */\r\n  GridLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Determine top x and y margin\r\n    var tx = this.board.drawMarginHor;\r\n    var ty = this.board.drawMarginVer;\r\n\r\n    //Get theme properties\r\n    var cellSize = this.board.getCellSize();\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\r\n    var lineCap = this.board.theme.get('grid.lineCap');\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Helper vars\r\n    var i, x, y;\r\n\r\n    //Draw vertical lines\r\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\r\n      x = this.board.getAbsX(i);\r\n      this.context.moveTo(x, ty);\r\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\r\n    }\r\n\r\n    //Draw horizontal lines\r\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\r\n      y = this.board.getAbsY(i);\r\n      this.context.moveTo(tx, y);\r\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\r\n    }\r\n\r\n    //Draw grid lines\r\n    this.context.stroke();\r\n\r\n    //Star points defined?\r\n    for (i = 0; i < starPoints.length; i++) {\r\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n\r\n    //Draw coordinates\r\n    if (this.coordinates) {\r\n      Coordinates.draw.call(this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Clear rectangle\r\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  /**\r\n   * Redraw a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', s);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n\r\n    //Determine draw coordinates\r\n    var x1 = (gridX === 0) ? x : x - r;\r\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\r\n    var y1 = (gridY === 0) ? y : y - r;\r\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Patch up grid lines\r\n    this.context.moveTo(x1, y);\r\n    this.context.lineTo(x2, y);\r\n    this.context.moveTo(x, y1);\r\n    this.context.lineTo(x, y2);\r\n    this.context.stroke();\r\n\r\n    //Check if we need to draw a star point here\r\n    for (var i in starPoints) {\r\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\r\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\r\n      }\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  //Return\r\n  return GridLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function HoverLayer(board, context) {\r\n\r\n    //Container for items to restore\r\n    this.restore = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add hover item\r\n   */\r\n  HoverLayer.prototype.add = function(x, y, hover) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Remove any previous item at this position\r\n    this.remove(x, y);\r\n\r\n    //Create hover object\r\n    hover.object = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Stones\r\n    if (hover.type === 'stones') {\r\n      hover.objectClass = StoneFaded;\r\n      hover.object.color = hover.value;\r\n    }\r\n\r\n    //Markup\r\n    else if (hover.type === 'markup') {\r\n      hover.objectClass = Markup;\r\n      if (typeof hover.value === 'object') {\r\n        hover.object = angular.extend(hover.object, hover.value);\r\n      }\r\n      else {\r\n        hover.object.type = hover.value;\r\n      }\r\n    }\r\n\r\n    //Unknown\r\n    else {\r\n      console.warn('Unknown hover type', hover.type);\r\n      return;\r\n    }\r\n\r\n    //Check if we need to hide something on layers underneath\r\n    if (this.board.has(hover.type, x, y)) {\r\n      this.restore.push({\r\n        x: x,\r\n        y: y,\r\n        layer: hover.type,\r\n        value: this.board.get(hover.type, x, y)\r\n      });\r\n      this.board.remove(hover.type, x, y);\r\n    }\r\n\r\n    //Add to stack\r\n    this.grid.set(x, y, hover);\r\n\r\n    //Draw item\r\n    if (hover.objectClass && hover.objectClass.draw) {\r\n      hover.objectClass.draw.call(this, hover.object);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove the hover object\r\n   */\r\n  HoverLayer.prototype.remove = function(x, y) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.has(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get object and clear it\r\n    var hover = this.grid.get(x, y);\r\n    if (hover.objectClass && hover.objectClass.clear) {\r\n      hover.objectClass.clear.call(this, hover.object);\r\n    }\r\n\r\n    //Other objects to restore?\r\n    for (var i = 0; i < this.restore.length; i++) {\r\n      if (this.restore[i].x === x && this.restore[i].y === y) {\r\n        this.board.add(\r\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n        );\r\n        this.restore.splice(i, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove all hover objects\r\n   */\r\n  HoverLayer.prototype.removeAll = function() {\r\n\r\n    //Anything to do?\r\n    if (this.grid.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    //Get all item as objects\r\n    var i;\r\n    var hover = this.grid.all('layer');\r\n\r\n    //Clear them\r\n    for (i = 0; i < hover.length; i++) {\r\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\r\n        hover[i].objectClass.clear.call(this, hover[i].object);\r\n      }\r\n    }\r\n\r\n    //Clear layer and empty grid\r\n    this.clear();\r\n    this.grid.empty();\r\n\r\n    //Restore objects on other layers\r\n    for (i = 0; i < this.restore.length; i++) {\r\n      this.board.add(\r\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n      );\r\n    }\r\n\r\n    //Clear restore array\r\n    this.restore = [];\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  HoverLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Loop objects and clear them\r\n    var hover = this.grid.all('hover');\r\n    for (var i = 0; i < hover.length; i++) {\r\n      if (hover.objectClass && hover.objectClass.draw) {\r\n        hover.objectClass.draw.call(this, hover.object);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return HoverLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function MarkupLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all markup at once\r\n   */\r\n  MarkupLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'type');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Markup.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Markup.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  MarkupLayer.prototype.removeAll = function() {\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Clear them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.clear.call(this, markup[i]);\r\n    }\r\n\r\n    //Empty the grid now\r\n    this.grid.empty();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  MarkupLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.draw.call(this, markup[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  MarkupLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  MarkupLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return MarkupLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ScoreLayer(board, context) {\r\n\r\n    //Points and captures\r\n    this.points = [];\r\n    this.captures = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set points and captures\r\n   */\r\n  ScoreLayer.prototype.setAll = function(points, captures) {\r\n\r\n    //Remove all existing stuff first\r\n    this.removeAll();\r\n\r\n    //Set new stuff\r\n    this.points = points.all('color');\r\n    this.captures = captures.all('color');\r\n\r\n    //Draw\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Remove all scoring\r\n   */\r\n  ScoreLayer.prototype.removeAll = function() {\r\n\r\n    //If there are captures, draw them back onto the stones layer\r\n    for (var i = 0; i < this.captures.length; i++) {\r\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\r\n    }\r\n\r\n    //Clear the layer\r\n    this.clear();\r\n\r\n    //Remove all stuff\r\n    this.points = [];\r\n    this.captures = [];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ScoreLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Init\r\n    var i;\r\n\r\n    //Draw captures first (removing stones from the stones layer)\r\n    for (i = 0; i < this.captures.length; i++) {\r\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\r\n      StoneFaded.draw.call(this, this.captures[i]);\r\n    }\r\n\r\n    //Draw points on top of it\r\n    for (i = 0; i < this.points.length; i++) {\r\n      StoneMini.draw.call(this, this.points[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ScoreLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneShadow.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ShadowLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add a stone\r\n   */\r\n  ShadowLayer.prototype.add = function(stone) {\r\n\r\n    //Don't add if no shadow\r\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\r\n      return;\r\n    }\r\n\r\n    //Already have a stone here?\r\n    if (this.grid.has(stone.x, stone.y)) {\r\n      return;\r\n    }\r\n\r\n    //Add to grid\r\n    this.grid.set(stone.x, stone.y, stone.color);\r\n\r\n    //Draw it if there is a context\r\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\r\n      StoneShadow.draw.call(this, stone);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove a stone\r\n   */\r\n  ShadowLayer.prototype.remove = function(stone) {\r\n\r\n    //Remove from grid\r\n    this.grid.unset(stone.x, stone.y);\r\n\r\n    //Redraw whole layer\r\n    this.redraw();\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ShadowLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get shadowsize from theme\r\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\r\n\r\n    //Apply shadow transformation\r\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      StoneShadow.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ShadowLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function StonesLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n\r\n    //Set empty value for grid\r\n    this.grid.whenEmpty(StoneColor.EMPTY);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all stones at once\r\n   */\r\n  StonesLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'color');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Stone.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Stone.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  StonesLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      Stone.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  StonesLayer.prototype.redraw = function() {\r\n\r\n    //Clear shadows layer\r\n    this.board.removeAll('shadow');\r\n\r\n    //Redraw ourselves\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  StonesLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  StonesLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StonesLayer;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Coordinates :: This class is used for drawing board coordinates\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Coordinates.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Coordinates', function() {\r\n\r\n  //Kanji\r\n  var kanji = [\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', ''\r\n  ];\r\n\r\n  //Character codes\r\n  var aChar = 'A'.charCodeAt(0);\r\n  var aCharLc = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Coordinate generators\r\n   */\r\n  var coordinates = {\r\n\r\n    //Kanji coordinates\r\n    kanji: function(i) {\r\n      return kanji[i] || '';\r\n    },\r\n\r\n    //Numbers from 1\r\n    numbers: function(i) {\r\n      return i + 1;\r\n    },\r\n\r\n    //Capital letters from A\r\n    letters: function(i) {\r\n\r\n      //Initialize\r\n      var ch = '';\r\n\r\n      //Beyond Z? Prepend with A\r\n      if (i >= 25) {\r\n        ch = 'A';\r\n        i -= 25;\r\n      }\r\n\r\n      //The letter I is ommitted\r\n      if (i >= 8) {\r\n        i++;\r\n      }\r\n\r\n      //Return\r\n      return ch + String.fromCharCode(aChar + i);\r\n    },\r\n\r\n    //JGF coordinates (e.g. 0, 1, ...)\r\n    jgf: function(i) {\r\n      return i;\r\n    },\r\n\r\n    //SGF coordinates (e.g. a, b, ...)\r\n    sgf: function(i) {\r\n      var ch;\r\n      if (i < 26) {\r\n        ch = aCharLc + i;\r\n      }\r\n      else {\r\n        ch = aChar + i;\r\n      }\r\n      return String.fromCharCode(ch);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Coordinates object\r\n   */\r\n  var Coordinates = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function() {\r\n\r\n      //Can only draw when we have context and dimensions\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Get cell size\r\n      var cellSize = this.board.getCellSize();\r\n\r\n      //Get boundary coordinates\r\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\r\n      var xr = this.board.drawWidth - xl;\r\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\r\n      var yb = this.board.drawHeight - yt;\r\n\r\n      //Get theme properties\r\n      var fillStyle = this.board.theme.get('coordinates.color');\r\n      var vertical = {\r\n        font: this.board.theme.get('coordinates.vertical.font'),\r\n        size: this.board.theme.get('coordinates.vertical.size'),\r\n        style: this.board.theme.get('coordinates.vertical.style'),\r\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\r\n      };\r\n      var horizontal = {\r\n        font: this.board.theme.get('coordinates.horizontal.font'),\r\n        size: this.board.theme.get('coordinates.horizontal.size'),\r\n        style: this.board.theme.get('coordinates.horizontal.style'),\r\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\r\n      };\r\n\r\n      //Configure context\r\n      this.context.fillStyle = fillStyle;\r\n      this.context.textBaseline = 'middle';\r\n      this.context.textAlign = 'center';\r\n\r\n      //Helper vars\r\n      var i, j, x, y, ch;\r\n\r\n      //Draw vertical coordinates\r\n      for (i = 0; i < this.board.height; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (vertical.inverse) {\r\n          j = this.board.height - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof vertical.style === 'function') {\r\n          ch = vertical.style.call(this, j);\r\n        }\r\n        else if (coordinates[vertical.style]) {\r\n          ch = coordinates[vertical.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        y = this.board.getAbsY(i);\r\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\r\n        this.context.fillText(ch, xl, y);\r\n        this.context.fillText(ch, xr, y);\r\n      }\r\n\r\n      //Draw horizontal coordinates\r\n      for (i = 0; i < this.board.width; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (horizontal.inverse) {\r\n          j = this.board.width - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof horizontal.style === 'function') {\r\n          ch = horizontal.style.call(this, j);\r\n        }\r\n        else if (coordinates[horizontal.style]) {\r\n          ch = coordinates[horizontal.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        x = this.board.getAbsX(i);\r\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\r\n        this.context.fillText(ch, x, yt);\r\n        this.context.fillText(ch, x, yb);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Coordinates;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Markup :: This class is used for drawing markup\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Markup.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\r\n\r\n  /**\r\n   * Math constants\r\n   */\r\n  var cosPi4 = Math.cos(Math.PI / 4);\r\n  var cosPi6 = Math.cos(Math.PI / 6);\r\n\r\n  /**\r\n   * Triangle draw handler\r\n   */\r\n  function drawTriangle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y - r);\r\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.closePath();\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Square draw handler\r\n   */\r\n  function drawSquare(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw circle handler\r\n   */\r\n  function drawCircle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw mark handler\r\n   */\r\n  function drawMark(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - rcos, y - rcos);\r\n    this.context.lineTo(x + rcos, y + rcos);\r\n    this.context.moveTo(x + rcos, y - rcos);\r\n    this.context.lineTo(x - rcos, y + rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw select handler\r\n   */\r\n  function drawSelect(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Last move draw handler\r\n   */\r\n  function drawLast(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y);\r\n    this.context.lineTo(x + r, y);\r\n    this.context.lineTo(x, y + r);\r\n    this.context.closePath();\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw happy smiley handler\r\n   */\r\n  function drawHappySmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 8);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw sad smiley handler\r\n   */\r\n  function drawSadSmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw label\r\n   */\r\n  function drawLabel(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //First, clear grid square below for clarity\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.clearCell(markup.x, markup.y);\r\n    }\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.textBaseline = 'middle';\r\n    this.context.textAlign = 'center';\r\n\r\n    //Convert to text\r\n    if (typeof markup.text === 'number') {\r\n      markup.text = markup.text.toString();\r\n    }\r\n\r\n    //Determine font size\r\n    if (markup.text.length === 1) {\r\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\r\n    }\r\n    else if (markup.text.length === 2) {\r\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\r\n    }\r\n    else {\r\n      this.context.font = r + 'px ' + font;\r\n    }\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.fillText(markup.text, x, y, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Clear label\r\n   */\r\n  function clearLabel(markup) {\r\n\r\n    //No stone on location? Redraw the grid square, if we cleared it\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup class\r\n   */\r\n  var Markup = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Drawing depends on type\r\n      switch (markup.type) {\r\n\r\n        //Triangle\r\n        case MarkupTypes.TRIANGLE:\r\n          drawTriangle.call(this, markup);\r\n          break;\r\n\r\n        //Square\r\n        case MarkupTypes.SQUARE:\r\n          drawSquare.call(this, markup);\r\n          break;\r\n\r\n        //Circle\r\n        case MarkupTypes.CIRCLE:\r\n          drawCircle.call(this, markup);\r\n          break;\r\n\r\n        //Mark\r\n        case MarkupTypes.MARK:\r\n          drawMark.call(this, markup);\r\n          break;\r\n\r\n        //Select\r\n        case MarkupTypes.SELECT:\r\n          drawSelect.call(this, markup);\r\n          break;\r\n\r\n        //happy\r\n        case MarkupTypes.HAPPY:\r\n          drawHappySmiley.call(this, markup);\r\n          break;\r\n\r\n        //Sad\r\n        case MarkupTypes.SAD:\r\n          drawSadSmiley.call(this, markup);\r\n          break;\r\n\r\n        //Last move marker\r\n        case MarkupTypes.LAST:\r\n          drawLast.call(this, markup);\r\n          break;\r\n\r\n        //Label\r\n        case MarkupTypes.LABEL:\r\n          markup.text = markup.text || '';\r\n          drawLabel.call(this, markup);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear\r\n     */\r\n    clear: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, markup);\r\n\r\n      //Special handling for label\r\n      if (markup.type === MarkupTypes.LABEL) {\r\n        clearLabel.call(this, markup);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Markup;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Stone :: This class is used for drawing stones on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Stone.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service',\r\n  'ngGo.Board.ShellPattern.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\r\n\r\n  /**\r\n   * Shell random seed\r\n   */\r\n  var shellSeed;\r\n\r\n  /**\r\n   * Mono colored stones\r\n   */\r\n  function drawMono(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Don't draw shadow\r\n    stone.shadow = false;\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\r\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Configure context\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Draw outline\r\n    this.context.stroke();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Glass stones\r\n   */\r\n  function drawGlass(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Begin path\r\n    this.context.beginPath();\r\n\r\n    //Determine stone texture\r\n    if (color === StoneColor.W) {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#fff');\r\n      this.context.fillStyle.addColorStop(1, '#aaa');\r\n    }\r\n    else {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#666');\r\n      this.context.fillStyle.addColorStop(1, '#111');\r\n    }\r\n\r\n    //Complete drawing\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Slate and shell stones\r\n   */\r\n  function drawSlateShell(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Get random seed\r\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var shellTypes = this.board.theme.get('stone.shell.types');\r\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.fill();\r\n\r\n    //Shell stones\r\n    if (color === StoneColor.W) {\r\n\r\n      //Get random shell type\r\n      var type =\r\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\r\n\r\n      //Determine random angle\r\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\r\n      var angle = (2 / z) * (shellSeed % z);\r\n\r\n      //Draw shell pattern\r\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Slate stones\r\n    else {\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var Stone = {\r\n\r\n    /**\r\n     * Draw a stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Determine style of stone\r\n      var style = this.board.theme.get('stone.style');\r\n\r\n      //Draw using the appropriate handler\r\n      switch (style) {\r\n\r\n        //Slate and shell\r\n        case 'shell':\r\n          drawSlateShell.call(this, stone);\r\n          break;\r\n\r\n        //Glass stones\r\n        case 'glass':\r\n          drawGlass.call(this, stone);\r\n          break;\r\n\r\n        //Mono stones\r\n        case 'mono':\r\n          drawMono.call(this, stone);\r\n          break;\r\n\r\n        //Custom type\r\n        default:\r\n          var handler = $injector.get(style);\r\n          if (handler) {\r\n            handler.call(this, stone);\r\n          }\r\n      }\r\n\r\n      //Add shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.add(stone);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear a stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, stone);\r\n\r\n      //Remove shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.remove(stone);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Stone;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneFaded', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneFaded = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.faded.scale');\r\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneFaded;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\r\n * (for scoring).\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneMini.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneMini', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneMini = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.mini.scale');\r\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneMini;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneShadow :: This class is used for drawing stone shadows on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneShadow', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var StoneShadow = {\r\n\r\n    /**\r\n     * Draw a stone shadow\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\r\n\r\n      //Apply scaling factor?\r\n      if (stone.scale) {\r\n        r = Math.round(r * stone.scale);\r\n      }\r\n\r\n      //Get theme properties\r\n      var blur = this.board.theme.get('shadow.blur', s);\r\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\r\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\r\n      var shadowColor = this.board.theme.get('shadow.color');\r\n\r\n      //Configure context\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\r\n      );\r\n      this.context.fillStyle.addColorStop(0, shadowColor);\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n\r\n      //Draw shadow\r\n      this.context.beginPath();\r\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    },\r\n\r\n    /**\r\n     * Clear a stone shadow\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Note: this method is currently not in use due to the overlapping shadows\r\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\r\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\r\n      //appropriate either, so for now we will leave it at this.\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = this.board.theme.get('stone.radius', s);\r\n\r\n      //Clear a generous rectangle\r\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneShadow;\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\r\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions\r\n   */\r\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\r\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\r\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\r\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\r\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\r\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\r\n\r\n  /**\r\n   * Player parser function\r\n   */\r\n  function parsePlayer(jgf, match) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\r\n\r\n    //Create player object\r\n    var player = {\r\n      color: color,\r\n      name: match[2],\r\n      rank: match[3].toLowerCase()\r\n    };\r\n\r\n    //Check if player of this color already exists, if so, overwrite\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p] = player;\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, push\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, match) {\r\n    jgf.game.komi = parseFloat(match[1] / 10);\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, match) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Push date\r\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\r\n  }\r\n\r\n  /**\r\n   * Result parser function\r\n   */\r\n  function parseResult(jgf, match) {\r\n\r\n    //Winner color\r\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\r\n    result += '+';\r\n\r\n    //Win condition\r\n    if (match[2].match(/res/i)) {\r\n      result += 'R';\r\n    }\r\n    else if (match[2].match(/time/i)) {\r\n      result += 'T';\r\n    }\r\n    else {\r\n      result += match[2];\r\n    }\r\n\r\n    //Set in JGF\r\n    jgf.game.result = result;\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, match) {\r\n\r\n    //Determine player color\r\n    var color = match[2];\r\n    if (color === 1) {\r\n      color = 'B';\r\n    }\r\n    else if (color === 2) {\r\n      color = 'W';\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (false) {\r\n\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[color] = [match[3] * 1, match[4] * 1];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    parse: function(gib, stringified) {\r\n\r\n      //Get new JGF object\r\n      var jgf = KifuBlank.jgf();\r\n\r\n      //Initialize\r\n      var match;\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find player information\r\n      while ((match = regPlayer.exec(gib))) {\r\n        parsePlayer(jgf, match);\r\n      }\r\n\r\n      //Find komi\r\n      if ((match = regKomi.exec(gib))) {\r\n        parseKomi(jgf, match);\r\n      }\r\n\r\n      //Find game date\r\n      if ((match = regDate.exec(gib))) {\r\n        parseDate(jgf, match);\r\n      }\r\n\r\n      //Find game result\r\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\r\n        parseResult(jgf, match);\r\n      }\r\n\r\n      //Find moves\r\n      while ((match = regMove.exec(gib))) {\r\n\r\n        //Create new node\r\n        node = {};\r\n\r\n        //Parse move\r\n        parseMove(jgf, node, match);\r\n\r\n        //Push node to container\r\n        container.push(node);\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Flip SGF alias map and create JGF alias map\r\n   */\r\n  var jgfAliases = {};\r\n  for (var sgfProp in sgfAliases) {\r\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\r\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert to SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to escape SGF info\r\n   */\r\n  function escapeSgf(text) {\r\n    if (typeof text === 'string') {\r\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\r\n    }\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Helper to write an SGF group\r\n   */\r\n  function writeGroup(prop, values, output, escape) {\r\n    if (values.length) {\r\n      output.sgf += prop;\r\n      for (var i = 0; i < values.length; i++) {\r\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser\r\n   */\r\n  function parseMove(move, output) {\r\n\r\n    //Determine and validate color\r\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\r\n    if (color === '') {\r\n      return;\r\n    }\r\n\r\n    //Determine move\r\n    var coords = (move[color] === 'pass') ? '' : move[color];\r\n\r\n    //Append to SGF\r\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\r\n  }\r\n\r\n  /**\r\n   * Setup parser\r\n   */\r\n  function parseSetup(setup, output) {\r\n\r\n    //Loop colors\r\n    for (var color in setup) {\r\n      if (setup.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < setup[color].length; i++) {\r\n          setup[color][i] = convertCoordinates(setup[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('A' + color, setup[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Score parser\r\n   */\r\n  function parseScore(score, output) {\r\n\r\n    //Loop colors\r\n    for (var color in score) {\r\n      if (score.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < score[color].length; i++) {\r\n          score[color][i] = convertCoordinates(score[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('T' + color, score[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser\r\n   */\r\n  function parseMarkup(markup, output) {\r\n\r\n    //Loop markup types\r\n    for (var type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n        var i;\r\n\r\n        //Label type has the label text appended to the coords\r\n        if (type === 'label') {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\r\n          }\r\n        }\r\n        else {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]);\r\n          }\r\n        }\r\n\r\n        //Convert type\r\n        if (typeof jgfAliases[type] !== 'undefined') {\r\n          type = jgfAliases[type];\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup(type, markup[type], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser\r\n   */\r\n  function parseTurn(turn, output) {\r\n    output.sgf += 'PL[' + turn + ']';\r\n  }\r\n\r\n  /**\r\n   * Comments parser\r\n   */\r\n  function parseComments(comments, output) {\r\n\r\n    //Determine key\r\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\r\n\r\n    //Flatten comment objects\r\n    var flatComments = [];\r\n    for (var c = 0; c < comments.length; c++) {\r\n      if (typeof comments[c] === 'string') {\r\n        flatComments.push(comments[c]);\r\n      }\r\n      else if (comments[c].comment) {\r\n        flatComments.push(comments[c].comment);\r\n      }\r\n    }\r\n\r\n    //Write as group\r\n    writeGroup(key, flatComments, output, true);\r\n  }\r\n\r\n  /**\r\n   * Node name parser\r\n   */\r\n  function parseNodeName(nodeName, output) {\r\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\r\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\r\n  }\r\n\r\n  /**\r\n   * Game parser\r\n   */\r\n  function parseGame(game) {\r\n\r\n    //Loop SGF game definitions\r\n    for (var i in sgfGames) {\r\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Application parser\r\n   */\r\n  function parseApplication(application) {\r\n    var parts = application.split(' v');\r\n    if (parts.length > 1) {\r\n      return parts[0] + ':' + parts[1];\r\n    }\r\n    return application;\r\n  }\r\n\r\n  /**\r\n   * Player instructions parser\r\n   */\r\n  function parsePlayer(player, rootProperties) {\r\n\r\n    //Variation handling\r\n    var st = 0;\r\n    if (!player.variationMarkup) {\r\n      st += 2;\r\n    }\r\n    if (player.variationSiblings) {\r\n      st += 1;\r\n    }\r\n\r\n    //Set in root properties\r\n    rootProperties.ST = st;\r\n  }\r\n\r\n  /**\r\n   * Board parser\r\n   */\r\n  function parseBoard(board, rootProperties) {\r\n\r\n    //Both width and height should be given\r\n    if (board.width && board.height) {\r\n\r\n      //Same dimensions?\r\n      if (board.width === board.height) {\r\n        rootProperties.SZ = board.width;\r\n      }\r\n\r\n      //Different dimensions are not supported by SGF, but OGS uses the\r\n      //format w:h, so we will stick with that for anyone who supports it.\r\n      else {\r\n        rootProperties.SZ = board.width + ':' + board.height;\r\n      }\r\n    }\r\n\r\n    //Otherwise, check if only width or height were given at least\r\n    else if (board.width) {\r\n      rootProperties.SZ = board.width;\r\n    }\r\n    else if (board.height) {\r\n      rootProperties.SZ = board.height;\r\n    }\r\n\r\n    //Can't determine size\r\n    else {\r\n      rootProperties.SZ = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Players parser\r\n   */\r\n  function parsePlayers(players, rootProperties) {\r\n\r\n    //Loop players\r\n    for (var p = 0; p < players.length; p++) {\r\n\r\n      //Validate color\r\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\r\n        continue;\r\n      }\r\n\r\n      //Get SGF color\r\n      var color = (players[p].color === 'black') ? 'B' : 'W';\r\n\r\n      //Name given?\r\n      if (players[p].name) {\r\n        rootProperties['P' + color] = players[p].name;\r\n      }\r\n\r\n      //Rank given?\r\n      if (players[p].rank) {\r\n        rootProperties[color + 'R'] = players[p].rank;\r\n      }\r\n\r\n      //Team given?\r\n      if (players[p].team) {\r\n        rootProperties[color + 'T'] = players[p].team;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Node properties\r\n    'move': parseMove,\r\n    'setup': parseSetup,\r\n    'score': parseScore,\r\n    'markup': parseMarkup,\r\n    'turn': parseTurn,\r\n    'comments': parseComments,\r\n    'name': parseNodeName,\r\n\r\n    //Info properties\r\n    'record.application': parseApplication,\r\n    'player': parsePlayer,\r\n    'board': parseBoard,\r\n    'game.type': parseGame,\r\n    'game.players': parsePlayers\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Parser functions\r\n   ***/\r\n\r\n  /**\r\n   * Helper to write a JGF tree to SGF\r\n   */\r\n  function writeTree(tree, output) {\r\n\r\n    //Loop nodes in the tree\r\n    for (var i = 0; i < tree.length; i++) {\r\n      var node = tree[i];\r\n\r\n      //Array? That means a variation\r\n      if (angular.isArray(node)) {\r\n        for (var j = 0; j < node.length; j++) {\r\n          output.sgf += '(\\n;';\r\n          writeTree(node[j], output);\r\n          output.sgf += '\\n)';\r\n        }\r\n\r\n        //Continue\r\n        continue;\r\n      }\r\n\r\n      //Loop node properties\r\n      for (var key in node) {\r\n        if (node.hasOwnProperty(key)) {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n            parsingMap[key](node[key], output);\r\n            continue;\r\n          }\r\n\r\n          //Other object, can't handle it\r\n          if (typeof node[key] === 'object') {\r\n            continue;\r\n          }\r\n\r\n          //Anything else, append it\r\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //More to come?\r\n      if ((i + 1) < tree.length) {\r\n        output.sgf += '\\n;';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to extract all SGF root properties from a JGF object\r\n   */\r\n  function extractRootProperties(jgf, rootProperties, key) {\r\n\r\n    //Initialize key\r\n    if (typeof key === 'undefined') {\r\n      key = '';\r\n    }\r\n\r\n    //Loop properties of jgf node\r\n    for (var subKey in jgf) {\r\n      if (jgf.hasOwnProperty(subKey)) {\r\n\r\n        //Skip SGF signature (as we keep our own)\r\n        if (subKey === 'sgf') {\r\n          continue;\r\n        }\r\n\r\n        //Build jgf key\r\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\r\n\r\n        //If the item is an object, handle separately\r\n        if (typeof jgf[subKey] === 'object') {\r\n\r\n          //Handler for this object present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\r\n          }\r\n\r\n          //Otherwise, just flatten and call this function recursively\r\n          else {\r\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Check if it's a known key, if so, append the value to the root\r\n        var value;\r\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            value = parsingMap[jgfKey](jgf[subKey]);\r\n          }\r\n          else {\r\n            value = escapeSgf(jgf[subKey]);\r\n          }\r\n\r\n          //Set in root properties\r\n          rootProperties[jgfAliases[jgfKey]] = value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    parse: function(jgf) {\r\n\r\n      //String given?\r\n      if (typeof jgf === 'string') {\r\n        jgf = angular.fromJson(jgf);\r\n      }\r\n\r\n      //Must have moves tree\r\n      if (!jgf.tree) {\r\n        console.error('No moves tree in JGF object');\r\n        return;\r\n      }\r\n\r\n      //Initialize output (as object, so it remains a reference) and root properties container\r\n      var output = {sgf: '(\\n;'};\r\n      var root = angular.copy(jgf);\r\n      var rootProperties = KifuBlank.sgf();\r\n\r\n      //The first node of the JGF tree is the root node, and it can contain comments,\r\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\r\n      //and attach it to the root\r\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\r\n        root = angular.extend(root, jgf.tree[0]);\r\n        delete root.root;\r\n        delete jgf.tree[0];\r\n      }\r\n\r\n      //Set root properties\r\n      delete root.tree;\r\n      extractRootProperties(root, rootProperties);\r\n\r\n      //Write root properties\r\n      for (var key in rootProperties) {\r\n        if (rootProperties[key]) {\r\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //Write game tree\r\n      writeTree(jgf.tree, output);\r\n\r\n      //Close SGF and return\r\n      output.sgf += ')';\r\n      return output.sgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions for SGF data\r\n   */\r\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\r\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\r\n  var regProperty = /[A-Z]+/;\r\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Application parser function (doesn't overwrite existing signature)\r\n   */\r\n  function parseApp(jgf, node, key, value) {\r\n    if (!jgf.record.application) {\r\n      var app = value[0].split(':');\r\n      if (app.length > 1) {\r\n        jgf.record.application = app[0] + ' v' + app[1];\r\n      }\r\n      else {\r\n        jgf.record.application = app[0];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SGF format parser\r\n   */\r\n  function parseSgfFormat() {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Game type parser function\r\n   */\r\n  function parseGame(jgf, node, key, value) {\r\n    var game = value[0];\r\n    if (typeof sgfGames[game] !== 'undefined') {\r\n      jgf.game.type = sgfGames[game];\r\n    }\r\n    else {\r\n      jgf.game.type = value[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, key, value) {\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\r\n      node.move[key] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[key] = convertCoordinates(value[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Comment parser function\r\n   */\r\n  function parseComment(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Node name parser function\r\n   */\r\n  function parseNodeName(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value[0];\r\n  }\r\n\r\n  /**\r\n   * Board setup parser function\r\n   */\r\n  function parseSetup(jgf, node, key, value) {\r\n\r\n    //Initialize setup container on node\r\n    if (typeof node.setup === 'undefined') {\r\n      node.setup = {};\r\n    }\r\n\r\n    //Remove \"A\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Initialize setup container of this type\r\n    if (typeof node.setup[key] === 'undefined') {\r\n      node.setup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.setup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scoring parser function\r\n   */\r\n  function parseScore(jgf, node, key, value) {\r\n\r\n    //Initialize score container on node\r\n    if (typeof node.score === 'undefined') {\r\n      node.score = {\r\n        B: [],\r\n        W: []\r\n      };\r\n    }\r\n\r\n    //Remove \"T\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.score[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser function\r\n   */\r\n  function parseTurn(jgf, node, key, value) {\r\n    node.turn = value[0];\r\n  }\r\n\r\n  /**\r\n   * Label parser function\r\n   */\r\n  function parseLabel(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n\r\n      //Split off coordinates and add label contents\r\n      var coords = convertCoordinates(value[i].substr(0, 2));\r\n      coords.push(value[i].substr(3));\r\n\r\n      //Add to node\r\n      node.markup[key].push(coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser function\r\n   */\r\n  function parseMarkup(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.markup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Size parser function\r\n   */\r\n  function parseSize(jgf, node, key, value) {\r\n\r\n    //Initialize board container\r\n    if (typeof jgf.board === 'undefined') {\r\n      jgf.board = {};\r\n    }\r\n\r\n    //Add size property (can be width:height or just a single size)\r\n    var size = value[0].split(':');\r\n    if (size.length > 1) {\r\n      jgf.board.width = parseInt(size[0]);\r\n      jgf.board.height = parseInt(size[1]);\r\n    }\r\n    else {\r\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, node, key, value) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Explode dates\r\n    var dates = value[0].split(',');\r\n    for (var d = 0; d < dates.length; d++) {\r\n      jgf.game.dates.push(dates[d]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, node, key, value) {\r\n    jgf.game.komi = parseFloat(value[0]);\r\n  }\r\n\r\n  /**\r\n   * Variations handling parser function\r\n   */\r\n  function parseVariations(jgf, node, key, value) {\r\n\r\n    //Initialize display property\r\n    if (typeof jgf.player === 'undefined') {\r\n      jgf.player = {};\r\n    }\r\n\r\n    //Initialize variation display settings\r\n    jgf.player.variationMarkup = false;\r\n    jgf.player.variationChildren = false;\r\n    jgf.player.variationSiblings = false;\r\n\r\n    //Parse as integer\r\n    var st = parseInt(value[0]);\r\n\r\n    //Determine what we want (see SGF specs for details)\r\n    switch (st) {\r\n      case 0:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 1:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n      case 2:\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 3:\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Player info parser function\r\n   */\r\n  function parsePlayer(jgf, node, key, value) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Check if player of this color already exists\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p][key] = value[0];\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, initialize\r\n    var player = {color: color};\r\n    player[key] = value[0];\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Parsing function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Application, game type, board size, komi, date\r\n    'AP': parseApp,\r\n    'FF': parseSgfFormat,\r\n    'GM': parseGame,\r\n    'SZ': parseSize,\r\n    'KM': parseKomi,\r\n    'DT': parseDate,\r\n\r\n    //Variations handling\r\n    'ST': parseVariations,\r\n\r\n    //Player info handling\r\n    'PB': parsePlayer,\r\n    'PW': parsePlayer,\r\n    'BT': parsePlayer,\r\n    'WT': parsePlayer,\r\n    'BR': parsePlayer,\r\n    'WR': parsePlayer,\r\n\r\n    //Moves\r\n    'B': parseMove,\r\n    'W': parseMove,\r\n\r\n    //Node annotation\r\n    'C': parseComment,\r\n    'N': parseNodeName,\r\n\r\n    //Board setup\r\n    'AB': parseSetup,\r\n    'AW': parseSetup,\r\n    'AE': parseSetup,\r\n    'PL': parseTurn,\r\n    'TW': parseScore,\r\n    'TB': parseScore,\r\n\r\n    //Markup\r\n    'CR': parseMarkup,\r\n    'SQ': parseMarkup,\r\n    'TR': parseMarkup,\r\n    'MA': parseMarkup,\r\n    'SL': parseMarkup,\r\n    'LB': parseLabel\r\n  };\r\n\r\n  /**\r\n   * These properties need a node object\r\n   */\r\n  var needsNode = [\r\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\r\n  ];\r\n\r\n  /*****************************************************************************\r\n   * Parser helpers\r\n   ***/\r\n\r\n  /**\r\n   * Set info in the JGF tree at a certain position\r\n   */\r\n  function setInfo(jgf, position, value) {\r\n\r\n    //Position given must be an array\r\n    if (typeof position !== 'object') {\r\n      return;\r\n    }\r\n\r\n    //Initialize node to attach value to\r\n    var node = jgf;\r\n    var key;\r\n\r\n    //Loop the position\r\n    for (var p = 0; p < position.length; p++) {\r\n\r\n      //Get key\r\n      key = position[p];\r\n\r\n      //Last key reached? Done\r\n      if ((p + 1) === position.length) {\r\n        break;\r\n      }\r\n\r\n      //Create container if not set\r\n      if (typeof node[key] !== 'object') {\r\n        node[key] = {};\r\n      }\r\n\r\n      //Move up in tree\r\n      node = node[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    parse: function(sgf, stringified) {\r\n\r\n      //Get new JGF object (with SGF node as a base)\r\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\r\n\r\n      //Initialize\r\n      var stack = [];\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find sequence of elements\r\n      var sequence = sgf.match(regSequence);\r\n\r\n      //Loop sequence items\r\n      for (var i = 0; i < sequence.length; i++) {\r\n\r\n        //Push stack if new variation found\r\n        if (sequence[i] === '(') {\r\n\r\n          //First encounter, this defines the main tree branch, so skip\r\n          if (i === 0 || i === '0') {\r\n            continue;\r\n          }\r\n\r\n          //Push the current container to the stack\r\n          stack.push(container);\r\n\r\n          //Create variation container if it doesn't exist yet\r\n          if (!angular.isArray(container[container.length - 1])) {\r\n            container.push([]);\r\n          }\r\n\r\n          //Use variation container\r\n          container = container[container.length - 1];\r\n\r\n          //Now create moves container\r\n          container.push([]);\r\n          container = container[container.length - 1];\r\n          continue;\r\n        }\r\n\r\n        //Grab last container from stack if end of variation reached\r\n        else if (sequence[i] === ')') {\r\n          if (stack.length) {\r\n            container = stack.pop();\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Make array of properties within this sequence\r\n        var properties = sequence[i].match(regNode) || [];\r\n\r\n        //Loop them\r\n        for (var j = 0; j < properties.length; j++) {\r\n\r\n          //Get property's key and separate values\r\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\r\n          var values = properties[j].match(regValues);\r\n\r\n          //Remove additional braces [ and ]\r\n          for (var k = 0; k < values.length; k++) {\r\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\r\n          }\r\n\r\n          //SGF parser present for this key? Call it, and we're done\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n\r\n            //Does this type of property need a node?\r\n            if (needsNode.indexOf(key) !== -1) {\r\n\r\n              //If no node object present, create a new node\r\n              //For moves, always a new node is created\r\n              if (!node || key === 'B' || key === 'W') {\r\n                node = {};\r\n                container.push(node);\r\n              }\r\n            }\r\n\r\n            //Apply parsing function on node\r\n            parsingMap[key](jgf, node, key, values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF parser present, we continue with regular property handling\r\n\r\n          //If there is only one value, simplify array\r\n          if (values.length === 1) {\r\n            values = values[0];\r\n          }\r\n\r\n          //SGF alias known? Then this is an info element and we handle it accordingly\r\n          if (typeof sgfAliases[key] !== 'undefined') {\r\n\r\n            //The position in the JGF object is represented by dot separated strings\r\n            //in the sgfAliases array. Split the position and use the setInfo helper\r\n            //to set the info on the JGF object\r\n            setInfo(jgf, sgfAliases[key].split('.'), values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF alias present either, just append the data\r\n\r\n          //Save in node\r\n          if (node) {\r\n            node[key] = values;\r\n          }\r\n\r\n          //Save in root\r\n          else {\r\n            jgf[key] = values;\r\n          }\r\n        }\r\n\r\n        //Reset node, unless this was the root node\r\n        if (node && !node.root) {\r\n          node = null;\r\n        }\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeCommon :: This class governs common event handling of the player shared by\r\n * various player modes. It's basically an abstract player mode and it can't be actively set.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Common.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Run block\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\r\n\r\n  /**\r\n   * Register common event handlers\r\n   */\r\n  Player.on('keydown', PlayerModeCommon.keyDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n}])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\r\n\r\n  /**\r\n   * Helper to build drag object\r\n   */\r\n  function dragObject(event) {\r\n\r\n    //Initialize drag object\r\n    var drag = {\r\n      start: {\r\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\r\n      },\r\n      stop: {\r\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\r\n      }\r\n    };\r\n\r\n    //Fix boundaries\r\n    if (drag.start.x < 0) {\r\n      drag.start.x = 0;\r\n    }\r\n    if (drag.start.y < 0) {\r\n      drag.start.y = 0;\r\n    }\r\n    if (drag.stop.x > this.board.width - 1) {\r\n      drag.stop.x = this.board.width - 1;\r\n    }\r\n    if (drag.stop.y > this.board.height - 1) {\r\n      drag.stop.y = this.board.height - 1;\r\n    }\r\n\r\n    //Return\r\n    return drag;\r\n  }\r\n\r\n  /**\r\n   * Normalize the mousewheel event helper\r\n   */\r\n  function normalizeMousewheelEvent(event) {\r\n\r\n    //Initialize vars\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n\r\n    //Old school scrollwheel delta\r\n    if ('detail' in event) {\r\n      deltaY = event.detail * -1;\r\n    }\r\n    if ('wheelDelta' in event) {\r\n      deltaY = event.wheelDelta;\r\n    }\r\n    if ('wheelDeltaY' in event) {\r\n      deltaY = event.wheelDeltaY;\r\n    }\r\n    if ('wheelDeltaX' in event) {\r\n      deltaX = event.wheelDeltaX * -1;\r\n    }\r\n\r\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\r\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n      deltaX = deltaY * -1;\r\n      deltaY = 0;\r\n    }\r\n\r\n    //New type wheel delta (WheelEvent)\r\n    if ('deltaY' in event) {\r\n      deltaY = event.deltaY * -1;\r\n    }\r\n    if ('deltaX' in event) {\r\n      deltaX = event.deltaX;\r\n    }\r\n\r\n    //Set in event (have to use different property name because of strict mode)\r\n    event.mouseWheelX = deltaX;\r\n    event.mouseWheelY = deltaY;\r\n\r\n    //Return\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Player extension\r\n   */\r\n  angular.extend(Player, {\r\n\r\n    /**\r\n     * Mouse coordinate helper vars\r\n     */\r\n    mouse: {\r\n\r\n      //Drag start\r\n      dragStart: null,\r\n\r\n      //Last grid coordinates\r\n      lastX: -1,\r\n      lastY: -1\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Player mode definition\r\n   */\r\n  var PlayerMode = {\r\n\r\n    /**\r\n     * Handler for keydown events\r\n     */\r\n    keyDown: function(event, keyboardEvent) {\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Switch key code\r\n      switch (keyboardEvent.keyCode) {\r\n\r\n        //ESC\r\n        case KeyCodes.ESC:\r\n\r\n          //Cancel drag event, and prevent click event as well\r\n          this.mouse.dragStart = null;\r\n          this.preventClickEvent = true;\r\n          break;\r\n\r\n        //Right arrow\r\n        case KeyCodes.RIGHT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Advance to the next move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\r\n              this.next();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Left arrow\r\n        case KeyCodes.LEFT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Go to the previous move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\r\n              this.previous();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Up arrow\r\n        case KeyCodes.UP:\r\n          break;\r\n\r\n        //Down arrow\r\n        case KeyCodes.DOWN:\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handler for mousewheel events\r\n     */\r\n    mouseWheel: function(event, mouseEvent) {\r\n\r\n      //Disabled or not using move tool?\r\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\r\n        return true;\r\n      }\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return true;\r\n      }\r\n\r\n      //Normalize mousewheel event\r\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\r\n\r\n      //Find delta\r\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\r\n\r\n      //Next move\r\n      if (delta < 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.next();\r\n      }\r\n\r\n      //Previous move\r\n      else if (delta > 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.previous();\r\n      }\r\n\r\n      //Don't scroll the window\r\n      if (delta !== 0) {\r\n        mouseEvent.preventDefault();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse out handler\r\n     */\r\n    mouseOut: function() {\r\n      if (this.board) {\r\n        this.board.removeAll('hover');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse move handler\r\n     */\r\n    mouseMove: function(event, mouseEvent) {\r\n\r\n      //Attach drag object to events\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n      }\r\n\r\n      //Nothing else to do?\r\n      if (!this.board || !this.board.layers.hover) {\r\n        return;\r\n      }\r\n\r\n      //Last coordinates are the same?\r\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\r\n        return;\r\n      }\r\n\r\n      //Remember last coordinates\r\n      this.mouse.lastX = event.x;\r\n      this.mouse.lastY = event.y;\r\n\r\n      //Broadcast hover event\r\n      this.broadcast('hover', mouseEvent);\r\n    },\r\n\r\n    /**\r\n     * Mouse down handler\r\n     */\r\n    mouseDown: function(event) {\r\n      this.mouse.dragStart = {\r\n        x: event.x,\r\n        y: event.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Mouse up handler\r\n     */\r\n    mouseUp: function(event, mouseEvent) {\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n        this.broadcast('mousedrag', mouseEvent);\r\n      }\r\n      this.mouse.dragStart = null;\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return PlayerMode;\r\n}]);\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\r\n * a game record and its board positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Edit.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Setup tools\r\n */\r\n.constant('SetupTools', {\r\n  BLACK: 'black',\r\n  WHITE: 'white',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Markup tools\r\n */\r\n.constant('MarkupTools', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy',\r\n  TEXT: 'text',\r\n  NUMBER: 'number',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\r\n\r\n  //Register event handlers\r\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\r\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\r\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\r\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\r\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\r\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\r\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeEdit', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\r\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\r\n  ) {\r\n\r\n    //Character codes\r\n    var aChar = 'A'.charCodeAt(0);\r\n    var aCharLc = 'a'.charCodeAt(0);\r\n\r\n    /**\r\n     * Update hover mark at specific coordinates\r\n     */\r\n    function updateHoverMark(x, y, isDrag) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Setup tool\r\n        case PlayerTools.SETUP:\r\n\r\n          //Clear tool\r\n          if (this.setupTool === SetupTools.CLEAR) {\r\n\r\n            //Stone present? Can remove it\r\n            if (this.game.hasStone(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Stone color tool\r\n          else {\r\n\r\n            //Add or overwrite stone if no stone present of the given color\r\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'stones',\r\n                value: this.setupToolColor()\r\n              });\r\n            }\r\n\r\n            //Stone present of same color? Can remove it if we're not dragging\r\n            else if (!isDrag) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Markup tool\r\n        case PlayerTools.MARKUP:\r\n\r\n          //Clear tool, or already markup in place?\r\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\r\n            if (this.game.hasMarkup(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Text or number\r\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: {\r\n                type: MarkupTypes.LABEL,\r\n                text: this.markupLabel\r\n              }\r\n            });\r\n          }\r\n\r\n          //Other markup\r\n          else {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: this.markupTool\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set markup\r\n     */\r\n    function setMarkup(x, y) {\r\n\r\n      //Already markup in place? Remove it first\r\n      if (this.game.hasMarkup(x, y)) {\r\n\r\n        //Check what markup there is\r\n        var markup = this.game.getMarkup(x, y);\r\n\r\n        //Label? Also remove from our labels list\r\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\r\n          var i = this.markupLabels.indexOf(markup.text);\r\n          if (i !== -1) {\r\n            this.markupLabels.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        //Remove from game\r\n        this.game.removeMarkup(x, y);\r\n        return;\r\n      }\r\n\r\n      //Clear tool used? Done\r\n      if (this.markupTool === MarkupTools.CLEAR) {\r\n        return;\r\n      }\r\n\r\n      //Text\r\n      else if (this.markupTool === MarkupTools.TEXT) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next text label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Number\r\n      else if (this.markupTool === MarkupTools.NUMBER) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next number label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Other markup\r\n      else {\r\n        this.game.addMarkup(x, y, this.markupTool);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set a stone\r\n     */\r\n    function setStone(x, y, isDrag) {\r\n\r\n      //Get the stone color\r\n      var color = this.setupToolColor();\r\n\r\n      //Trying to remove a stone\r\n      if (color === StoneColor.EMPTY) {\r\n        this.game.removeStone(x, y);\r\n      }\r\n\r\n      //Adding a stone\r\n      else {\r\n\r\n        //A stone there already of the same color? Just remove if not dragging\r\n        if (!isDrag && this.game.hasStone(x, y, color)) {\r\n          this.game.removeStone(x, y);\r\n          return;\r\n        }\r\n\r\n        //Any stone present?\r\n        else if (this.game.hasStone(x, y)) {\r\n          this.game.removeStone(x, y);\r\n        }\r\n\r\n        //Add stone now\r\n        this.game.addStone(x, y, color);\r\n      }\r\n\r\n      //Redraw markup\r\n      this.board.layers.markup.redrawCell(x, y);\r\n    }\r\n\r\n    /**\r\n     * Find all markup labels in current position\r\n     */\r\n    function findAllMarkupLabels() {\r\n\r\n      //Clear\r\n      this.markupLabels = [];\r\n\r\n      //Must have game\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get all markup from position\r\n      var markup = this.game.position.markup.all('type');\r\n      for (var i = 0; i < markup.length; i++) {\r\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\r\n          this.markupLabels.push(markup[i].text);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Active setup tool and markup tool\r\n      setupTool: SetupTools.BLACK,\r\n      markupTool: MarkupTools.TRIANGLE,\r\n\r\n      //Current markup labels on the board and current markup label\r\n      markupLabels: [],\r\n      markupLabel: '',\r\n\r\n      /**\r\n       * Set the setup tool\r\n       */\r\n      switchSetupTool: function(tool) {\r\n        this.setupTool = tool;\r\n      },\r\n\r\n      /**\r\n       * Set the markup tool\r\n       */\r\n      switchMarkupTool: function(tool) {\r\n        this.markupTool = tool;\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          this.determineMarkupLabel();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Conversion of setup tool to stone color\r\n       */\r\n      setupToolColor: function() {\r\n        switch (this.setupTool) {\r\n          case SetupTools.BLACK:\r\n            return StoneColor.B;\r\n          case SetupTools.WHITE:\r\n            return StoneColor.W;\r\n          default:\r\n            return StoneColor.EMPTY;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the new text markup label\r\n       */\r\n      setMarkupLabel: function(label) {\r\n        if (label) {\r\n          this.markupLabel = label;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Determine the new text markup label\r\n       */\r\n      determineMarkupLabel: function() {\r\n\r\n        //Clear\r\n        this.markupLabel = '';\r\n\r\n        //Check what tool we're using\r\n        switch (this.markupTool) {\r\n\r\n          //Text tool?\r\n          case MarkupTools.TEXT:\r\n            var i = 0;\r\n\r\n            //Loop while the label is present\r\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n\r\n              //A-Z\r\n              if (i < 26) {\r\n                this.markupLabel = String.fromCharCode(aChar + i);\r\n              }\r\n\r\n              //a-z\r\n              else if (i < 52) {\r\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\r\n              }\r\n\r\n              //AA, AB, AC, etc.\r\n              else {\r\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\r\n                  String.fromCharCode(aChar + (i % 26));\r\n              }\r\n\r\n              //Keep going\r\n              i++;\r\n            }\r\n            break;\r\n\r\n          //Number tool?\r\n          case MarkupTools.NUMBER:\r\n            this.markupLabel = 0;\r\n\r\n            //Loop while the label is present\r\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n              this.markupLabel++;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeEdit = {\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items\r\n        this.board.removeAll('hover');\r\n\r\n        //Single coordinate?\r\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //No dragging for labels\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //Loop area\r\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n            updateHoverMark.call(this, x, y, true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Keydown handler\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //TODO: tool switching via keyboard input\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Click handler\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        this.board.removeAll('hover');\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Try to play the move\r\n            if (!this.game.play(event.x, event.y)) {\r\n              return;\r\n            }\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Set stone and update board\r\n            setStone.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Set markup and update board\r\n            setMarkup.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Mouse drag handler\r\n       */\r\n      mouseDrag: function(event) {\r\n\r\n        //Initialize vars\r\n        var x, y;\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setStone.call(this, x, y, true);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Don't do this for labels\r\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n              break;\r\n            }\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setMarkup.call(this, x, y);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change\r\n       */\r\n      pathChange: function() {\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SETUP,\r\n          PlayerTools.MARKUP,\r\n          PlayerTools.SCORE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Find all markup labels in the current game position\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeEdit;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\r\n * through an existing game record without the ability to deviate from the tree or its variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Replay.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\r\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\r\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\r\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\r\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\r\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\r\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\r\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\r\n\r\n  //Register the mode\r\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeReplay', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Auto play delay\r\n    autoPlayDelay: 1000\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show move variations on the board\r\n     */\r\n    function showMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n\r\n        //Auto variation markup should never overwrite existing markup\r\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\r\n          continue;\r\n        }\r\n\r\n        //Add to board\r\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n          type: this.board.theme.get('markup.variation.type'),\r\n          text: this.board.theme.get('markup.variation.text', i),\r\n          color: this.board.theme.get('markup.variation.color')\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide move variations from the board\r\n     */\r\n    function hideMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) move variations on the board\r\n     */\r\n    function drawMoveVariations(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get the current node\r\n      var node = this.game.getNode();\r\n      var variations;\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      //Child variations?\r\n      if (this.variationChildren && node.hasMoveVariations()) {\r\n        variations = node.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n\r\n      //Sibling variations?\r\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\r\n        variations = node.parent.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Auto play vars\r\n      autoPlaying: false,\r\n      autoPlayDelay: 1000,\r\n      autoPlayPromise: null,\r\n\r\n      /**\r\n       * Set auto play delay\r\n       */\r\n      setAutoPlayDelay: function(delay) {\r\n        if (this.autoPlayDelay !== delay) {\r\n          this.autoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'autoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Start auto play with a given delay\r\n       */\r\n      start: function(delay) {\r\n\r\n        //Not in replay mode or already auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Already auto playing, no game or no move children?\r\n        if (!this.game || !this.game.node.hasChildren()) {\r\n          return;\r\n        }\r\n\r\n        //Get self\r\n        var self = this;\r\n\r\n        //Determine delay\r\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\r\n\r\n        //Switch tool\r\n        this.switchTool(PlayerTools.NONE);\r\n\r\n        //Create interval\r\n        this.autoPlaying = true;\r\n        this.autoPlayPromise = $interval(function() {\r\n\r\n          //Advance to the next node\r\n          self.next(0, true);\r\n\r\n          //Ran out of children?\r\n          if (!self.game.node.hasChildren()) {\r\n            self.stop();\r\n          }\r\n        }, delay);\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStarted', this.game.node);\r\n      },\r\n\r\n      /**\r\n       * Stop auto play\r\n       */\r\n      stop: function() {\r\n\r\n        //Not in replay mode or not auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Cancel interval\r\n        if (this.autoPlayPromise) {\r\n          $interval.cancel(this.autoPlayPromise);\r\n        }\r\n\r\n        //Clear flags\r\n        this.autoPlayPromise = null;\r\n        this.autoPlaying = false;\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStopped', this.game.node);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeReplay = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'variationMarkup') {\r\n          drawMoveVariations.call(this, this.variationMarkup);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Check if we clicked a move variation, advance to the next position if so\r\n            if (this.game.isMoveVariation(event.x, event.y)) {\r\n              this.next(this.game.getMoveVariation(event.x, event.y));\r\n            }\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeReplay.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SCORE,\r\n          PlayerTools.NONE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Stop auto playing\r\n        if (this.autoPlaying) {\r\n          this.stop();\r\n        }\r\n\r\n        //Hide move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, false);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeReplay;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\r\n * go problems and finding the right move or variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Solve.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\r\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\r\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\r\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\r\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\r\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\r\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\r\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Player color\r\n    playerColor: StoneColor.B,\r\n\r\n    //Show solution paths\r\n    solutionPaths: false,\r\n\r\n    //Auto play settings\r\n    solveAutoPlay: true,\r\n    solveAutoPlayDelay: 500\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\r\n\r\n    /**\r\n     * Check if we can make a move\r\n     */\r\n    function canMakeMove() {\r\n\r\n      //We can make a move when...\r\n\r\n      //...there is no auto play going on\r\n      if (!this.solveAutoPlay) {\r\n        return true;\r\n      }\r\n\r\n      //...we solved the puzzle already\r\n      if (this.problemSolved) {\r\n        return true;\r\n      }\r\n\r\n      //...we are off path\r\n      if (this.problemOffPath) {\r\n        return true;\r\n      }\r\n\r\n      //...it's our turn\r\n      if (this.game.getTurn() === this.playerColor) {\r\n        return true;\r\n      }\r\n\r\n      //Otherwise, we can't make a move\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show solution paths\r\n     */\r\n    function showSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        if (variations[i].solution === true) {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.valid.type'),\r\n            text: this.board.theme.get('markup.solution.valid.text', i),\r\n            scale: this.board.theme.get('markup.solution.valid.scale'),\r\n            color: this.board.theme.get('markup.solution.valid.color')\r\n          });\r\n        }\r\n        else {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.invalid.type'),\r\n            text: this.board.theme.get('markup.solution.invalid.text', i),\r\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\r\n            color: this.board.theme.get('markup.solution.invalid.color')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide solution paths\r\n     */\r\n    function hideSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) solution paths\r\n     */\r\n    function drawSolutionPaths(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get node and variations\r\n      var node = this.game.getNode();\r\n      var variations = node.getMoveVariations();\r\n\r\n      //When showing, make sure it's not during the auto solver's move\r\n      if (show && !this.problemSolved && this.solveAutoPlay) {\r\n        if (this.game.getTurn() !== this.playerColor) {\r\n          hideSolutionPaths.call(this, variations);\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Call helper\r\n      if (show) {\r\n        showSolutionPaths.call(this, variations);\r\n      }\r\n      else {\r\n        hideSolutionPaths.call(this, variations);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Solved and off-path flags\r\n      problemSolved: false,\r\n      problemOffPath: false,\r\n\r\n      //Problem start path\r\n      problemStartPath: null,\r\n\r\n      //The player color\r\n      playerColor: 0,\r\n\r\n      //Solution paths\r\n      solutionPaths: false,\r\n\r\n      //Auto play vars\r\n      solveAutoPlay: true,\r\n      solveAutoPlayDelay: 500,\r\n\r\n      //Navigation blocked flag\r\n      solveNavigationBlocked: false,\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlay: function(autoPlay) {\r\n        if (this.solveAutoPlay !== autoPlay) {\r\n          this.solveAutoPlay = autoPlay;\r\n          this.broadcast('settingChange', 'solveAutoPlay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlayDelay: function(delay) {\r\n        if (this.solveAutoPlayDelay !== delay) {\r\n          this.solveAutoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set player color\r\n       */\r\n      setPlayerColor: function(color) {\r\n        if (this.playerColor !== color) {\r\n          this.playerColor = color;\r\n          this.broadcast('settingChange', 'playerColor');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Get player color\r\n       */\r\n      getPlayerColor: function(asOnBoard) {\r\n        if (asOnBoard && this.board) {\r\n          return this.board.colorMultiplier * this.playerColor;\r\n        }\r\n        return this.playerColor;\r\n      },\r\n\r\n      /**\r\n       * Toggle solution paths\r\n       */\r\n      toggleSolutionPaths: function(solutionPaths) {\r\n\r\n        //Toggle if not given\r\n        if (typeof solutionPaths === 'undefined') {\r\n          solutionPaths = !this.solutionPaths;\r\n        }\r\n\r\n        //Change?\r\n        if (solutionPaths !== this.solutionPaths) {\r\n          this.solutionPaths = solutionPaths;\r\n          this.broadcast('settingChange', 'solutionPaths');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Auto play next move\r\n       */\r\n      autoPlayNext: function(immediately) {\r\n\r\n        //Must have game and children\r\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\r\n          return;\r\n        }\r\n\r\n        //Init vars\r\n        var children = [];\r\n        var self = this;\r\n        var i;\r\n\r\n        //When picking a child node, we always prefer to pick a valid solution\r\n        for (i = 0; i < this.game.node.children.length; i++) {\r\n          if (this.game.node.children[i].solution) {\r\n            children.push(this.game.node.children[i]);\r\n          }\r\n        }\r\n\r\n        //No solution nodes? Just use all nodes then.\r\n        if (children.length === 0) {\r\n          children = this.game.node.children;\r\n        }\r\n\r\n        //Pick a random child node\r\n        i = Math.floor(Math.random() * children.length);\r\n\r\n        //No delay?\r\n        if (immediately || !this.solveAutoPlayDelay) {\r\n          this.next(children[i]);\r\n          return;\r\n        }\r\n\r\n        //Block navigation and run the timeout\r\n        this.solveNavigationBlocked = true;\r\n        $timeout(function() {\r\n\r\n          //Move to next move and unblock navigation\r\n          self.next(children[i]);\r\n          self.solveNavigationBlocked = false;\r\n\r\n        }, this.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Start solving from the current game node\r\n       */\r\n      solve: function() {\r\n\r\n        //Must have a game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return false;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Remember problem start path\r\n        this.problemStartPath = this.game.getPath(true);\r\n\r\n        //Restrict start of navigation to the current node\r\n        this.restrictNode();\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restart the problem\r\n       */\r\n      restartProblem: function() {\r\n\r\n        //Must be in solve mode, must have game\r\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Go back to the start path\r\n        if (this.problemStartPath) {\r\n          this.goto(this.problemStartPath);\r\n        }\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeSolve = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.toggleSolutionPaths(this.config.solutionPaths);\r\n        this.setPlayerColor(this.config.playerColor);\r\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\r\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'solutionPaths') {\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n        }\r\n\r\n        //Player color changed?\r\n        if (setting === 'playerColor') {\r\n\r\n          //Draw (or hide) solution paths\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n\r\n          //Make an auto play move if it's not our turn\r\n          if (\r\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\r\n          ) {\r\n            this.autoPlayNext(true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this, event.x, event.y);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for keydown events\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //Right arrow\r\n          case KeyCodes.RIGHT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\r\n\r\n                //Go forward one move if solved\r\n                if (this.problemSolved) {\r\n                  this.next();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n\r\n          //Left arrow\r\n          case KeyCodes.LEFT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked and not reached the start?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\r\n\r\n                //Go back one move\r\n                this.previous();\r\n\r\n                //Go back one more if this is not the player's turn and if\r\n                //the problem hasn't been solved yet\r\n                if (\r\n                  !this.problemSolved && this.solveAutoPlay &&\r\n                  this.game.getTurn() === -this.playerColor\r\n                ) {\r\n                  this.previous();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //A valid variation\r\n        if (this.game.isMoveVariation(event.x, event.y)) {\r\n\r\n          //Get the node\r\n          var i = this.game.getMoveVariation(event.x, event.y);\r\n\r\n          //Advance to the next position and get the next node\r\n          this.next(i);\r\n          var node = this.game.getNode();\r\n\r\n          //No children left? Check if we solved it or not\r\n          if (node.children.length === 0) {\r\n            if (node.solution === true) {\r\n              this.problemSolved = true;\r\n              this.broadcast('solutionFound', node);\r\n            }\r\n            else {\r\n              this.broadcast('solutionWrong', node);\r\n            }\r\n          }\r\n\r\n          //Auto-play next move?\r\n          else if (!this.problemSolved && this.solveAutoPlay) {\r\n            this.autoPlayNext();\r\n          }\r\n        }\r\n\r\n        //Unknown variation, try to play\r\n        else if (this.game.play(event.x, event.y)) {\r\n          this.problemOffPath = true;\r\n          this.processPosition();\r\n          this.broadcast('solutionOffPath', this.game.getNode());\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Draw solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Hide any solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, false);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeSolve;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n","/**\n * ng-go - v1.3.1.2 - 10-9-2016\n * https://github.com/cookwu/ngGo\n *\n * Copyright (c) 2016 Cook Wu <cookwu@webaker.net>\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n/**\r\n * ngGo\r\n *\r\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\r\n * refactored to fit the Angular framework, as well as having been linted, properly commented\r\n * and generally cleaned up.\r\n *\r\n * Copyright (c) 2013 Jan Prokop (WGo)\r\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify, merge,\r\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\r\n * to whom the Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo', [])\r\n\r\n/**\r\n * ngGo constants\r\n */\r\n.constant('ngGo', {\r\n  name: 'ngGo',\r\n  version: '1.3.1',\r\n  error: {\r\n\r\n    //Position errors\r\n    POSITION_OUT_OF_BOUNDS: 1,\r\n    POSITION_ALREADY_HAS_STONE: 2,\r\n    POSITION_IS_SUICIDE: 3,\r\n    POSITION_IS_REPEATING: 4,\r\n\r\n    //Data loading errors\r\n    NO_DATA: 5,\r\n    UNKNOWN_DATA: 6,\r\n    INVALID_SGF: 7,\r\n    INVALID_GIB: 8,\r\n    INVALID_JGF_JSON: 9,\r\n    INVALID_JGF_TREE_JSON: 10\r\n  }\r\n})\r\n\r\n/**\r\n * Stone colors\r\n */\r\n.constant('StoneColor', {\r\n  E: 0,\r\n  EMPTY: 0,\r\n  B: 1,\r\n  BLACK: 1,\r\n  W: -1,\r\n  WHITE: -1\r\n})\r\n\r\n/**\r\n * Markup types\r\n */\r\n.constant('MarkupTypes', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  LABEL: 'label',\r\n  LAST: 'last',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy'\r\n})\r\n\r\n/**\r\n * Player modes\r\n */\r\n.constant('PlayerModes', {\r\n  PLAY: 'play',\r\n  REPLAY: 'replay',\r\n  EDIT: 'edit',\r\n  SOLVE: 'solve'\r\n})\r\n\r\n/**\r\n * Player tools\r\n */\r\n.constant('PlayerTools', {\r\n  NONE: 'none',\r\n  MOVE: 'move',\r\n  SCORE: 'score',\r\n  SETUP: 'setup',\r\n  MARKUP: 'markup'\r\n})\r\n\r\n/**\r\n * Key codes\r\n */\r\n.constant('KeyCodes', {\r\n  LEFT: 37,\r\n  RIGHT: 39,\r\n  UP: 38,\r\n  DOWN: 40,\r\n  ESC: 27,\r\n  ENTER: 13,\r\n  SPACE: 32,\r\n  TAB: 9,\r\n  SHIFT: 16,\r\n  CTRL: 17,\r\n  ALT: 18,\r\n  HOME: 36,\r\n  END: 35,\r\n  PAGEUP: 33,\r\n  PAGEDOWN: 34\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidDataError :: Error class to handle invalid data.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidDataError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidDataError(code) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidDataError';\r\n    this.message = 'Invalid data: ';\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.NO_DATA:\r\n        this.message += 'no data to process.';\r\n        break;\r\n      case ngGo.error.UNKNOWN_DATA:\r\n        this.message += 'unknown data format.';\r\n        break;\r\n      case ngGo.error.INVALID_GIB:\r\n        this.message += 'unable to parse GIB data.';\r\n        break;\r\n      case ngGo.error.INVALID_SGF:\r\n        this.message += 'unable to parse SGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_JSON:\r\n        this.message += 'unable to parse JGF data.';\r\n        break;\r\n      case ngGo.error.INVALID_JGF_TREE_JSON:\r\n        this.message += 'unable to parse the JGF tree data.';\r\n        break;\r\n      default:\r\n        this.message += 'unable to parse the data.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidDataError.prototype = new Error();\r\n  InvalidDataError.prototype.constructor = InvalidDataError;\r\n\r\n  //Return object\r\n  return InvalidDataError;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * InvalidPositionError :: Error class to handle invalid moves.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\r\n\r\n  /**\r\n   * Define error\r\n   */\r\n  function InvalidPositionError(code, x, y, color) {\r\n\r\n    //Set name and message\r\n    this.code = code;\r\n    this.name = 'InvalidPositionError';\r\n    this.message = 'Invalid position detected.';\r\n\r\n    //Add position data\r\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\r\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\r\n        ' stone on (' + x + ', ' + y + ')';\r\n    }\r\n\r\n    //Append code message\r\n    switch (code) {\r\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\r\n        this.message += ', but these coordinates are not on the board.';\r\n        break;\r\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\r\n        this.message += ', but there is already a stone on those coordinates.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_SUICIDE:\r\n        this.message += ', but that would be suicide.';\r\n        break;\r\n      case ngGo.error.POSTITION_IS_REPEATING:\r\n        this.message += ', but this position already occured.';\r\n        break;\r\n      default:\r\n        this.message += '.';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extend from error class\r\n   */\r\n  InvalidPositionError.prototype = new Error();\r\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\r\n\r\n  //Return object\r\n  return InvalidPositionError;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Directive', [\r\n  'ngGo.Board.Service'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('board', ['$window', 'Board', function($window, Board) {\r\n\r\n  //Get pixel ratio\r\n  var pixelRatio = window.devicePixelRatio || 1;\r\n\r\n  /**\r\n   * Helper to create a layer canvas\r\n   */\r\n  function createLayerCanvas(name) {\r\n\r\n    //Create canvas element and get context\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    //Scale context depending on pixel ratio\r\n    if (pixelRatio > 1) {\r\n      context.scale(pixelRatio, pixelRatio);\r\n    }\r\n\r\n    //Set class\r\n    canvas.className = name;\r\n\r\n    //Set initial canvas width/height based on our own size\r\n    canvas.width = this.clientWidth * pixelRatio;\r\n    canvas.height = this.clientHeight * pixelRatio;\r\n\r\n    //Append to element now and return context\r\n    this.appendChild(canvas);\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Helper to determine draw size\r\n   */\r\n  function determineDrawSize(scope, availableWidth, availableHeight) {\r\n\r\n    //Init vars\r\n    var drawWidth, drawHeight, cellSize;\r\n\r\n    //Stretch available height to width if zero\r\n    if (availableHeight === 0 && availableWidth > 0) {\r\n      availableHeight = availableWidth;\r\n    }\r\n\r\n    //Grid size known?\r\n    if (scope.Board.width && scope.Board.height) {\r\n\r\n      //Determine smallest cell size\r\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\r\n\r\n      //Set draw size\r\n      drawWidth = Math.floor(cellSize * scope.Board.width);\r\n      drawHeight = Math.floor(cellSize * scope.Board.height);\r\n    }\r\n\r\n    //Otherwise, use the lesser of the available width/height\r\n    else {\r\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\r\n    }\r\n\r\n    //Broadcast new size if changed\r\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\r\n      scope.lastDrawWidth = drawWidth;\r\n      scope.lastDrawHeight = drawHeight;\r\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\r\n      return true;\r\n    }\r\n\r\n    //No change\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Directive\r\n   */\r\n  return {\r\n    restrict: 'E',\r\n    scope: {\r\n      instance: '&'\r\n    },\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Init vars\r\n      var i, context, layer, playerElement;\r\n      var parent = element.parent();\r\n      var sizingElement = element[0];\r\n      var existingInstance = true;\r\n\r\n      //Remember last draw width/height\r\n      scope.lastDrawWidth = 0;\r\n      scope.lastDrawHeight = 0;\r\n\r\n      //Get board instance\r\n      scope.Board = scope.instance();\r\n\r\n      //Function given?\r\n      if (typeof scope.Board === 'function') {\r\n        scope.Board = scope.Board();\r\n      }\r\n\r\n      //Instantiate board if not present in scope\r\n      if (!scope.Board) {\r\n        existingInstance = false;\r\n        scope.Board = new Board();\r\n      }\r\n\r\n      //Link element\r\n      scope.Board.linkElement(element);\r\n\r\n      //Find player element\r\n      if (parent[0].tagName === 'PLAYER') {\r\n        playerElement = parent;\r\n        sizingElement = parent.parent()[0];\r\n      }\r\n\r\n      //Listen for board drawsize events\r\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\r\n\r\n        //First set the new dimensions on the canvas elements\r\n        var canvas = element.find('canvas');\r\n        for (i = 0; i < canvas.length; i++) {\r\n          canvas[i].width = width * pixelRatio;\r\n          canvas[i].height = height * pixelRatio;\r\n        }\r\n\r\n        //Set on the element if we're using a player element and if there is a size\r\n        if (playerElement || attrs.forceSize === 'true') {\r\n          element.css({width: width + 'px', height: height + 'px'});\r\n        }\r\n\r\n        //Next set it on the board itself\r\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\r\n      });\r\n\r\n      //Determine initial draw size\r\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n\r\n      //On window resize, determine the draw size again\r\n      angular.element($window).on('resize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On manual resize, determine draw size again\r\n      scope.$on('ngGo.board.determineDrawSize', function() {\r\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\r\n      });\r\n\r\n      //On board grid resize, determine the draw size again\r\n      scope.$on('ngGo.board.resize', function(event, board) {\r\n\r\n        //Only relevent if this was our own board\r\n        if (board !== scope.Board) {\r\n          return;\r\n        }\r\n\r\n        //If the draw size didn't change, the draw size event won't be triggered.\r\n        //However, that means we should call the resized() method now manually because\r\n        //it won't be called with the setDrawSize() call.\r\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\r\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\r\n          scope.Board.resized();\r\n        }\r\n      });\r\n\r\n      //Static board\r\n      if (attrs.static && attrs.static === 'true') {\r\n\r\n        //Add static class and make the board static\r\n        element.addClass('static');\r\n        scope.Board.makeStatic();\r\n\r\n        //Create single canvas and link to all relevant layer service classes\r\n        context = createLayerCanvas.call(element[0], 'static');\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Dynamic board\r\n      else {\r\n\r\n        //Create individual layer canvasses and link the canvas context to the layer service class\r\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\r\n          layer = scope.Board.layerOrder[i];\r\n          context = createLayerCanvas.call(element[0], layer);\r\n          scope.Board.layers[layer].setContext(context);\r\n        }\r\n      }\r\n\r\n      //Observe the board size attribute\r\n      attrs.$observe('size', function(size) {\r\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\r\n          size = size.split('x');\r\n          scope.Board.setSize(size[0], size[1]);\r\n        }\r\n        else {\r\n          scope.Board.setSize(size, size);\r\n        }\r\n      });\r\n\r\n      //Observe the coordinates attribute\r\n      attrs.$observe('coordinates', function(attr) {\r\n        scope.Board.toggleCoordinates(attr === 'true');\r\n      });\r\n\r\n      //Observe the cutoff attribute\r\n      attrs.$observe('cutoff', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.setCutoff(attr.split(','));\r\n        }\r\n      });\r\n\r\n      //Observe color multiplier\r\n      attrs.$observe('colorMultiplier', function(attr) {\r\n        if (angular.isDefined(attr)) {\r\n          scope.Board.swapColors(attr);\r\n        }\r\n      });\r\n\r\n      //Link board to player if present in parent scope\r\n      if (scope.$parent.Player) {\r\n        scope.$parent.Player.setBoard(scope.Board);\r\n      }\r\n\r\n      //Redraw board if we had an existing instance (it might contain data)\r\n      if (existingInstance) {\r\n        scope.Board.redraw();\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\r\n * and is used for placing and removing objects on the board. The class has helpers to figure out\r\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\r\n * responsible for drawing all layers on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Directive',\r\n  'ngGo.Board.Theme.Service',\r\n  'ngGo.Board.Layer.GridLayer.Service',\r\n  'ngGo.Board.Layer.ShadowLayer.Service',\r\n  'ngGo.Board.Layer.StonesLayer.Service',\r\n  'ngGo.Board.Layer.MarkupLayer.Service',\r\n  'ngGo.Board.Layer.ScoreLayer.Service',\r\n  'ngGo.Board.Layer.HoverLayer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.Stone.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Board', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Width and height\r\n    width: 0,\r\n    height: 0,\r\n\r\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\r\n    cutoff: [],\r\n\r\n    //Section of board to display\r\n    section: {top: 0, right: 0, bottom: 0, left: 0},\r\n\r\n    //Show coordinates?\r\n    coordinates: false,\r\n\r\n    //Color multiplier (use -1 to swap colors)\r\n    colorMultiplier: 1\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\r\n\r\n    /**\r\n     * Board constructor\r\n     */\r\n    function Board(config) {\r\n\r\n      //Initialize board\r\n      this.init();\r\n\r\n      //Parse config\r\n      this.parseConfig(config || {});\r\n    }\r\n\r\n    /**\r\n     * Initialize board\r\n     */\r\n    Board.prototype.init = function() {\r\n\r\n      //Remove everything\r\n      this.removeAll();\r\n\r\n      //Set board theme\r\n      this.theme = new BoardTheme();\r\n\r\n      //Initialize board draw dimensions in pixels\r\n      this.cellSize = 0;\r\n      this.drawWidth = 0;\r\n      this.drawHeight = 0;\r\n      this.drawMarginHor = 0;\r\n      this.drawMarginVer = 0;\r\n      this.gridDrawWidth = 0;\r\n      this.gridDrawHeight = 0;\r\n\r\n      //Set layer order\r\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\r\n\r\n      //Initialize layers\r\n      this.layers = {};\r\n      for (var l = 0; l < this.layerOrder.length; l++) {\r\n        var layer = this.layerOrder[l];\r\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\r\n        var LayerClass = $injector.get(layerClass);\r\n        this.layers[layer] = new LayerClass(this);\r\n      }\r\n\r\n      //Static board flag\r\n      this.static = false;\r\n\r\n      //Get margin from theme\r\n      this.margin = this.theme.get('board.margin');\r\n\r\n      //Color multiplier (to allow color swapping)\r\n      this.colorMultiplier = 1;\r\n\r\n      //Turn off coordinates\r\n      this.coordinates = false;\r\n      this.layers.grid.setCoordinates(false);\r\n\r\n      //Initialize grid size\r\n      this.width = 0;\r\n      this.height = 0;\r\n\r\n      //Initialize cutoff\r\n      this.cutoff = {\r\n        top: false,\r\n        left: false,\r\n        right: false,\r\n        bottom: false\r\n      };\r\n\r\n      //Initialize section\r\n      this.section = {\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Link the board to a HTML element\r\n     */\r\n    Board.prototype.linkElement = function(element) {\r\n      this.element = element;\r\n    };\r\n\r\n    /**\r\n     * Make this board static (one canvas layer, only grid, stones and markup)\r\n     */\r\n    Board.prototype.makeStatic = function() {\r\n      this.static = true;\r\n      this.layerOrder = ['grid', 'stones', 'markup'];\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Configuration\r\n     ***/\r\n\r\n    /**\r\n     * Parse config instructions\r\n     */\r\n    Board.prototype.parseConfig = function(config) {\r\n\r\n      //Validate\r\n      if (typeof config !== 'object') {\r\n        return;\r\n      }\r\n\r\n      //Extend from default config\r\n      config = angular.extend({}, defaultConfig, config);\r\n\r\n      //Process settigns\r\n      this.toggleCoordinates(config.coordinates);\r\n      this.swapColors(config.colorMultiplier);\r\n      this.setCutoff(config.cutoff);\r\n      this.setSection(config.section);\r\n      this.setSize(config.width, config.height);\r\n    };\r\n\r\n    /**\r\n     * Set margin\r\n     */\r\n    Board.prototype.setMargin = function(margin) {\r\n\r\n      //Reset when not defined\r\n      if (typeof margin === 'undefined') {\r\n        margin = this.theme.get('board.margin');\r\n      }\r\n\r\n      //Set margin if changed\r\n      if (this.margin !== margin) {\r\n        this.margin = margin;\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set grid cut-off\r\n     */\r\n    Board.prototype.setCutoff = function(cutoff) {\r\n\r\n      //Nothing given? Reset cutoff\r\n      if (!cutoff || !angular.isArray(cutoff)) {\r\n        cutoff = [];\r\n      }\r\n\r\n      //Init\r\n      var changes = false;\r\n\r\n      //Check if there's a change\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff.hasOwnProperty(side)) {\r\n          if (cutoff.indexOf(side) !== -1) {\r\n            if (!this.cutoff[side]) {\r\n              this.cutoff[side] = true;\r\n              changes = true;\r\n            }\r\n          }\r\n          else {\r\n            if (this.cutoff[side]) {\r\n              this.cutoff[side] = false;\r\n              changes = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Trigger resized if there were changes\r\n      if (changes) {\r\n        this.resized();\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set section of the board to be displayed\r\n     */\r\n    Board.prototype.setSection = function(section) {\r\n\r\n      //Nothing given?\r\n      if (!section || typeof section !== 'object') {\r\n        return this;\r\n      }\r\n\r\n      //Expand on default\r\n      section = angular.extend({\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      }, section);\r\n\r\n      //No changes?\r\n      if (\r\n        this.section.top === section.top && this.section.bottom === section.bottom &&\r\n        this.section.left === section.left && this.section.right === section.right\r\n      ) {\r\n        return this;\r\n      }\r\n\r\n      //Set section and call resized handler\r\n      this.section = section;\r\n      this.resized();\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set board size. This will clear the board objects.\r\n     */\r\n    Board.prototype.setSize = function(width, height) {\r\n\r\n      //Check what's given\r\n      width = parseInt(width || height || 0);\r\n      height = parseInt(height || width || 0);\r\n\r\n      //Invalid?\r\n      if (isNaN(width) || isNaN(height)) {\r\n        return;\r\n      }\r\n\r\n      //Changing?\r\n      if (width !== this.width || height !== this.height) {\r\n\r\n        //Remember size\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        //Set size in layers\r\n        for (var layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].setSize(width, height);\r\n          }\r\n        }\r\n\r\n        //Broadcast event (no call to resized, as that is handled in the directive)\r\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Set new draw size\r\n     */\r\n    Board.prototype.setDrawSize = function(width, height) {\r\n      if (width !== this.drawWidth || height !== this.drawHeight) {\r\n        this.drawWidth = width;\r\n        this.drawHeight = height;\r\n        this.resized();\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Toggle the coordinates\r\n     */\r\n    Board.prototype.toggleCoordinates = function(show) {\r\n\r\n      //Set or toggle\r\n      if (typeof show !== 'undefined') {\r\n        this.coordinates = show;\r\n      }\r\n      else {\r\n        this.coordinates = !this.coordinates;\r\n      }\r\n\r\n      //Set in grid layer\r\n      this.layers.grid.setCoordinates(this.coordinates);\r\n\r\n      //Set the proper board margin\r\n      if (this.coordinates) {\r\n        this.setMargin(this.theme.get('coordinates.margin'));\r\n      }\r\n      else {\r\n        this.setMargin(this.theme.get('board.margin'));\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Swap colors on the board\r\n     */\r\n    Board.prototype.swapColors = function(multiplier) {\r\n\r\n      //Multiplier not given? Set to inverse of current value\r\n      if (typeof multiplier === 'undefined') {\r\n        multiplier = -this.colorMultiplier;\r\n      }\r\n      else {\r\n        multiplier = parseInt(multiplier);\r\n        if (isNaN(multiplier)) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //No change?\r\n      if (multiplier === this.colorMultiplier) {\r\n        return;\r\n      }\r\n\r\n      //Set new value\r\n      this.colorMultiplier = multiplier;\r\n\r\n      //For static board, redraw the whole thing\r\n      if (this.static) {\r\n        this.redraw();\r\n      }\r\n\r\n      //For a dynamic board, only these layers\r\n      else {\r\n        this.redraw('stones');\r\n        this.redraw('markup');\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Theme handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the current theme object\r\n     */\r\n    Board.prototype.getTheme = function() {\r\n      return this.theme;\r\n    };\r\n\r\n    /**\r\n     * Set the theme object\r\n     */\r\n    Board.prototype.setTheme = function(theme) {\r\n      this.theme = theme;\r\n      return this;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Object handling\r\n     ***/\r\n\r\n    /**\r\n     * Add an object to a board layer\r\n     */\r\n    Board.prototype.add = function(layer, x, y, value) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].add(x, y, value);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove an object from a board layer\r\n     */\r\n    Board.prototype.remove = function(layer, x, y) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].remove(x, y);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get something from a board layer\r\n     */\r\n    Board.prototype.get = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].get(x, y));\r\n    };\r\n\r\n    /**\r\n     * Check if we have something at given coordinates for a given layer\r\n     */\r\n    Board.prototype.has = function(layer, x, y) {\r\n      return (this.layers[layer] && this.layers[layer].has(x, y));\r\n    };\r\n\r\n    /**\r\n     * Set all objects (grid) for a given layer\r\n     */\r\n    Board.prototype.setAll = function(layer, grid) {\r\n      if (typeof this.layers[layer] !== 'undefined') {\r\n        this.layers[layer].setAll(grid);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove all objects from the board, optionally for a given layer\r\n     */\r\n    Board.prototype.removeAll = function(layer) {\r\n      if (layer) {\r\n        if (typeof this.layers[layer] !== 'undefined') {\r\n          this.layers[layer].removeAll();\r\n        }\r\n      }\r\n      else {\r\n        for (layer in this.layers) {\r\n          if (this.layers.hasOwnProperty(layer)) {\r\n            this.layers[layer].removeAll();\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Position handling\r\n     ***/\r\n\r\n    /**\r\n     * Update the board with a new position\r\n     */\r\n    Board.prototype.updatePosition = function(position, pathChanged) {\r\n\r\n      //If we have no grid size yet, use what's in the position\r\n      if (!this.width || !this.height) {\r\n        this.setSize(position.width, position.height);\r\n      }\r\n\r\n      //Remove markup if path changed\r\n      if (pathChanged) {\r\n        this.removeAll('markup');\r\n      }\r\n\r\n      //Set new stones and markup grids\r\n      this.setAll('stones', position.stones);\r\n      this.setAll('markup', position.markup);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state (list of objects per layer)\r\n     */\r\n    Board.prototype.getState = function(layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          return this.layers[layer].getAll();\r\n        }\r\n        return null;\r\n      }\r\n\r\n      //All layers\r\n      var state = {};\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          var grid = this.layers[layer].getAll();\r\n          if (grid && !grid.isEmpty()) {\r\n            state[layer] = grid;\r\n          }\r\n        }\r\n      }\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the board state from given state object\r\n     */\r\n    Board.prototype.restoreState = function(state, layer) {\r\n\r\n      //Only specific layer?\r\n      if (layer) {\r\n        if (this.layers[layer]) {\r\n          this.layers[layer].setAll(state);\r\n        }\r\n        return;\r\n      }\r\n\r\n      //All layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].removeAll();\r\n          if (state[layer]) {\r\n            this.layers[layer].setAll(state[layer]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing control\r\n     ***/\r\n\r\n    /**\r\n     * Clear the whole board\r\n     */\r\n    Board.prototype.clear = function(layer) {\r\n\r\n      //Just clearing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Clear the layer\r\n        this.layers[layer].clear();\r\n        return;\r\n      }\r\n\r\n      //Static? One clear is enough\r\n      if (this.static) {\r\n        this.layers.stones.clear();\r\n        return;\r\n      }\r\n\r\n      //Clear all layers\r\n      for (layer in this.layers) {\r\n        if (this.layers.hasOwnProperty(layer)) {\r\n          this.layers[layer].clear();\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Redraw everything or just a single layer\r\n     */\r\n    Board.prototype.redraw = function(layer) {\r\n\r\n      //The board can only be redrawn when there is a grid size and a draw size\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Just redrawing one layer?\r\n      if (layer) {\r\n\r\n        //If the board is static or the layer is unknown, we can't do this\r\n        if (this.static || !this.layers[layer]) {\r\n          return;\r\n        }\r\n\r\n        //Redraw the layer\r\n        this.layers[layer].redraw();\r\n        return;\r\n      }\r\n\r\n      //Clear the board first\r\n      this.clear();\r\n\r\n      //Now draw all layers again in the correct order\r\n      for (var i = 0; i < this.layerOrder.length; i++) {\r\n        layer = this.layerOrder[i];\r\n        this.layers[layer].draw();\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Drawing helpers\r\n     ***/\r\n\r\n    /**\r\n     * Called after a board size change, draw size change, section change or margin change\r\n     */\r\n    Board.prototype.resized = function() {\r\n\r\n      //Determine the new grid\r\n      this.grid = {\r\n        xLeft: 0 + this.section.left,\r\n        xRight: this.width - 1 - this.section.right,\r\n        yTop: 0 + this.section.top,\r\n        yBot: this.height - 1 - this.section.bottom\r\n      };\r\n\r\n      //Only redraw when there is sensible data\r\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\r\n        return;\r\n      }\r\n\r\n      //Determine number of cells horizontall and vertically\r\n      //The margin is a factor of the cell size, so let's add it to the number of cells\r\n      var noCellsHor = this.width + this.margin;\r\n      var noCellsVer = this.height + this.margin;\r\n\r\n      //Are we cutting off parts of the grid? Add half a cell of draw size\r\n      for (var side in this.cutoff) {\r\n        if (this.cutoff[side]) {\r\n          if (side === 'top' || side === 'bottom') {\r\n            noCellsVer += 0.5;\r\n          }\r\n          else {\r\n            noCellsHor += 0.5;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Determine cell size now\r\n      this.cellSize = Math.floor(Math.min(\r\n        this.drawWidth / noCellsHor,\r\n        this.drawHeight / noCellsVer\r\n      ));\r\n\r\n      //Determine actual grid draw size (taking off the margin again)\r\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\r\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\r\n\r\n      //Determine draw margins\r\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\r\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\r\n\r\n      //Redraw\r\n      this.redraw();\r\n    };\r\n\r\n    /**\r\n     * Get the current cell size\r\n     */\r\n    Board.prototype.getCellSize = function() {\r\n      return this.cellSize;\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsX = function(gridX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert grid coordinate to pixel coordinate\r\n     */\r\n    Board.prototype.getAbsY = function(gridY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridX = function(absX) {\r\n      var offset = this.cutoff.left ? 0.5 : 0;\r\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Convert pixel coordinate to grid coordinate\r\n     */\r\n    Board.prototype.getGridY = function(absY) {\r\n      var offset = this.cutoff.top ? 0.5 : 0;\r\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\r\n    };\r\n\r\n    /**\r\n     * Check if given grid coordinates are on board\r\n     */\r\n    Board.prototype.isOnBoard = function(gridX, gridY) {\r\n      return (\r\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\r\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\r\n      );\r\n    };\r\n\r\n    //Return object\r\n    return Board;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\r\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\r\n * a small rectangular area on the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('DefaultClearHandler', function() {\r\n\r\n  /**\r\n   * Clear handler definition\r\n   *\r\n   * All external handlers are called from the context of the layer that contains the object.\r\n   * First parameter is the canvas2d context, second parameter is the object itself.\r\n   */\r\n  return function(context, obj) {\r\n\r\n    //No context?\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(obj.x);\r\n    var y = this.board.getAbsY(obj.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Clear rectangle the size of the stone radius\r\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\r\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\r\n * stone color values for the game position class. It has built in validation of coordinates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Grid.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.GridChanges.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\r\n\r\n  /**\r\n   * Helper to convert a value at given coordinates to an object\r\n   */\r\n  function toObject(x, y, valueKey) {\r\n\r\n    //Create coordinates object\r\n    var obj = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Already an object?\r\n    if (typeof this.grid[x][y] === 'object') {\r\n      return angular.extend(obj, this.grid[x][y]);\r\n    }\r\n\r\n    //Not an object, set value with given value key and return\r\n    obj[valueKey] = this.grid[x][y];\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardGrid(width, height, emptyValue) {\r\n\r\n    //Initialize size and grid array\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.grid = [];\r\n    this.emptyValue = null;\r\n\r\n    //Set empty value if given\r\n    if (typeof emptyValue !== 'undefined') {\r\n      this.emptyValue = emptyValue;\r\n    }\r\n\r\n    //Size given? Set it\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a value\r\n   */\r\n  BoardGrid.prototype.set = function(x, y, value) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Unset a value\r\n   */\r\n  BoardGrid.prototype.unset = function(x, y) {\r\n    if (this.isOnGrid(x, y)) {\r\n      this.grid[x][y] = this.emptyValue;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Check if we have a non null value on the coordinates\r\n   */\r\n  BoardGrid.prototype.has = function(x, y) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\r\n  };\r\n\r\n  /**\r\n   * Check if we have a specific value on the coordinates\r\n   */\r\n  BoardGrid.prototype.is = function(x, y, value) {\r\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\r\n  };\r\n\r\n  /**\r\n   * Get a value, or an object with coordinates and the value in the given value key\r\n   */\r\n  BoardGrid.prototype.get = function(x, y, valueKey) {\r\n\r\n    //Validate\r\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\r\n      return this.emptyValue;\r\n    }\r\n\r\n    //Return as is?\r\n    if (!valueKey) {\r\n      return this.grid[x][y];\r\n    }\r\n\r\n    //Return as object\r\n    return toObject.call(this, x, y, valueKey);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Mass operations\r\n   ***/\r\n\r\n  /**\r\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\r\n   * and the value in the given value key will be returned.\r\n   */\r\n  BoardGrid.prototype.all = function(valueKey) {\r\n\r\n    //Just get the grid?\r\n    if (!valueKey) {\r\n      return this.grid;\r\n    }\r\n\r\n    //Initialize objects list\r\n    var objects = [];\r\n\r\n    //Loop coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          objects.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return objects list\r\n    return objects;\r\n  };\r\n\r\n  /**\r\n   * Check if there is anything\r\n   */\r\n  BoardGrid.prototype.isEmpty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== this.emptyValue) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Populate the whole grid with a given value\r\n   */\r\n  BoardGrid.prototype.populate = function(value) {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = value;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Empty the grid\r\n   */\r\n  BoardGrid.prototype.empty = function() {\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clone ourselves\r\n   */\r\n  BoardGrid.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newGrid = new BoardGrid();\r\n\r\n    //Manually set vars for maximum efficiency\r\n    newGrid.grid = angular.copy(this.grid);\r\n    newGrid.emptyValue = this.emptyValue;\r\n    newGrid.width = this.width;\r\n    newGrid.height = this.height;\r\n\r\n    //Return\r\n    return newGrid;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Comparison\r\n   ***/\r\n\r\n  /**\r\n   * Checks if a given grid is the same as the current grid\r\n   */\r\n  BoardGrid.prototype.isSameAs = function(grid) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== grid.width || this.height !== grid.height) {\r\n      return false;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n        if (this.grid[x][y] !== grid[x][y]) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    //No differences found\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Compares this position with another position and return change object\r\n   */\r\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\r\n\r\n    //Initialize board grid changes object\r\n    var changes = new BoardGridChanges();\r\n\r\n    //Must have the same size\r\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\r\n      console.warn('Trying to compare grids of a different size');\r\n      return changes;\r\n    }\r\n\r\n    //Loop all coordinates\r\n    for (var x = 0; x < this.width; x++) {\r\n      for (var y = 0; y < this.height; y++) {\r\n\r\n        //Something to add?\r\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\r\n        }\r\n\r\n        //Something to remove?\r\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\r\n          changes.remove.push(toObject.call(this, x, y, valueKey));\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return changes grid\r\n    return changes;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to validate coordinates (first param can be an object)\r\n   */\r\n  BoardGrid.prototype.isOnGrid = function(x, y) {\r\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\r\n  };\r\n\r\n  /**\r\n   * Helper to set the empty value\r\n   */\r\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\r\n    this.emptyValue = emptyValue;\r\n  };\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  BoardGrid.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Create grid array\r\n    this.grid = [];\r\n    for (var x = 0; x < this.width; x++) {\r\n      this.grid[x] = [];\r\n      for (var y = 0; y < this.height; y++) {\r\n        this.grid[x][y] = this.emptyValue;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the grid size object\r\n   */\r\n  BoardGrid.prototype.getSize = function() {\r\n    return {width: this.width, height: this.height};\r\n  };\r\n\r\n  //Return\r\n  return BoardGrid;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\r\n * grids. It simply keeps track of what was added and what was removed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.GridChanges.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardGridChanges', function() {\r\n\r\n  /**\r\n   * Helper to subtract sets\r\n   */\r\n  function setSubtract(a, b) {\r\n    var n = [];\r\n    var q;\r\n    for (var i = 0; i < a.length; i++) {\r\n      q = true;\r\n      for (var j in b) {\r\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\r\n          q = false;\r\n          break;\r\n        }\r\n      }\r\n      if (q) {\r\n        n.push(a[i]);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /**\r\n   * Grid changes constructor\r\n   */\r\n  return function() {\r\n\r\n    /**\r\n     * Containers\r\n     */\r\n    this.add = [];\r\n    this.remove = [];\r\n\r\n    /**\r\n     * Concatenation helper\r\n     */\r\n    this.concat = function(newChanges) {\r\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\r\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\r\n    };\r\n\r\n    /**\r\n     * Check if there are changes\r\n     */\r\n    this.has = function() {\r\n      return !!(this.add.length || this.remove.length);\r\n    };\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\r\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\r\n * for drawing itself as well as its objects onto the canvas.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function BoardLayer(board, context) {\r\n\r\n    //Remember board reference and 2d canvas context\r\n    this.board = board;\r\n    this.context = context;\r\n\r\n    //Initialize grid for board objects\r\n    this.grid = new BoardGrid();\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Generic grid and object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set grid size\r\n   */\r\n  BoardLayer.prototype.setSize = function(width, height) {\r\n\r\n    //Note: since this method is usually only called upon a global board resize,\r\n    //which also triggers the redraw method for layers, the layer is not cleared\r\n    //here, as it will happen anyway during the redraw cycle.\r\n\r\n    //Set it in the grid (removing all objects in the process)\r\n    this.grid.setSize(width, height);\r\n  };\r\n\r\n  /**\r\n   * Get all items\r\n   */\r\n  BoardLayer.prototype.getAll = function() {\r\n    return this.grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Set all items at once\r\n   */\r\n  BoardLayer.prototype.setAll = function(grid) {\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  BoardLayer.prototype.removeAll = function() {\r\n    this.clear();\r\n    this.grid.empty();\r\n  };\r\n\r\n  /**\r\n   * Add a single item\r\n   */\r\n  BoardLayer.prototype.add = function(x, y, value) {\r\n    this.clearCell(x, y);\r\n    this.grid.set(x, y, value);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Remove a single item\r\n   */\r\n  BoardLayer.prototype.remove = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.grid.unset(x, y);\r\n  };\r\n\r\n  /**\r\n   * Get an item\r\n   */\r\n  BoardLayer.prototype.get = function(x, y) {\r\n    return this.grid.get(x, y);\r\n  };\r\n\r\n  /**\r\n   * Check if there is an item\r\n   */\r\n  BoardLayer.prototype.has = function(x, y) {\r\n    return this.grid.has(x, y);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Generic drawing methods\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  BoardLayer.prototype.draw = function() {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\r\n   */\r\n  BoardLayer.prototype.clear = function() {\r\n    if (this.context) {\r\n      this.context.clearRect(\r\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  BoardLayer.prototype.redraw = function() {\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\r\n    //Drawing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\r\n    //Clearing method to be implemented in specific layer class\r\n  };\r\n\r\n  /**\r\n   * Redraw cell\r\n   */\r\n  BoardLayer.prototype.redrawCell = function(x, y) {\r\n    this.clearCell(x, y);\r\n    this.drawCell(x, y);\r\n  };\r\n\r\n  /**\r\n   * Set the canvas2d context\r\n   */\r\n  BoardLayer.prototype.setContext = function(context) {\r\n    this.context = context;\r\n  };\r\n\r\n  /**\r\n   * Get the canvas2d context\r\n   */\r\n  BoardLayer.prototype.getContext = function() {\r\n    return this.context;\r\n  };\r\n\r\n  //Return\r\n  return BoardLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardObject :: Base class for drawing board objects\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.DefaultClearHandler.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var BoardObject = {\r\n\r\n    /**\r\n     * Draw method\r\n     */\r\n    draw: function(/*obj*/) {\r\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear method\r\n     */\r\n    clear: function(obj) {\r\n      DefaultClearHandler.call(this, this.context, obj);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return BoardObject;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.ShellPattern.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShellPattern', function() {\r\n\r\n  /**\r\n   * Helper to draw a shell line\r\n   */\r\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\r\n\r\n    //Initialize\r\n    ctx.shadowBlur = 2;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = (radius / 30) * this.thickness;\r\n    ctx.beginPath();\r\n\r\n    //Lower radius\r\n    radius -= Math.max(1, ctx.lineWidth);\r\n\r\n    //Determine coordinates\r\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\r\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\r\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\r\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\r\n\r\n    //Math magic\r\n    var m, angle;\r\n    if (x2 > x1) {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m);\r\n    }\r\n    else if (x2 === x1) {\r\n      angle = Math.PI / 2;\r\n    }\r\n    else {\r\n      m = (y2 - y1) / (x2 - x1);\r\n      angle = Math.atan(m) - Math.PI;\r\n    }\r\n\r\n    //Curvature factor\r\n    var c = this.factor * radius;\r\n    var dx = Math.sin(angle) * c;\r\n    var dy = Math.cos(angle) * c;\r\n\r\n    //Curvature coordinates\r\n    var bx1 = x1 + dx;\r\n    var by1 = y1 - dy;\r\n    var bx2 = x2 + dx;\r\n    var by2 = y2 - dy;\r\n\r\n    //Draw shell stroke\r\n    ctx.moveTo(x1, y1);\r\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Shell pattern drawer\r\n   */\r\n  return function(ctx, x, y, radius, angle, strokeStyle) {\r\n\r\n    //Initialize start and end angle\r\n    var startAngle = angle;\r\n    var endAngle = angle;\r\n\r\n    //Loop lines\r\n    for (var i = 0; i < this.lines.length; i++) {\r\n      startAngle += this.lines[i];\r\n      endAngle -= this.lines[i];\r\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\r\n    }\r\n  };\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\r\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\r\n * use static values or dynamic values depending on other properties, like the grid cell size.\r\n * Using the provider, the theme can be configured globally at application launch.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Theme.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\r\n\r\n  /**\r\n   * Default theme\r\n   */\r\n  var defaultTheme = {\r\n\r\n    //Board\r\n    board: {\r\n\r\n      //Board margin factor\r\n      margin: 0.25\r\n    },\r\n\r\n    //Stones\r\n    stone: {\r\n\r\n      //Stone style can be shell, glass, mono, or specify a custom handler service\r\n      style: 'shell',\r\n      shadow: true,\r\n      radius: function(cellSize) {\r\n        return Math.floor(cellSize / 2);\r\n      },\r\n\r\n      //Shell stones\r\n      shell: {\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#111';\r\n          }\r\n          return '#BFBFBA';\r\n        },\r\n        stroke: 'rgba(128,128,128,0.15)',\r\n        types: [\r\n          {\r\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\r\n            factor: 0.15,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\r\n            factor: 0.1,\r\n            thickness: 1.5\r\n          },\r\n          {\r\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\r\n            factor: 0.05,\r\n            thickness: 1.75\r\n          },\r\n          {\r\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\r\n            factor: 0.1,\r\n            thickness: 2\r\n          }\r\n        ]\r\n      },\r\n\r\n      //Mono stones\r\n      mono: {\r\n        lineWidth: 1,\r\n        lineColor: function() {\r\n          return '#000';\r\n        },\r\n        color: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return '#000';\r\n          }\r\n          return '#fff';\r\n        }\r\n      },\r\n\r\n      //Mini stones\r\n      mini: {\r\n        scale: 0.5,\r\n        alpha: 1\r\n      },\r\n\r\n      //Faded stones\r\n      faded: {\r\n        scale: 1,\r\n        alpha: function(stoneColor) {\r\n          if (stoneColor === StoneColor.B) {\r\n            return 0.3;\r\n          }\r\n          return 0.4;\r\n        }\r\n      }\r\n    },\r\n\r\n    //Shadows\r\n    shadow: {\r\n\r\n      //Shadow gradient colors\r\n      color: 'rgba(40,30,20,0.5)',\r\n\r\n      //Shadow size\r\n      size: function(cellSize) {\r\n        return Math.floor(cellSize / 20);\r\n      },\r\n\r\n      //Shadow blur size\r\n      blur: function(cellSize) {\r\n        return cellSize / 20;\r\n      },\r\n\r\n      //Shadow offset\r\n      offsetX: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      },\r\n      offsetY: function(cellSize) {\r\n        return Math.ceil(cellSize / 20);\r\n      }\r\n    },\r\n\r\n    //Markup\r\n    markup: {\r\n\r\n      //Standard color\r\n      color: function(stoneColor) {\r\n        if (stoneColor === StoneColor.B) {\r\n          return 'rgba(255,255,255,0.9)';\r\n        }\r\n        return 'rgba(0,0,0,0.9)';\r\n      },\r\n\r\n      //Line width\r\n      lineWidth: function(cellSize) {\r\n        return Math.max(1, Math.floor(cellSize / 16));\r\n      },\r\n\r\n      //Triangle\r\n      triangle: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Square\r\n      square: {\r\n        scale: 0.85\r\n      },\r\n\r\n      //Cricle\r\n      circle: {\r\n        scale: 0.55\r\n      },\r\n\r\n      //Mark\r\n      mark: {\r\n        lineCap: 'square',\r\n        scale: 0.75\r\n      },\r\n\r\n      //Last\r\n      last: {\r\n        scale: 0.7\r\n      },\r\n\r\n      //Smiley\r\n      smiley: {\r\n        lineCap: 'round',\r\n        scale: 0.85\r\n      },\r\n\r\n      //Label\r\n      label: {\r\n        font: 'Arial'\r\n      },\r\n\r\n      //Variation markup\r\n      variation: {\r\n        type: MarkupTypes.LABEL,\r\n        text: function(i) {\r\n          return String.fromCharCode(65 + i);\r\n        },\r\n        color: 'rgba(86,114,30,0.9)'\r\n      },\r\n\r\n      //Solution paths markup\r\n      solution: {\r\n        valid: {\r\n          type: MarkupTypes.SELECT,\r\n          text: null,\r\n          color: 'rgba(86,114,30,1)',\r\n          scale: 0.5\r\n        },\r\n        invalid: {\r\n          type: MarkupTypes.MARK,\r\n          text: null,\r\n          color: 'rgba(237,9,15,1)',\r\n          scale: 0.3\r\n        }\r\n      }\r\n    },\r\n\r\n    //Grid\r\n    grid: {\r\n\r\n      //Line properties\r\n      lineColor: 'rgba(60,40,15,1)',\r\n      lineWidth: function(cellSize) {\r\n        if (cellSize > 60) {\r\n          return 2;\r\n        }\r\n        else if (cellSize > 50) {\r\n          return 1.5;\r\n        }\r\n        return 1;\r\n      },\r\n      lineCap: 'square',\r\n\r\n      //Star points\r\n      star: {\r\n\r\n        //Color and radius\r\n        color: 'rgba(60,40,15,1)',\r\n        radius: function(cellSize) {\r\n          if (cellSize > 50) {\r\n            return Math.floor((cellSize / 16) + 1);\r\n          }\r\n          else if (cellSize > 30) {\r\n            return 3;\r\n          }\r\n          else if (cellSize > 15) {\r\n            return 2;\r\n          }\r\n          else if (cellSize > 5) {\r\n            return 1.5;\r\n          }\r\n          return 1;\r\n        },\r\n\r\n        //Locations\r\n        points: function(width, height) {\r\n\r\n          //19x19\r\n          if (width === height && width === 19) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\r\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\r\n            ];\r\n          }\r\n\r\n          //13x13\r\n          if (width === height && width === 13) {\r\n            return [\r\n              { x: 3, y: 3 }, { x: 9, y: 3 },\r\n              { x: 3, y: 9 }, { x: 9, y: 9 }\r\n            ];\r\n          }\r\n\r\n          //9x9\r\n          if (width === height && width === 9) {\r\n            return [\r\n              { x: 4, y: 4}, { x: 2, y: 2},\r\n              { x: 2, y: 6}, { x: 6, y: 2},\r\n              { x: 6, y: 6}\r\n            ];\r\n          }\r\n\r\n          //No star points\r\n          return [];\r\n        }\r\n      }\r\n    },\r\n\r\n    //Coordinates\r\n    coordinates: {\r\n\r\n      //Color\r\n      color: 'rgba(101,69,37,0.5)',\r\n\r\n      //Board margin factor when showing coordinates\r\n      margin: 1.25,\r\n\r\n      //Vertical coordinates style\r\n      vertical: {\r\n        font: 'Arial',\r\n        style: 'numbers',\r\n        inverse: true,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      },\r\n\r\n      //Horizontal coordinates style\r\n      horizontal: {\r\n        font: 'Arial',\r\n        style: 'letters',\r\n        inverse: false,\r\n        size: function() {\r\n          return function(ch, cellSize) {\r\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\r\n          };\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Set global default theme\r\n   */\r\n  this.setTheme = function(theme) {\r\n    if (theme) {\r\n      defaultTheme = angular.merge(defaultTheme, theme);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = function() {\r\n\r\n    /**\r\n     * Board theme constructor\r\n     */\r\n    function BoardTheme(theme) {\r\n\r\n      //Remember the given instance theme settings and (re)set the theme\r\n      this.instanceTheme = theme;\r\n      this.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the theme to defaults\r\n     */\r\n    BoardTheme.prototype.reset = function() {\r\n\r\n      //Use default theme as a base\r\n      this.theme = angular.copy(defaultTheme);\r\n\r\n      //Add any instance theme properties\r\n      if (this.instanceTheme) {\r\n        angular.merge(this.theme, this.instanceTheme);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Get a theme property\r\n     */\r\n    BoardTheme.prototype.get = function(property) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Can't find the property?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          console.warn('Could not find theme property', property);\r\n          return null;\r\n        }\r\n\r\n        //Advance further in the object\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Found what we're looking for\r\n      if (typeof prop !== 'function') {\r\n        return prop;\r\n      }\r\n\r\n      //Prepare arguments\r\n      var args = [];\r\n      if (arguments.length > 1) {\r\n        for (var a = 1; a < arguments.length; a++) {\r\n          args.push(arguments[a]);\r\n        }\r\n      }\r\n\r\n      //Call function\r\n      return prop.apply(this, args);\r\n    };\r\n\r\n    /**\r\n     * Change a theme property dynamically (accepts handler function as value)\r\n     */\r\n    BoardTheme.prototype.set = function(property, value) {\r\n\r\n      //Determine path to the property\r\n      var path = property.split('.');\r\n      var prop = this.theme;\r\n\r\n      //Loop path\r\n      for (var i = 0; i < path.length; i++) {\r\n\r\n        //Time to set?\r\n        if ((i + 1) === path.length) {\r\n          prop[path[i]] = value;\r\n          break;\r\n        }\r\n\r\n        //Not set?\r\n        if (typeof prop[path[i]] === 'undefined') {\r\n          prop[path[i]] = {};\r\n        }\r\n\r\n        //Move on\r\n        prop = prop[path[i]];\r\n      }\r\n\r\n      //Return self for chaining\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\r\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\r\n     */\r\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\r\n\r\n      //If no linewidth specified, use the grid line width as a reference\r\n      //to make sure stuff is aligned to the grid\r\n      if (typeof lineWidth === 'undefined') {\r\n        lineWidth = this.get('grid.lineWidth');\r\n      }\r\n\r\n      //Return a translation for uneven widths\r\n      return (lineWidth % 2) * 0.5;\r\n    };\r\n\r\n    //Return\r\n    return BoardTheme;\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Game :: This class represents a game record or a game that is being played/edited. The class\r\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\r\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\r\n * The class also keeps a stack of all board positions in memory and can validate moves to make\r\n * sure they are not repeating or suicide.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Path.Service',\r\n  'ngGo.Game.Node.Service',\r\n  'ngGo.Game.Position.Service',\r\n  'ngGo.Kifu.Blank.Service',\r\n  'ngGo.Kifu.Parser.Service',\r\n  'ngGo.Errors.InvalidDataError.Service',\r\n  'ngGo.Errors.InvalidPositionError.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.provider('Game', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default size of board\r\n    defaultSize: 0,\r\n\r\n    //Default komi and handicap\r\n    defaultKomi: 0,\r\n    defaultHandicap: 0,\r\n\r\n    //Remember last selected variation when traversing nodes\r\n    rememberPath: true,\r\n\r\n    //Check for repeating positions? (KO / ALL / empty)\r\n    checkRepeat: 'KO',\r\n\r\n    //Allow suicide?\r\n    allowSuicide: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\r\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\r\n    KifuBlank, InvalidDataError, InvalidPositionError\r\n  ) {\r\n\r\n    /*****************************************************************************\r\n     * General helpers\r\n     ***/\r\n\r\n    /**\r\n     * Validate the info we have to make sure the properties exist\r\n     */\r\n    function validateInfo() {\r\n\r\n      //Set board info if not set\r\n      if (!this.info.board) {\r\n        this.info.board = {};\r\n      }\r\n\r\n      //Set game info if not set\r\n      if (!this.info.game) {\r\n        this.info.game = {};\r\n      }\r\n\r\n      //Set defaults\r\n      if (typeof this.info.board.width === 'undefined') {\r\n        this.info.board.width = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.board.height === 'undefined') {\r\n        this.info.board.height = this.config.defaultSize;\r\n      }\r\n      if (typeof this.info.game.komi === 'undefined') {\r\n        this.info.game.komi = this.config.defaultKomi;\r\n      }\r\n      if (typeof this.info.game.handicap === 'undefined') {\r\n        this.info.game.handicap = this.config.defaultHandicap;\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Node navigation helpers\r\n     ***/\r\n\r\n    /**\r\n     * Navigate to the next node\r\n     */\r\n    function nextNode(i) {\r\n\r\n      //Check if we have children\r\n      if (this.node.children.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      //Remembered the path we took earlier?\r\n      if (i === undefined) {\r\n        i = this.node.rememberedPath;\r\n      }\r\n\r\n      //Determine which child node to process\r\n      i = i || 0;\r\n      if (i === -1) {\r\n        i = 0;\r\n      }\r\n\r\n      //Validate\r\n      if (i >= this.node.children.length || !this.node.children[i]) {\r\n        return false;\r\n      }\r\n\r\n      //Advance path\r\n      this.path.advance(i);\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.children[i];\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the previous node\r\n     */\r\n    function previousNode() {\r\n\r\n      //No parent node?\r\n      if (!this.node.parent) {\r\n        return false;\r\n      }\r\n\r\n      //Retreat path\r\n      this.path.retreat();\r\n\r\n      //Set pointer of current node\r\n      this.node = this.node.parent;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Navigate to the first node\r\n     */\r\n    function firstNode() {\r\n\r\n      //Reset path\r\n      this.path.reset();\r\n\r\n      //Set node pointer back to root\r\n      this.node = this.root;\r\n\r\n      //Set the initial turn depending on handicap\r\n      //Can be overwritten by game record instructions\r\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Position history helpers\r\n     ***/\r\n\r\n    /**\r\n     * Clear the position history and initialize with a blank position\r\n     */\r\n    function initializeHistory() {\r\n\r\n      //Already at beginning?\r\n      if (this.history.length === 1) {\r\n        return;\r\n      }\r\n\r\n      //Clear positions stack and create new blank position\r\n      this.history = [];\r\n      this.history.push(new GamePosition());\r\n\r\n      //Set board size if we have the info\r\n      if (this.info.board) {\r\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add position to stack. If position isn't specified current position is\r\n     * cloned and stacked. Pointer of actual position is moved to the new position.\r\n     */\r\n    function pushPosition(newPosition) {\r\n\r\n      //Position not given?\r\n      if (!newPosition) {\r\n        newPosition = this.position.clone();\r\n      }\r\n\r\n      //Push\r\n      this.history.push(newPosition);\r\n      return newPosition;\r\n    }\r\n\r\n    /**\r\n     * Remove current position from stack\r\n     */\r\n    function popPosition() {\r\n\r\n      //Nothing left?\r\n      if (this.history.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      //Get old position\r\n      return this.history.pop();\r\n    }\r\n\r\n    /**\r\n     * Replace the current position in the stack\r\n     */\r\n    function replacePosition(newPosition) {\r\n      if (newPosition) {\r\n        this.history.pop();\r\n        this.history.push(newPosition);\r\n      }\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Execution helpers\r\n     ***/\r\n\r\n    /**\r\n     * Execute the current node\r\n     */\r\n    function executeNode() {\r\n\r\n      //Remember last selected node if we have a parent\r\n      if (this.node.parent) {\r\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\r\n      }\r\n\r\n      //Initialize new position\r\n      var i;\r\n      var newPosition = this.position.clone();\r\n\r\n      //Handle moves\r\n      if (this.node.isMove()) {\r\n        if (this.node.move.pass) {\r\n          newPosition.setTurn(-this.node.move.color);\r\n        }\r\n        else {\r\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\r\n        }\r\n      }\r\n\r\n      //Handle turn instructions\r\n      if (this.node.turn) {\r\n        newPosition.setTurn(this.node.turn);\r\n      }\r\n\r\n      //Handle setup instructions\r\n      if (this.node.setup) {\r\n        for (i in this.node.setup) {\r\n          if (this.node.setup.hasOwnProperty(i)) {\r\n            newPosition.stones.set(\r\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Handle markup\r\n      if (this.node.markup) {\r\n        for (i in this.node.markup) {\r\n          if (this.node.markup.hasOwnProperty(i)) {\r\n            newPosition.markup.set(\r\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      //Push the new position into the history now\r\n      pushPosition.call(this, newPosition);\r\n    }\r\n\r\n    /*****************************************************************************\r\n     * Game class\r\n     ***/\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Game(data, config) {\r\n\r\n      //Extend config\r\n      this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n      //Define property getter/setter for position\r\n      Object.defineProperty(this, 'position', {\r\n\r\n        //Getter returns the last position from the stack\r\n        get: function() {\r\n          return this.history[this.history.length - 1];\r\n        },\r\n\r\n        //Setter adds a new position to the stack\r\n        set: function(newPosition) {\r\n          this.history[this.history.length] = newPosition;\r\n        }\r\n      });\r\n\r\n      //Load data\r\n      if (data) {\r\n        this.load(data);\r\n      }\r\n      else {\r\n        this.init();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Initialize\r\n     */\r\n    Game.prototype.init = function() {\r\n\r\n      //Info properties\r\n      this.info = {};\r\n\r\n      //The rood node and pointer to the current node\r\n      this.root = null;\r\n      this.node = null;\r\n\r\n      //Game path\r\n      this.path = new GamePath();\r\n\r\n      //JGF record we loaded from\r\n      this.jgf = null;\r\n\r\n      //Positions history stack\r\n      this.history = [];\r\n    };\r\n\r\n    /**\r\n     * Load game record data\r\n     */\r\n    Game.prototype.load = function(data) {\r\n\r\n      //Initialize\r\n      this.init();\r\n\r\n      //Try to load game record data\r\n      try {\r\n        this.fromData(data);\r\n      }\r\n      catch (errorCode) {\r\n\r\n        //Just initialize our history with a blank position\r\n        initializeHistory.call(this);\r\n\r\n        //Wrap error code in error object\r\n        throw new InvalidDataError(errorCode);\r\n      }\r\n\r\n      //Go to the first move\r\n      this.first();\r\n    };\r\n\r\n    /**\r\n     * Reload game record\r\n     */\r\n    Game.prototype.reload = function() {\r\n      if (this.jgf) {\r\n        this.load(this.jgf);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if we managed to load a valid game record\r\n     */\r\n    Game.prototype.isLoaded = function() {\r\n      return this.root !== null;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game cloning and conversion\r\n     ***/\r\n\r\n    /**\r\n     * Clone this game\r\n     */\r\n    Game.prototype.clone = function() {\r\n\r\n      //Create new kifu object and get properties\r\n      var clone = new Game();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy all properties\r\n      for (var p = 0; p < props.length; p++) {\r\n        clone[p] = angular.copy(this[p]);\r\n      }\r\n\r\n      //Return clone\r\n      return clone;\r\n    };\r\n\r\n    /**\r\n     * Load from an unknown data source\r\n     */\r\n    Game.prototype.fromData = function(data) {\r\n\r\n      //No data, can't do much\r\n      if (!data) {\r\n        throw ngGo.error.NO_DATA;\r\n      }\r\n\r\n      //String given, could be stringified JGF, an SGF or GIB file\r\n      if (typeof data === 'string') {\r\n        var c = data.charAt(0);\r\n        if (c === '(') {\r\n          return this.fromSgf(data);\r\n        }\r\n        else if (c === '{' || c === '[') {\r\n          return this.fromJgf(data);\r\n        }\r\n        else if (c === '\\\\') {\r\n          return this.fromGib(data);\r\n        }\r\n        else {\r\n          throw ngGo.error.UNKNOWN_DATA;\r\n        }\r\n      }\r\n\r\n      //Object given? Probably a JGF object\r\n      else if (typeof data === 'object') {\r\n        this.fromJgf(data);\r\n      }\r\n\r\n      //Something else?\r\n      else {\r\n        throw ngGo.error.UNKNOWN_DATA;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Load from GIB data\r\n     */\r\n    Game.prototype.fromGib = function(gib) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.gib2jgf(gib);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_GIB;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from SGF data\r\n     */\r\n    Game.prototype.fromSgf = function(sgf) {\r\n\r\n      //Use the kifu parser\r\n      var jgf = KifuParser.sgf2jgf(sgf);\r\n      if (!jgf) {\r\n        throw ngGo.error.INVALID_SGF;\r\n      }\r\n\r\n      //Now load from JGF\r\n      this.fromJgf(jgf);\r\n    };\r\n\r\n    /**\r\n     * Load from JGF data\r\n     */\r\n    Game.prototype.fromJgf = function(jgf) {\r\n\r\n      //Parse jgf string\r\n      if (typeof jgf === 'string') {\r\n        try {\r\n          jgf = angular.fromJson(jgf);\r\n        }\r\n        catch (error) {\r\n          throw ngGo.error.INVALID_JGF_JSON;\r\n        }\r\n      }\r\n\r\n      //If array given, convert to object with only tree\r\n      if (angular.isArray(jgf)) {\r\n        jgf = {\r\n          tree: jgf\r\n        };\r\n      }\r\n\r\n      //Parse tree string\r\n      if (typeof jgf.tree === 'string') {\r\n        if (jgf.tree.charAt(0) === '[') {\r\n          try {\r\n            jgf.tree = angular.fromJson(jgf.tree);\r\n          }\r\n          catch (error) {\r\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\r\n          }\r\n        }\r\n        else {\r\n          jgf.tree = [];\r\n        }\r\n      }\r\n\r\n      //Copy all properties except moves tree\r\n      for (var i in jgf) {\r\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\r\n          this.info[i] = angular.copy(jgf[i]);\r\n        }\r\n      }\r\n\r\n      //Validate info\r\n      validateInfo.call(this);\r\n\r\n      //Create root node\r\n      this.root = new GameNode();\r\n\r\n      //Tree given? Load all the moves\r\n      if (jgf.tree) {\r\n        this.root.fromJgf(jgf.tree);\r\n      }\r\n\r\n      //Remember JGF\r\n      this.jgf = jgf;\r\n    };\r\n\r\n    /**\r\n     * Convert to SGF\r\n     */\r\n    Game.prototype.toSgf = function() {\r\n      return KifuParser.jgf2sgf(this.toJgf());\r\n    };\r\n\r\n    /**\r\n     * Convert to JGF (optionally stringified)\r\n     */\r\n    Game.prototype.toJgf = function(stringify) {\r\n\r\n      //Initialize JGF and get properties\r\n      var jgf = KifuBlank.jgf();\r\n      var props = Object.getOwnPropertyNames(this);\r\n\r\n      //Copy properties\r\n      for (var p = 0; p < props.length; p++) {\r\n\r\n        //Skip root\r\n        if (p === 'root') {\r\n          continue;\r\n        }\r\n\r\n        //Already present on JGF object? Extend\r\n        if (jgf[p]) {\r\n          jgf[p] = angular.extend(jgf[p], this[p]);\r\n        }\r\n\r\n        //Otherwise copy\r\n        else {\r\n          jgf[p] = angular.copy(this[p]);\r\n        }\r\n      }\r\n\r\n      //Build tree\r\n      jgf.tree = this.root.toJgf();\r\n\r\n      //Return\r\n      return stringify ? angular.toJson(jgf) : jgf;\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Getters\r\n     ***/\r\n\r\n    /**\r\n     * Get current node\r\n     */\r\n    Game.prototype.getNode = function() {\r\n      return this.node;\r\n    };\r\n\r\n    /**\r\n     * Get nodes array for currently remembered path\r\n     */\r\n    Game.prototype.getNodes = function() {\r\n\r\n      //Initialize node to process\r\n      var node = this.root;\r\n      var nodes = [node];\r\n\r\n      //Process children\r\n      while (node) {\r\n        node = node.getChild(node.rememberedPath);\r\n        if (node) {\r\n          nodes.push(node);\r\n        }\r\n      }\r\n\r\n      //Return nodes\r\n      return nodes;\r\n    };\r\n\r\n    /**\r\n     * Get node for a certain move\r\n     */\r\n    Game.prototype.getMoveNode = function(move) {\r\n      var nodes = this.getMoveNodes(move, move);\r\n      return nodes.length ? nodes[0] : null;\r\n    };\r\n\r\n    /**\r\n     * Get move nodes restricted by given move numbers\r\n     */\r\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\r\n\r\n      //Get all nodes for the current path\r\n      var nodes = this.getNodes();\r\n\r\n      //Use sensible defaults if no from/to moves given\r\n      fromMove = fromMove || 1;\r\n      toMove = toMove || nodes.length;\r\n\r\n      //Filter\r\n      return nodes.filter(function(node) {\r\n        if (node.isMove()) {\r\n          var move = node.getMoveNumber();\r\n          return (move >= fromMove && move <= toMove);\r\n        }\r\n        return false;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Get current move number\r\n     */\r\n    Game.prototype.getMove = function() {\r\n      if (this.node) {\r\n        return this.node.getMoveNumber();\r\n      }\r\n      return 0;\r\n    };\r\n\r\n    /**\r\n     * Get the number of moves in the main branch\r\n     */\r\n    Game.prototype.getMoveCount = function() {\r\n      var moveNodes = this.getMoveNodes();\r\n      return moveNodes.length;\r\n    };\r\n\r\n    /**\r\n     * Get the move variation for given coordinates\r\n     */\r\n    Game.prototype.getMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.getMoveVariation(x, y);\r\n      }\r\n      return -1;\r\n    };\r\n\r\n    /**\r\n     * Get the current game position\r\n     */\r\n    Game.prototype.getPosition = function() {\r\n      return this.position;\r\n    };\r\n\r\n    /**\r\n     * Get the game path\r\n     */\r\n    Game.prototype.getPath = function(clone) {\r\n      if (clone) {\r\n        return this.path.clone();\r\n      }\r\n      return this.path;\r\n    };\r\n\r\n    /**\r\n     * Clone the current game path\r\n     */\r\n    Game.prototype.clonePath = function() {\r\n      return this.path.clone();\r\n    };\r\n\r\n    /**\r\n     * Get the game path to a certain named node\r\n     */\r\n    Game.prototype.getPathToNode = function(nodeName) {\r\n      return GamePath.findNode(nodeName, this.root);\r\n    };\r\n\r\n    /**\r\n     * Get the game komi\r\n     */\r\n    Game.prototype.getKomi = function() {\r\n      var komi = this.get('game.komi', 0);\r\n      return parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Set the game komi\r\n     */\r\n    Game.prototype.setKomi = function(komi) {\r\n      if (typeof komi === 'undefined') {\r\n        komi = this.config.defaultKomi;\r\n      }\r\n      this.info.game.komi = parseFloat(komi);\r\n    };\r\n\r\n    /**\r\n     * Get the game name\r\n     */\r\n    Game.prototype.getName = function() {\r\n      return this.get('game.name', '');\r\n    };\r\n\r\n    /**\r\n     * Get the game result\r\n     */\r\n    Game.prototype.getResult = function() {\r\n      return this.get('game.result', '');\r\n    };\r\n\r\n    /**\r\n     * Get the player turn for this position\r\n     */\r\n    Game.prototype.getTurn = function() {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return StoneColor.B;\r\n      }\r\n\r\n      //Get from position\r\n      return this.position.getTurn();\r\n    };\r\n\r\n    /**\r\n     * Set the player turn for the current position\r\n     */\r\n    Game.prototype.setTurn = function(color) {\r\n\r\n      //Must have a position\r\n      if (!this.history.length) {\r\n        return;\r\n      }\r\n\r\n      //Set in position\r\n      this.position.setTurn(color);\r\n    };\r\n\r\n    /**\r\n     * Get the total capture count up to the current position\r\n     */\r\n    Game.prototype.getCaptureCount = function() {\r\n\r\n      //Initialize\r\n      var captures = {};\r\n      captures[StoneColor.B] = 0;\r\n      captures[StoneColor.W] = 0;\r\n\r\n      //Loop all positions and increment capture count\r\n      for (var i = 0; i < this.history.length; i++) {\r\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\r\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\r\n      }\r\n\r\n      //Return\r\n      return captures;\r\n    };\r\n\r\n    /**\r\n     * Get an info property\r\n     */\r\n    Game.prototype.get = function(property, defaultValue) {\r\n\r\n      //Must have a property\r\n      if (!property) {\r\n        return;\r\n      }\r\n\r\n      //The item's property in the object is given by dot separated strings\r\n      if (typeof property === 'string') {\r\n        property = property.split('.');\r\n      }\r\n\r\n      //Initialize object we're getting info from\r\n      var obj = this.info;\r\n      var key;\r\n\r\n      //Loop the properties\r\n      for (var p = 0; p < property.length; p++) {\r\n\r\n        //Get actual key\r\n        key = property[p];\r\n\r\n        //Last key reached? Done, get value\r\n        if ((p + 1) === property.length) {\r\n          if (typeof obj[key] === 'undefined') {\r\n            return defaultValue;\r\n          }\r\n          return obj[key];\r\n        }\r\n\r\n        //Must be object container\r\n        if (typeof obj[key] !== 'object') {\r\n          console.warn('Game info property', key, 'is not an object');\r\n          return defaultValue;\r\n        }\r\n\r\n        //Move up in tree\r\n        obj = obj[key];\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Checkers\r\n     ***/\r\n\r\n    /**\r\n     * Check if coordinates are on the board\r\n     */\r\n    Game.prototype.isOnBoard = function(x, y) {\r\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\r\n    };\r\n\r\n    /**\r\n     * Check if given coordinates are one of the next child node coordinates\r\n     */\r\n    Game.prototype.isMoveVariation = function(x, y) {\r\n      if (this.node) {\r\n        return this.node.isMoveVariation(x, y);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Check if a given position is repeating within this game\r\n     */\r\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\r\n\r\n      //Init\r\n      var stop;\r\n\r\n      //Check for ko only? (Last two positions)\r\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\r\n        stop = this.history.length - 2;\r\n      }\r\n\r\n      //Check all history?\r\n      else if (this.checkRepeat === 'ALL') {\r\n        stop = 0;\r\n      }\r\n\r\n      //Not repeating\r\n      else {\r\n        return false;\r\n      }\r\n\r\n      //Loop history of positions to check\r\n      for (var i = this.history.length - 2; i >= stop; i--) {\r\n        if (checkPosition.isSameAs(this.history[i])) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      //Not repeating\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Wrapper for validateMove() returning a boolean and catching any errors\r\n     */\r\n    Game.prototype.isValidMove = function(x, y, color) {\r\n      try {\r\n        this.validateMove(x, y, color);\r\n        return true;\r\n      }\r\n      catch (error) {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if a move is valid. If valid, the new game position object is returned.\r\n     * You can supply a pre-created position to use, or the current position is cloned.\r\n     */\r\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Something already here?\r\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\r\n      }\r\n\r\n      //Set color of move to make\r\n      color = color || this.position.getTurn();\r\n\r\n      //Determine position to use\r\n      newPosition = newPosition || this.position.clone();\r\n\r\n      //Place the stone\r\n      newPosition.stones.set(x, y, color);\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = newPosition.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created?\r\n        if (!newPosition.hasLiberties(x, y)) {\r\n\r\n          //Capture the group if it's allowed\r\n          if (this.allowSuicide) {\r\n            newPosition.captureGroup(x, y);\r\n          }\r\n\r\n          //Invalid move\r\n          else {\r\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Check history for repeating moves\r\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\r\n      }\r\n\r\n      //Set proper turn\r\n      newPosition.setTurn(-color);\r\n\r\n      //Move is valid\r\n      return newPosition;\r\n    };\r\n\r\n    /**\r\n     * Check if a stone (setup) placement is valid.\r\n     */\r\n    Game.prototype.validatePlacement = function(x, y, color, position) {\r\n\r\n      //Check coordinates validity\r\n      if (!this.isOnBoard(x, y)) {\r\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\r\n      }\r\n\r\n      //Place the stone\r\n      position.stones.set(x, y, color);\r\n\r\n      //Empty spot? Don't need to check for captures\r\n      if (color === StoneColor.EMPTY) {\r\n        return;\r\n      }\r\n\r\n      //Capture adjacent stones if possible\r\n      var captures = position.captureAdjacent(x, y);\r\n\r\n      //No captures occurred? Check if the move we're making is a suicide move\r\n      if (!captures) {\r\n\r\n        //No liberties for the group we've just created? Capture it\r\n        if (!position.hasLiberties(x, y)) {\r\n          position.captureGroup(x, y);\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Stone and markup handling\r\n     ***/\r\n\r\n    /**\r\n     * Add a stone\r\n     */\r\n    Game.prototype.addStone = function(x, y, color) {\r\n\r\n      //Check if there's anything to do at all\r\n      if (this.position.stones.is(x, y, color)) {\r\n        return;\r\n      }\r\n\r\n      //Create temporary position\r\n      var tempPosition = this.position.clone();\r\n\r\n      //Validate placement on temp position\r\n      this.validatePlacement(x, y, color, tempPosition);\r\n\r\n      //No setup instructions container in this node?\r\n      if (typeof this.node.setup === 'undefined') {\r\n\r\n        //Is this a move node?\r\n        if (this.node.isMove()) {\r\n\r\n          //Clone our position\r\n          pushPosition.call(this);\r\n\r\n          //Create new node\r\n          var node = new GameNode();\r\n\r\n          //Append it to the current node and change the pointer\r\n          var i = node.appendTo(this.node);\r\n          this.node = node;\r\n\r\n          //Advance path to the added node index\r\n          this.path.advance(i);\r\n        }\r\n\r\n        //Create setup container in this node\r\n        this.node.setup = [];\r\n      }\r\n\r\n      //Replace current position\r\n      replacePosition.call(this, tempPosition);\r\n\r\n      //Add setup instructions to node\r\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\r\n    };\r\n\r\n    /**\r\n     * Add markup\r\n     */\r\n    Game.prototype.addMarkup = function(x, y, markup) {\r\n\r\n      //No markup instructions container in this node?\r\n      if (typeof this.node.markup === 'undefined') {\r\n        this.node.markup = [];\r\n      }\r\n\r\n      //Add markup to game position\r\n      this.position.markup.set(x, y, markup);\r\n\r\n      //Add markup instructions to node\r\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\r\n    };\r\n\r\n    /**\r\n     * Remove a stone\r\n     */\r\n    Game.prototype.removeStone = function(x, y) {\r\n\r\n      //Check if the stone is found in setup instructions\r\n      var foundInSetup = false;\r\n\r\n      //Remove from node setup instruction\r\n      if (typeof this.node.setup !== 'undefined') {\r\n        for (var i = 0; i < this.node.setup.length; i++) {\r\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\r\n\r\n            //Remove from node and unset in position\r\n            this.node.setup.splice(i, 1);\r\n            this.position.stones.unset(x, y);\r\n\r\n            //Mark as found\r\n            foundInSetup = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Not found in setup? Add as no stone color\r\n      if (!foundInSetup) {\r\n        this.addStone(x, y, StoneColor.EMPTY);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Remove markup\r\n     */\r\n    Game.prototype.removeMarkup = function(x, y) {\r\n\r\n      //Remove from node\r\n      if (typeof this.node.markup !== 'undefined') {\r\n        for (var i = 0; i < this.node.markup.length; i++) {\r\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\r\n            this.node.markup.splice(i, 1);\r\n            this.position.markup.unset(x, y);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Check if there is a stone at the given coordinates for the current position\r\n     */\r\n    Game.prototype.hasStone = function(x, y, color) {\r\n      if (typeof color !== 'undefined') {\r\n        return this.position.stones.is(x, y, color);\r\n      }\r\n      return this.position.stones.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Check if there is markup at the given coordinate for the current position\r\n     */\r\n    Game.prototype.hasMarkup = function(x, y, type) {\r\n      if (typeof type !== 'undefined') {\r\n        return this.position.markup.is(x, y, type);\r\n      }\r\n      return this.position.markup.has(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get stone on coordinates\r\n     */\r\n    Game.prototype.getStone = function(x, y) {\r\n      return this.position.stones.get(x, y);\r\n    };\r\n\r\n    /**\r\n     * Get markup on coordinates\r\n     */\r\n    Game.prototype.getMarkup = function(x, y) {\r\n      return this.position.markup.get(x, y);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Move handling\r\n     ***/\r\n\r\n    /**\r\n     * Play move\r\n     */\r\n    Game.prototype.play = function(x, y, color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Validate move and get new position\r\n      var newPosition = this.validateMove(x, y, color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          x: x,\r\n          y: y,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n\r\n      //Valid move\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Play pass\r\n     */\r\n    Game.prototype.pass = function(color) {\r\n\r\n      //Color defaults to current turn\r\n      color = color || this.position.getTurn();\r\n\r\n      //Initialize new position and switch the turn\r\n      var newPosition = this.position.clone();\r\n      newPosition.setTurn(-color);\r\n\r\n      //Push new position\r\n      pushPosition.call(this, newPosition);\r\n\r\n      //Create new move node\r\n      var node = new GameNode({\r\n        move: {\r\n          pass: true,\r\n          color: color\r\n        }\r\n      });\r\n\r\n      //Append it to the current node, remember the path, and change the pointer\r\n      var i = node.appendTo(this.node);\r\n      this.node.rememberedPath = i;\r\n      this.node = node;\r\n\r\n      //Advance path to the added node index\r\n      this.path.advance(i);\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * Game tree navigation\r\n     ***/\r\n\r\n    /**\r\n     * Go to the next position\r\n     */\r\n    Game.prototype.next = function(i) {\r\n\r\n      //Object (node) given as parameter? Find index\r\n      if (typeof i === 'object') {\r\n        i = this.node.children.indexOf(i);\r\n      }\r\n\r\n      //Go to the next node\r\n      if (nextNode.call(this, i)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n          return true;\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n\r\n      //Didn't go to next position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the previous position\r\n     */\r\n    Game.prototype.previous = function() {\r\n\r\n      //Go to the previous node\r\n      if (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        return true;\r\n      }\r\n\r\n      //Didn't go to previous position\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * Go to the last position\r\n     */\r\n    Game.prototype.last = function() {\r\n\r\n      //Keep going to the next node until we reach the end\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the first position\r\n     */\r\n    Game.prototype.first = function() {\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      executeNode.call(this);\r\n    };\r\n\r\n    /**\r\n     * Go to position specified by a path object, a numeric move numer, or a node name string\r\n     */\r\n    Game.prototype.goto = function(target) {\r\n\r\n      //Must have a tree\r\n      if (this.root === null) {\r\n        return;\r\n      }\r\n\r\n      //Nothing given?\r\n      if (typeof target === 'undefined') {\r\n        return;\r\n      }\r\n\r\n      //Function given? Call now\r\n      if (typeof target === 'function') {\r\n        target = target.call(this);\r\n      }\r\n\r\n      //Initialize path\r\n      var path;\r\n\r\n      //Simple move number? Convert to path object\r\n      if (typeof target === 'number') {\r\n        path = this.path.clone();\r\n        path.setMove(target);\r\n      }\r\n\r\n      //String? Named node\r\n      else if (typeof target === 'string') {\r\n\r\n        //Already here?\r\n        if (this.node.name === target) {\r\n          return;\r\n        }\r\n\r\n        //Find path to node\r\n        path = this.getPathToNode(target);\r\n        if (path === null) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Otherwise assume path object\r\n      else {\r\n        path = target;\r\n      }\r\n\r\n      //Already here?\r\n      if (this.path.compare(path)) {\r\n        return;\r\n      }\r\n\r\n      //Go to the first node\r\n      firstNode.call(this);\r\n\r\n      //Create the initial position, clone it and parse the current node\r\n      initializeHistory.call(this);\r\n      pushPosition.call(this);\r\n      executeNode.call(this);\r\n\r\n      //Loop path\r\n      var n = path.getMove();\r\n      for (var i = 0; i < n; i++) {\r\n\r\n        //Try going to the next node\r\n        if (!nextNode.call(this, path.nodeAt(i))) {\r\n          break;\r\n        }\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next fork\r\n     */\r\n    Game.prototype.nextFork = function() {\r\n\r\n      //Keep going to the next node until we reach one with multiple children\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Have multiple children?\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous fork\r\n     */\r\n    Game.prototype.previousFork = function() {\r\n\r\n      //Loop until we find a node with more than one child\r\n      while (previousNode.call(this)) {\r\n        popPosition.call(this);\r\n        if (this.node.children.length > 1) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the next move with comments\r\n     */\r\n    Game.prototype.nextComment = function() {\r\n\r\n      //Keep going to the next node until we find one with comments\r\n      while (nextNode.call(this)) {\r\n\r\n        //If an invalid move is detected, we can't go on\r\n        try {\r\n          executeNode.call(this);\r\n        }\r\n        catch (error) {\r\n          previousNode.call(this);\r\n          throw error;\r\n        }\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Go to the previous move with comments\r\n     */\r\n    Game.prototype.previousComment = function() {\r\n\r\n      //Go back until we find a node with comments\r\n      while (previousNode.call(this)) {\r\n\r\n        //Pop the position\r\n        popPosition.call(this);\r\n\r\n        //Comments found?\r\n        if (this.node.hasComments()) {\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    /*****************************************************************************\r\n     * State handling\r\n     ***/\r\n\r\n    /**\r\n     * Get the board state\r\n     */\r\n    Game.prototype.getState = function() {\r\n\r\n      //Can only create when we have a JGF and path\r\n      if (!this.jgf || !this.path) {\r\n        return null;\r\n      }\r\n\r\n      //Create state\r\n      var state = {\r\n        jgf: this.jgf,\r\n        path: this.path.clone()\r\n      };\r\n\r\n      //Return\r\n      return state;\r\n    };\r\n\r\n    /**\r\n     * Restore the game state\r\n     */\r\n    Game.prototype.restoreState = function(state) {\r\n\r\n      //Must have jgf and path\r\n      if (!state || !state.jgf || !state.path) {\r\n        return;\r\n      }\r\n\r\n      //Restore state\r\n      this.load(state.jgf);\r\n      this.goto(state.path);\r\n    };\r\n\r\n    //Return object\r\n    return Game;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameNode :: This class represents a single node in the game moves tree. It contains\r\n * properties like the x and y grid coordinates, the move played, board setup instructions,\r\n * markup, player turn and comments. The moves tree in the game record is represented by a\r\n * string of GameNodes, each with pointers to their parent and children. Each node can have\r\n * multiple children (move variations), but only one parent.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Node.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameNode', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /**\r\n   * Helper to construct a coordinates base object\r\n   */\r\n  function coordinatesObject(coords, baseObject) {\r\n    baseObject = baseObject || {};\r\n    if (coords === '' || coords === 'pass') {\r\n      baseObject.pass = true;\r\n    }\r\n    else {\r\n\r\n      //Backwards compatibility with SGF string coordinates in JGF\r\n      if (typeof coords === 'string') {\r\n        coords = convertCoordinates(coords);\r\n      }\r\n\r\n      //Append coordinates\r\n      baseObject.x = coords[0] * 1;\r\n      baseObject.y = coords[1] * 1;\r\n    }\r\n    return baseObject;\r\n  }\r\n\r\n  /**\r\n   * Convert a numeric color value (color constant) to a string\r\n   */\r\n  function toStringColor(color) {\r\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\r\n  }\r\n\r\n  /**\r\n   * Convert a string color value to a numeric color constant\r\n   */\r\n  function toColorConstant(color) {\r\n    if (color === 'B') {\r\n      return StoneColor.B;\r\n    }\r\n    else if (color === 'W') {\r\n      return StoneColor.W;\r\n    }\r\n    return StoneColor.E;\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Helpers for conversion between JGF / KIFU format\r\n   ***/\r\n\r\n  /**\r\n   * Convert move object to JGF format\r\n   */\r\n  function convertMoveToJgf(move) {\r\n\r\n    //Initialize JGF move object and determine color\r\n    var jgfMove = angular.copy(move);\r\n    var color = toStringColor(move.color);\r\n\r\n    //No color?\r\n    if (color === '') {\r\n      return null;\r\n    }\r\n\r\n    //Pass move?\r\n    if (move.pass === true) {\r\n      jgfMove[color] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      jgfMove[color] = [move.x, move.y];\r\n    }\r\n\r\n    //Delete coordinates and color\r\n    delete jgfMove.x;\r\n    delete jgfMove.y;\r\n    delete jgfMove.color;\r\n\r\n    //Return move\r\n    return jgfMove;\r\n  }\r\n\r\n  /**\r\n   * Convert move from JGF format\r\n   */\r\n  function convertMoveFromJgf(move) {\r\n\r\n    //Prepare color, coordinates\r\n    var color, coords;\r\n\r\n    //Check whose move it was\r\n    if (move.W) {\r\n      color = 'W';\r\n      coords = move.W;\r\n    }\r\n    else if (move.B) {\r\n      color = 'B';\r\n      coords = move.B;\r\n    }\r\n\r\n    //No coordinates?\r\n    if (!coords) {\r\n      return null;\r\n    }\r\n\r\n    //Return coordinates object\r\n    return coordinatesObject(coords, {\r\n      color: toColorConstant(color)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Convert setup object to JGF format\r\n   */\r\n  function convertSetupToJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var i, color;\r\n    var jgfSetup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in setup) {\r\n      if (setup.hasOwnProperty(i)) {\r\n\r\n        //Get color\r\n        color = toStringColor(setup[i].color) || 'E';\r\n\r\n        //Initialize array\r\n        if (typeof jgfSetup[color] === 'undefined') {\r\n          jgfSetup[color] = [];\r\n        }\r\n\r\n        //Add coordinates\r\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert setup from JGF format\r\n   */\r\n  function convertSetupFromJgf(setup) {\r\n\r\n    //Initialize variables\r\n    var c, key, color;\r\n    var gameSetup = [];\r\n\r\n    //Loop setup\r\n    for (key in setup) {\r\n      if (setup.hasOwnProperty(key)) {\r\n\r\n        //Get color constant\r\n        color = toColorConstant(key);\r\n\r\n        //Loop coordinates\r\n        for (c in setup[key]) {\r\n          if (setup[key].hasOwnProperty(c)) {\r\n            gameSetup.push(coordinatesObject(setup[key][c], {\r\n              color: color\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameSetup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup object to JGF format\r\n   */\r\n  function convertMarkupToJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var i, type;\r\n    var jgfMarkup = {};\r\n\r\n    //Loop setup objects\r\n    for (i in markup) {\r\n      if (markup.hasOwnProperty(i)) {\r\n\r\n        //Get type\r\n        type = markup[i].type;\r\n\r\n        //Initialize array\r\n        if (typeof jgfMarkup[type] === 'undefined') {\r\n          jgfMarkup[type] = [];\r\n        }\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\r\n        }\r\n        else {\r\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return jgfMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert markup from JGF format\r\n   */\r\n  function convertMarkupFromJgf(markup) {\r\n\r\n    //Initialize variables\r\n    var l, type;\r\n    var gameMarkup = [];\r\n\r\n    //Loop markup types\r\n    for (type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n\r\n        //Label?\r\n        if (type === 'label') {\r\n          for (l = 0; l < markup[type].length; l++) {\r\n\r\n            //Validate\r\n            if (!angular.isArray(markup[type][l])) {\r\n              continue;\r\n            }\r\n\r\n            //SGF type coordinates?\r\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\r\n              var text = markup[type][l][1];\r\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\r\n              markup[type][l].push(text);\r\n            }\r\n\r\n            //Validate length\r\n            if (markup[type][l].length < 3) {\r\n              continue;\r\n            }\r\n\r\n            //Add to stack\r\n            gameMarkup.push(coordinatesObject(markup[type][l], {\r\n              type: type,\r\n              text: markup[type][l][2]\r\n            }));\r\n          }\r\n        }\r\n        else {\r\n\r\n          //Loop coordinates\r\n          for (l in markup[type]) {\r\n            if (markup[type].hasOwnProperty(l)) {\r\n              gameMarkup.push(coordinatesObject(markup[type][l], {\r\n                type: type\r\n              }));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return gameMarkup;\r\n  }\r\n\r\n  /**\r\n   * Convert turn object to JGF format\r\n   */\r\n  function convertTurnToJgf(turn) {\r\n    switch (turn) {\r\n      case StoneColor.W:\r\n        return 'W';\r\n      case StoneColor.B:\r\n        return 'B';\r\n      default:\r\n        return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert turn from JGF format\r\n   */\r\n  function convertTurnFromJgf(turn) {\r\n    switch (turn) {\r\n      case 'W':\r\n        return StoneColor.W;\r\n      case 'B':\r\n        return StoneColor.B;\r\n      default:\r\n        return StoneColor.EMPTY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Conversions map\r\n   */\r\n  var conversionMap = {\r\n    toJgf: {\r\n      move: convertMoveToJgf,\r\n      setup: convertSetupToJgf,\r\n      markup: convertMarkupToJgf,\r\n      turn: convertTurnToJgf\r\n    },\r\n    fromJgf: {\r\n      move: convertMoveFromJgf,\r\n      setup: convertSetupFromJgf,\r\n      markup: convertMarkupFromJgf,\r\n      turn: convertTurnFromJgf\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameNode(properties, parent) {\r\n\r\n    //Set parent and children\r\n    this.parent = parent || null;\r\n    this.children = [];\r\n\r\n    //Save properties\r\n    if (properties) {\r\n      for (var key in properties) {\r\n        if (properties.hasOwnProperty(key)) {\r\n          this[key] = properties[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get node's child specified by index or null if doesn't exist\r\n   */\r\n  GameNode.prototype.getChild = function(i) {\r\n    i = i || 0;\r\n    if (this.children[i]) {\r\n      return this.children[i];\r\n    }\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Get all the children\r\n   */\r\n  GameNode.prototype.getChildren = function() {\r\n    return this.children;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has any chilren\r\n   */\r\n  GameNode.prototype.hasChildren = function() {\r\n    return (this.children.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Get parent node\r\n   */\r\n  GameNode.prototype.getParent = function() {\r\n    return this.parent;\r\n  };\r\n\r\n  /**\r\n   * Check if the node has more than one move variation\r\n   */\r\n  GameNode.prototype.hasMoveVariations = function() {\r\n\r\n    //Less than two child nodes?\r\n    if (this.children.length <= 1) {\r\n      return false;\r\n    }\r\n\r\n    //Loop children\r\n    var moveVariations = 0;\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations++;\r\n      }\r\n\r\n      //More than one move node present?\r\n      if (moveVariations > 1) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //No move variations\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Get all the move variation nodes\r\n   */\r\n  GameNode.prototype.getMoveVariations = function() {\r\n\r\n    //No child nodes?\r\n    if (this.children.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize\r\n    var moveVariations = [];\r\n\r\n    //Loop child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n\r\n      //Is this a move node?\r\n      if (this.children[i].isMove()) {\r\n        moveVariations.push(this.children[i]);\r\n      }\r\n    }\r\n\r\n    //Return\r\n    return moveVariations;\r\n  };\r\n\r\n  /**\r\n   * Get the move variation for given coordinates\r\n   */\r\n  GameNode.prototype.getMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return -1;\r\n  };\r\n\r\n  /**\r\n   * Check if given coordinates are one of the next child node coordinates\r\n   */\r\n  GameNode.prototype.isMoveVariation = function(x, y) {\r\n\r\n    //Loop the child nodes\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if we have comments\r\n   */\r\n  GameNode.prototype.hasComments = function() {\r\n    return (this.comments && this.comments.length > 0);\r\n  };\r\n\r\n  /**\r\n   * Check if this is a move node\r\n   */\r\n  GameNode.prototype.isMove = function() {\r\n    return !!this.move;\r\n  };\r\n\r\n  /**\r\n   * Get move number\r\n   */\r\n  GameNode.prototype.getMoveNumber = function() {\r\n\r\n    //Move node?\r\n    if (this.isMove()) {\r\n      if (this.parent) {\r\n        return this.parent.getMoveNumber() + 1;\r\n      }\r\n      return 1;\r\n    }\r\n\r\n    //Use parent move number if we have one\r\n    if (this.parent) {\r\n      return this.parent.getMoveNumber();\r\n    }\r\n\r\n    //No parent\r\n    return 0;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Node manipulation\r\n   ***/\r\n\r\n  /**\r\n   * Remove this node from its parent\r\n   */\r\n  GameNode.prototype.remove = function() {\r\n\r\n    //Can't remove if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found remove it\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1) {\r\n      this.parent.children.splice(i, 1);\r\n    }\r\n\r\n    //Clear parent reference\r\n    this.parent = null;\r\n  };\r\n\r\n  /**\r\n   * Move the node up in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveUp = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i > 0) {\r\n      var temp = this.parent.children[i - 1];\r\n      this.parent.children[i - 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Move the node down in the parent's child tree\r\n   */\r\n  GameNode.prototype.moveDown = function() {\r\n\r\n    //Can't move if no parent\r\n    if (!this.parent) {\r\n      return;\r\n    }\r\n\r\n    //Find the index of this node, and if found swap the nodes from position\r\n    var i = this.parent.children.indexOf(this);\r\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\r\n      var temp = this.parent.children[i + 1];\r\n      this.parent.children[i + 1] = this;\r\n      this.parent.children[i] = temp;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Append this node to another node\r\n   */\r\n  GameNode.prototype.appendTo = function(node) {\r\n\r\n    //Remove from existing parent\r\n    this.remove();\r\n\r\n    //Set new parent\r\n    this.parent = node;\r\n    node.children.push(this);\r\n    return node.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Append child node to this node.\r\n   */\r\n  GameNode.prototype.appendChild = function(node) {\r\n    node.parent = this;\r\n    this.children.push(node);\r\n    return this.children.length - 1;\r\n  };\r\n\r\n  /**\r\n   * Insert another node after this one\r\n   */\r\n  GameNode.prototype.insertNode = function(node) {\r\n\r\n    //Loop our children and change parent node\r\n    for (var i = 0; i < this.children.length; i++) {\r\n      this.children[i].parent = node;\r\n    }\r\n\r\n    //Merge children, set this node as the parent of given node\r\n    node.children = node.children.concat(this.children);\r\n    node.parent = this;\r\n\r\n    //Set given node as the child of this node\r\n    this.children = [node];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * JGF conversion\r\n   ***/\r\n\r\n  /**\r\n   * Build a Game Node from a given JGF tree\r\n   */\r\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\r\n\r\n    //Root JGF file given?\r\n    if (typeof jgf.tree !== 'undefined') {\r\n      return GameNode.fromJgf(jgf.tree, gameNode);\r\n    }\r\n\r\n    //Initialize helper vars\r\n    var variationNode, nextNode, i, j;\r\n\r\n    //Node to work with given? Otherwise, work with ourselves\r\n    gameNode = gameNode || this;\r\n\r\n    //Loop moves in the JGF tree\r\n    for (i = 0; i < jgf.length; i++) {\r\n\r\n      //Array? That means a variation branch\r\n      if (angular.isArray(jgf[i])) {\r\n\r\n        //Loop variation stacks\r\n        for (j = 0; j < jgf[i].length; j++) {\r\n\r\n          //Build the variation node\r\n          variationNode = new GameNode();\r\n          variationNode.fromJgf(jgf[i][j]);\r\n\r\n          //Append to working node\r\n          gameNode.appendChild(variationNode);\r\n        }\r\n      }\r\n\r\n      //Regular node\r\n      else {\r\n\r\n        //Get properties to copy\r\n        var properties = Object.getOwnPropertyNames(jgf[i]);\r\n\r\n        //Copy node properties\r\n        for (var key in properties) {\r\n          if (properties.hasOwnProperty(key)) {\r\n            var prop = properties[key];\r\n\r\n            //Conversion function present?\r\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\r\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\r\n            }\r\n            else if (typeof jgf[i][prop] === 'object') {\r\n              gameNode[prop] = angular.copy(jgf[i][prop]);\r\n            }\r\n            else {\r\n              gameNode[prop] = jgf[i][prop];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      //Next element is a regular node? Prepare new working node\r\n      //Otherwise, if there are no more nodes or if the next element is\r\n      //an array (e.g. variations), we keep our working node as the current one\r\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\r\n        nextNode = new GameNode();\r\n        gameNode.appendChild(nextNode);\r\n        gameNode = nextNode;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Convert this node to a JGF node container\r\n   */\r\n  GameNode.prototype.toJgf = function(container) {\r\n\r\n    //Initialize container to add nodes to\r\n    container = container || [];\r\n\r\n    //Initialize node and get properties\r\n    var node = {};\r\n    var properties = Object.getOwnPropertyNames(this);\r\n\r\n    //Copy node properties\r\n    for (var key in properties) {\r\n      if (properties.hasOwnProperty(key)) {\r\n        var prop = properties[key];\r\n\r\n        //Skip some properties\r\n        if (prop === 'parent' || prop === 'children') {\r\n          continue;\r\n        }\r\n\r\n        //Conversion function present?\r\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\r\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\r\n        }\r\n        else if (typeof this[prop] === 'object') {\r\n          node[prop] = angular.copy(this[prop]);\r\n        }\r\n        else {\r\n          node[prop] = this[prop];\r\n        }\r\n      }\r\n    }\r\n\r\n    //Add node to container\r\n    container.push(node);\r\n\r\n    //Variations present?\r\n    if (this.children.length > 1) {\r\n\r\n      //Create variations container\r\n      var variationsContainer = [];\r\n      container.push(variationsContainer);\r\n\r\n      //Loop child (variation) nodes\r\n      for (var i = 0; i < this.children.length; i++) {\r\n\r\n        //Create container for this variation\r\n        var variationContainer = [];\r\n        variationsContainer.push(variationContainer);\r\n\r\n        //Call child node converter\r\n        this.children[i].toJgf(variationContainer);\r\n      }\r\n    }\r\n\r\n    //Just one child?\r\n    else if (this.children.length === 1) {\r\n      this.children[0].toJgf(container);\r\n    }\r\n\r\n    //Return container\r\n    return container;\r\n  };\r\n\r\n  //Return object\r\n  return GameNode;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePath :: A simple class that keeps track of a path taken in a game.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Path.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePath', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePath() {\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Reset\r\n   */\r\n  GamePath.prototype.reset = function() {\r\n    this.move = 0;\r\n    this.path = {};\r\n    this.branches = 0;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Advance a move\r\n   */\r\n  GamePath.prototype.advance = function(i) {\r\n\r\n    //Different child variation chosen? Remember\r\n    if (i > 0) {\r\n      this.branches++;\r\n    }\r\n    this.path[this.move] = i;\r\n\r\n    //Increment move\r\n    this.move++;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Retreat a move\r\n   */\r\n  GamePath.prototype.retreat = function() {\r\n\r\n    //At start?\r\n    if (this.move === 0) {\r\n      return;\r\n    }\r\n\r\n    //Decrement move\r\n    this.move--;\r\n\r\n    //Delete path choice\r\n    if (this.path[this.move]) {\r\n      delete this.path[this.move];\r\n      this.branches--;\r\n    }\r\n\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Go to a specific move number\r\n   */\r\n  GamePath.prototype.setMove = function(no) {\r\n\r\n    //Less than our current move? We need to erase any paths above the move number\r\n    if (no < this.move) {\r\n      for (var i in this.path) {\r\n        if (i > no) {\r\n          delete this.path[i];\r\n          this.branches--;\r\n        }\r\n      }\r\n    }\r\n\r\n    //Set move number\r\n    this.move = no;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the move number\r\n   */\r\n  GamePath.prototype.getMove = function() {\r\n    return this.move;\r\n  };\r\n\r\n  /**\r\n   * Get the node choice at a specific move number\r\n   */\r\n  GamePath.prototype.nodeAt = function(no) {\r\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\r\n  };\r\n\r\n  /**\r\n   * Compare to another path\r\n   */\r\n  GamePath.prototype.compare = function(otherPath) {\r\n\r\n    //Invalid object?\r\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    //Different move number or path length?\r\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\r\n      return false;\r\n    }\r\n\r\n    //Check path\r\n    for (var i in this.path) {\r\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    //Same path!\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Clone\r\n   */\r\n  GamePath.prototype.clone = function() {\r\n\r\n    //Create new instance\r\n    var newPath = new GamePath();\r\n\r\n    //Set vars\r\n    newPath.move = this.move;\r\n    newPath.branches = this.branches;\r\n    newPath.path = angular.copy(this.path);\r\n\r\n    //Return\r\n    return newPath;\r\n  };\r\n\r\n  /**\r\n   * Helper to find node name recursively\r\n   */\r\n  function findNodeName(node, nodeName, path) {\r\n\r\n    //Found in this node?\r\n    if (node.name && node.name === nodeName) {\r\n      return true;\r\n    }\r\n\r\n    //Loop children\r\n    for (var i = 0; i < node.children.length; i++) {\r\n\r\n      //Advance path\r\n      path.advance(i);\r\n\r\n      //Found in child node?\r\n      if (findNodeName(node.children[i], nodeName, path)) {\r\n        return true;\r\n      }\r\n\r\n      //Not found in this child node, retreat path\r\n      path.retreat();\r\n    }\r\n\r\n    //Not found\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Static helper to create a path object to reach a certain node\r\n   */\r\n  GamePath.findNode = function(nodeName, rootNode) {\r\n\r\n    //Create new instance\r\n    var path = new GamePath();\r\n\r\n    //Find the node name\r\n    if (findNodeName(rootNode, nodeName, path)) {\r\n      return path;\r\n    }\r\n\r\n    //Not found\r\n    return null;\r\n  };\r\n\r\n  //Return\r\n  return GamePath;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\r\n * markup on the board in this position, as well as any captures that were made and which player's\r\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\r\n * compare changes to other positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Position.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GamePosition(width, height) {\r\n\r\n    //Initialize\r\n    this.error = 0;\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.stones = new BoardGrid();\r\n    this.markup = new BoardGrid();\r\n    this.turn = StoneColor.B;\r\n\r\n    //Initialize captures\r\n    this.captures = {};\r\n    this.captures[StoneColor.B] = [];\r\n    this.captures[StoneColor.W] = [];\r\n\r\n    //Set empty value for stones grid\r\n    this.stones.whenEmpty(StoneColor.EMPTY);\r\n\r\n    //Set size\r\n    if (width || height) {\r\n      this.setSize(width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the grid size\r\n   */\r\n  GamePosition.prototype.setSize = function(width, height) {\r\n\r\n    //Check what's given\r\n    width = width || height || 0;\r\n    height = height || width || 0;\r\n\r\n    //Set\r\n    this.width = parseInt(width);\r\n    this.height = parseInt(height);\r\n\r\n    //Set in grids\r\n    this.stones.setSize(width, height);\r\n    this.markup.setSize(width, height);\r\n\r\n    //Empty the position\r\n    this.empty();\r\n  };\r\n\r\n  /**\r\n   * Clear the whole position\r\n   */\r\n  GamePosition.prototype.empty = function() {\r\n    this.stones.empty();\r\n    this.markup.empty();\r\n  };\r\n\r\n  /**\r\n   * Sets stone color at given coordinates.\r\n   */\r\n  GamePosition.prototype.setStone = function(x, y, color) {\r\n    this.stones.set(x, y, color);\r\n  };\r\n\r\n  /**\r\n   * Sets markup type at given coordinates.\r\n   */\r\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\r\n    this.markup.set(x, y, markup);\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Liberties and capturing\r\n   ***/\r\n\r\n  /**\r\n   * Check if a group of given color has liberties, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\r\n\r\n    //Out of bounds? No liberties outside of the board\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Initialize tested grid if needed\r\n    tested = tested || new BoardGrid(this.width, this.height);\r\n\r\n    //See what color is present on the coordinates\r\n    var color = this.stones.get(x, y);\r\n\r\n    //If no group color was given, use what's on the position\r\n    groupColor = groupColor || color;\r\n\r\n    //Already tested, or enemy stone? Not giving any liberties\r\n    if (tested.get(x, y) === true || color === -groupColor) {\r\n      return false;\r\n    }\r\n\r\n    //Empty? That's a liberty\r\n    if (color === StoneColor.EMPTY) {\r\n      return true;\r\n    }\r\n\r\n    //Mark this position as tested now\r\n    tested.set(x, y, true);\r\n\r\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\r\n    //If we get at least one true, we have a liberty\r\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\r\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\r\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\r\n        this.hasLiberties(x + 1, y, groupColor, tested);\r\n  };\r\n\r\n  /**\r\n   * Helper to capture adjacent groups\r\n   */\r\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    friendlyColor = friendlyColor || this.stones.get(x, y);\r\n\r\n    //Can't capture empty spots\r\n    if (friendlyColor === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Flag to see if we captured stuff\r\n    var captured = false;\r\n\r\n    //Check adjacent positions now, capturing stones in the process if possible\r\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\r\n      captured = true;\r\n    }\r\n\r\n    //Return\r\n    return captured;\r\n  };\r\n\r\n  /**\r\n   * Helper if we can capture a certain group\r\n   */\r\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\r\n\r\n    //Out of bounds? Nothing to capture\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //Empty spot? Can't capture\r\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\r\n      return false;\r\n    }\r\n\r\n    //Use color of stone present if none given\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //We need to have a stone of matching group color in order to be able to capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //There is a capturable stone, let's see if it has any liberties left\r\n    if (this.hasLiberties(x, y, enemyColor)) {\r\n      return false;\r\n    }\r\n\r\n    //No liberties left, the group is capturable. Capture if we want to\r\n    if (doCapture) {\r\n      this.captureGroup(x, y, enemyColor);\r\n    }\r\n\r\n    //Capturable\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a group of certain color, starting at the given coordinates\r\n   */\r\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    //If no group color was given, use what's on the position\r\n    enemyColor = enemyColor || this.stones.get(x, y);\r\n\r\n    //Stone at position does not match the given group color? Can't capture it\r\n    if (this.stones.get(x, y) !== enemyColor) {\r\n      return false;\r\n    }\r\n\r\n    //Capture the stone\r\n    this.captureStone(x, y);\r\n\r\n    //Capture the rest of the group\r\n    this.captureGroup(x, y - 1, enemyColor);\r\n    this.captureGroup(x, y + 1, enemyColor);\r\n    this.captureGroup(x - 1, y, enemyColor);\r\n    this.captureGroup(x + 1, y, enemyColor);\r\n\r\n    //At least one stone was captured\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Capture a stone at given coordinates\r\n   */\r\n  GamePosition.prototype.captureStone = function(x, y) {\r\n\r\n    //Validate boundaries\r\n    if (!this.stones.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get color\r\n    var color = this.stones.get(x, y);\r\n\r\n    //Empty?\r\n    if (color === StoneColor.EMPTY) {\r\n      return;\r\n    }\r\n\r\n    //Ok, stone present, capture it\r\n    this.stones.set(x, y, StoneColor.EMPTY);\r\n    this.captures[color].push({x: x, y: y});\r\n  };\r\n\r\n  /**\r\n   * Set captures for a color (expects array with capture object coordinates)\r\n   */\r\n  GamePosition.prototype.setCaptures = function(color, captures) {\r\n    this.captures[color] = captures;\r\n  };\r\n\r\n  /**\r\n   * Get captures for a color\r\n   */\r\n  GamePosition.prototype.getCaptures = function(color) {\r\n    return this.captures[color] || [];\r\n  };\r\n\r\n  /**\r\n   * Get the capture count for a color (= the number of captures of the opposing color)\r\n   */\r\n  GamePosition.prototype.getCaptureCount = function(color) {\r\n    return this.captures[-color].length;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Turn control\r\n   ***/\r\n\r\n  /**\r\n   * Set color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.setTurn = function(color) {\r\n    this.turn = color;\r\n  };\r\n\r\n  /**\r\n   * Get color for whose move it is at this position\r\n   */\r\n  GamePosition.prototype.getTurn = function() {\r\n    return this.turn;\r\n  };\r\n\r\n  /**\r\n   * Switch the player turn on this position\r\n   */\r\n  GamePosition.prototype.switchTurn = function() {\r\n    this.turn = -this.turn;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Cloning and comparison\r\n   ***/\r\n\r\n  /**\r\n   * Clones the whole position except turn and captures\r\n   */\r\n  GamePosition.prototype.clone = function() {\r\n\r\n    //Create a new position\r\n    var newPosition = new GamePosition();\r\n\r\n    //Set vars manually for maximum efficiency\r\n    newPosition.turn = this.turn;\r\n    newPosition.width = this.width;\r\n    newPosition.height = this.height;\r\n    newPosition.stones = this.stones.clone();\r\n    newPosition.markup = new BoardGrid(this.width, this.height);\r\n\r\n    //Return\r\n    return newPosition;\r\n  };\r\n\r\n  /**\r\n   * Checks if a given position is the same as the current position\r\n   */\r\n  GamePosition.prototype.isSameAs = function(newPosition) {\r\n\r\n    //Must have the same size\r\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\r\n      return false;\r\n    }\r\n\r\n    //Compare the grids\r\n    return this.stones.isSameAs(newPosition.stones);\r\n  };\r\n\r\n  //Return\r\n  return GamePosition;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScore :: A simple class that contains a game score\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Score.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScore', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Helper to calculate the total points\r\n   */\r\n  function calcTotal() {\r\n    return parseInt(this.stones) + parseInt(this.territory) +\r\n      parseInt(this.captures) + parseInt(this.komi);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GameScore() {\r\n\r\n    //Get self\r\n    var self = this;\r\n\r\n    //Setup score containers\r\n    this.black = {};\r\n    this.white = {};\r\n\r\n    //Initialize\r\n    this.reset();\r\n\r\n    //Add total handlers\r\n    this.black.total = function() {\r\n      return calcTotal.call(self.black);\r\n    };\r\n    this.white.total = function() {\r\n      return calcTotal.call(self.white);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset the game score\r\n   */\r\n  GameScore.prototype.reset = function() {\r\n\r\n    //Get properties to loop\r\n    var props = ['stones', 'territory', 'captures', 'komi'];\r\n\r\n    //Score for black player\r\n    for (var i = 0; i < props.length; i++) {\r\n      this.black[props[i]] = 0;\r\n      this.white[props[i]] = 0;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the winner\r\n   */\r\n  GameScore.prototype.winner = function() {\r\n\r\n    //Get totals\r\n    var b = this.black.total();\r\n    var w = this.white.total();\r\n\r\n    //Determine winner\r\n    if (w > b) {\r\n      return StoneColor.W;\r\n    }\r\n    else if (b > w) {\r\n      return StoneColor.B;\r\n    }\r\n    return StoneColor.E;\r\n  };\r\n\r\n  //Return\r\n  return GameScore;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GameScorer :: This class is used to determine the score of a certain game position. It also\r\n * provides handling of manual adjustment of dead / living groups.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Game.Scorer.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Score.Service',\r\n  'ngGo.Board.Grid.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\r\n\r\n  /**\r\n   * Possible score states\r\n   */\r\n  var scoreState = {\r\n    UNKNOWN: StoneColor.EMPTY,\r\n    BLACK_STONE: StoneColor.B,\r\n    WHITE_STONE: StoneColor.W,\r\n    BLACK_CANDIDATE: StoneColor.B * 2,\r\n    WHITE_CANDIDATE: StoneColor.W * 2,\r\n    NEUTRAL: StoneColor.B * 3\r\n  };\r\n\r\n  /**\r\n   * Helper to set territory\r\n   */\r\n  function territorySet(x, y, candidateColor, boundaryColor) {\r\n\r\n    //Get color at given position\r\n    var posColor = this.stones.get(x, y);\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //If border reached, or a position which is already this color, or boundary color, can't set\r\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\r\n      return;\r\n    }\r\n\r\n    //Don't turn stones which are already this color into candidates, instead\r\n    //reset their color to what they were\r\n    if (origColor * 2 === candidateColor) {\r\n      this.stones.set(x, y, origColor);\r\n    }\r\n\r\n    //Otherwise, mark as candidate\r\n    else {\r\n      this.stones.set(x, y, candidateColor);\r\n    }\r\n\r\n    //Set adjacent squares\r\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\r\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\r\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\r\n  }\r\n\r\n  /**\r\n   * Helper to reset territory\r\n   */\r\n  function territoryReset(x, y) {\r\n\r\n    //Get original color from this position\r\n    var origColor = this.game.position.stones.get(x, y);\r\n\r\n    //Not on grid, or already this color?\r\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\r\n      return;\r\n    }\r\n\r\n    //Reset the color\r\n    this.stones.set(x, y, origColor);\r\n\r\n    //Set adjacent squares\r\n    territoryReset.call(this, x - 1, y);\r\n    territoryReset.call(this, x, y - 1);\r\n    territoryReset.call(this, x + 1, y);\r\n    territoryReset.call(this, x, y + 1);\r\n  }\r\n\r\n  /**\r\n   * Helper to determine score state\r\n   */\r\n  function determineScoreState() {\r\n\r\n    //Initialize vars\r\n    var change = true;\r\n    var curState, newState, adjacent, b, w, a, x, y;\r\n\r\n    //Loop while there is change\r\n    while (change) {\r\n\r\n      //Set to false\r\n      change = false;\r\n\r\n      //Go through the whole position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get current state at position\r\n          curState = this.stones.get(x, y);\r\n\r\n          //Unknown or candiates?\r\n          if (\r\n            curState === scoreState.UNKNOWN ||\r\n            curState === scoreState.BLACK_CANDIDATE ||\r\n            curState === scoreState.WHITE_CANDIDATE\r\n          ) {\r\n\r\n            //Get state in adjacent positions\r\n            adjacent = [\r\n              this.stones.get(x - 1, y),\r\n              this.stones.get(x, y - 1),\r\n              this.stones.get(x + 1, y),\r\n              this.stones.get(x, y + 1)\r\n            ];\r\n\r\n            //Reset\r\n            b = w = false;\r\n\r\n            //Loop adjacent squares\r\n            for (a = 0; a < 4; a++) {\r\n              if (\r\n                adjacent[a] === scoreState.BLACK_STONE ||\r\n                adjacent[a] === scoreState.BLACK_CANDIDATE\r\n              ) {\r\n                b = true;\r\n              }\r\n              else if (\r\n                adjacent[a] === scoreState.WHITE_STONE ||\r\n                adjacent[a] === scoreState.WHITE_CANDIDATE\r\n              ) {\r\n                w = true;\r\n              }\r\n              else if (adjacent[a] === scoreState.NEUTRAL) {\r\n                b = w = true;\r\n              }\r\n            }\r\n\r\n            //Determine new state\r\n            if (b && w) {\r\n              newState = scoreState.NEUTRAL;\r\n            }\r\n            else if (b) {\r\n              newState = scoreState.BLACK_CANDIDATE;\r\n            }\r\n            else if (w) {\r\n              newState = scoreState.WHITE_CANDIDATE;\r\n            }\r\n            else {\r\n              newState = false;\r\n            }\r\n\r\n            //Change?\r\n            if (newState !== false && newState !== curState) {\r\n              change = true;\r\n              this.stones.set(x, y, newState);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * this.game scorer class\r\n   */\r\n  var GameScorer = {\r\n\r\n    //Game to score\r\n    game: null,\r\n\r\n    //Score\r\n    score: null,\r\n\r\n    //Stones, captures and points grids\r\n    stones: null,\r\n    captures: null,\r\n    points: null,\r\n\r\n    /**\r\n     * Load a game to score\r\n     */\r\n    load: function(game) {\r\n\r\n      //Reset score\r\n      this.score = new GameScore();\r\n\r\n      //Remember\r\n      this.game = game;\r\n\r\n      //Clone position to work with\r\n      this.stones = this.game.position.stones.clone();\r\n\r\n      //Create grids\r\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\r\n    },\r\n\r\n    /**\r\n     * Get the calculated score\r\n     */\r\n    getScore: function() {\r\n      return this.score;\r\n    },\r\n\r\n    /**\r\n     * Get the points grid\r\n     */\r\n    getPoints: function() {\r\n      return this.points;\r\n    },\r\n\r\n    /**\r\n     * Get the captures grid\r\n     */\r\n    getCaptures: function() {\r\n      return this.captures;\r\n    },\r\n\r\n    /**\r\n     * Run score calculation routine\r\n     */\r\n    calculate: function() {\r\n\r\n      //No game?\r\n      if (!this.game) {\r\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\r\n        return;\r\n      }\r\n\r\n      //Empty grids\r\n      this.points.empty();\r\n      this.captures.empty();\r\n\r\n      //Determine score state\r\n      determineScoreState.call(this);\r\n\r\n      //Get komi and captures\r\n      var komi = this.game.get('game.komi');\r\n      var captures = this.game.getCaptureCount();\r\n\r\n      //Reset score\r\n      this.score.reset();\r\n\r\n      //Set captures and komi\r\n      this.score.black.captures = captures[StoneColor.B];\r\n      this.score.white.captures = captures[StoneColor.W];\r\n      this.score.black.komi = komi < 0 ? komi : 0;\r\n      this.score.white.komi = komi > 0 ? komi : 0;\r\n\r\n      //Init helper vars\r\n      var x, y, state, color;\r\n\r\n      //Loop position\r\n      for (x = 0; x < this.stones.width; x++) {\r\n        for (y = 0; y < this.stones.height; y++) {\r\n\r\n          //Get state and color on original position\r\n          state = this.stones.get(x, y);\r\n          color = this.game.position.stones.get(x, y);\r\n\r\n          //Black stone\r\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\r\n            this.score.black.stones++;\r\n            continue;\r\n          }\r\n\r\n          //White stone\r\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\r\n            this.score.white.stones++;\r\n            continue;\r\n          }\r\n\r\n          //Black candidate\r\n          if (state === scoreState.BLACK_CANDIDATE) {\r\n            this.score.black.territory++;\r\n            this.points.set(x, y, StoneColor.B);\r\n\r\n            //White stone underneath?\r\n            if (color === StoneColor.W) {\r\n              this.score.black.captures++;\r\n              this.captures.set(x, y, StoneColor.W);\r\n            }\r\n            continue;\r\n          }\r\n\r\n          //White candidate\r\n          if (state === scoreState.WHITE_CANDIDATE) {\r\n            this.score.white.territory++;\r\n            this.points.set(x, y, StoneColor.W);\r\n\r\n            //Black stone underneath?\r\n            if (color === StoneColor.B) {\r\n              this.score.white.captures++;\r\n              this.captures.set(x, y, StoneColor.B);\r\n            }\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mark stones dead or alive\r\n     */\r\n    mark: function(x, y) {\r\n\r\n      //Get color of original position and state of the count position\r\n      var color = this.game.position.stones.get(x, y);\r\n      var state = this.stones.get(x, y);\r\n\r\n      //White stone\r\n      if (color === StoneColor.W) {\r\n\r\n        //Was white, mark it and any territory it's in as black's\r\n        if (state === scoreState.WHITE_STONE) {\r\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\r\n        }\r\n\r\n        //Was marked as not white, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n\r\n      //Black stone\r\n      else if (color === StoneColor.B) {\r\n\r\n        //Was black, mark it and any territory it's in as white's\r\n        if (state === scoreState.BLACK_STONE) {\r\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\r\n        }\r\n\r\n        //Was marked as not black, reset the territory\r\n        else {\r\n          territoryReset.call(this, x, y);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return GameScorer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Blank.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuBlank', ['ngGo', function(ngGo) {\r\n\r\n  /**\r\n   * Blank JGF\r\n   */\r\n  var blankJgf = {\r\n    record: {\r\n      application: ngGo.name + ' v' + ngGo.version,\r\n      version: 1,\r\n      charset: 'UTF-8'\r\n    },\r\n    game: {\r\n      type: 'go',\r\n      players: [\r\n        {\r\n          color: 'black',\r\n          name: 'Black'\r\n        },\r\n        {\r\n          color: 'white',\r\n          name: 'White'\r\n        }\r\n      ]\r\n    },\r\n    board: {\r\n      width: 19,\r\n      height: 19\r\n    },\r\n    tree: []\r\n  };\r\n\r\n  /**\r\n   * Blank SGF\r\n   */\r\n  var blankSgf = {\r\n    AP: ngGo.name + ':' + ngGo.version,\r\n    CA: 'UTF-8',\r\n    FF: '4',\r\n    GM: '1',\r\n    SZ: '19',\r\n    PB: 'Black',\r\n    PW: 'White'\r\n  };\r\n\r\n  /**\r\n   * Blank JGF/SGF container\r\n   */\r\n  var KifuBlank = {\r\n\r\n    /**\r\n     * Get blank JGF\r\n     */\r\n    jgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankJgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    },\r\n\r\n    /**\r\n     * Get blank SGF\r\n     */\r\n    sgf: function(base) {\r\n\r\n      //Initialize blank\r\n      var blank = angular.copy(blankSgf);\r\n\r\n      //Base given?\r\n      if (base) {\r\n        for (var p in base) {\r\n          if (base.hasOwnProperty(p)) {\r\n            blank[p] = base[p];\r\n          }\r\n        }\r\n      }\r\n\r\n      //Return\r\n      return blank;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuBlank;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\r\n * constants used by the parsers to aid conversion.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parser.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\r\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\r\n])\r\n\r\n/**\r\n * SGF/JGF aliases constant for conversion between the two formats\r\n * Note: not all properties can be translated directly, so some are\r\n * not present here in this constant\r\n */\r\n.constant('sgfAliases', {\r\n\r\n  //Record properties\r\n  'AP': 'record.application',\r\n  'CA': 'record.charset',\r\n  'CP': 'record.copyright',\r\n  'SO': 'record.source',\r\n  'US': 'record.transcriber',\r\n  'AN': 'record.annotator',\r\n\r\n  //Game properties\r\n  'GM': 'game.type',\r\n  'GN': 'game.name',\r\n  'KM': 'game.komi',\r\n  'HA': 'game.handicap',\r\n  'RE': 'game.result',\r\n  'RU': 'game.rules',\r\n  'TM': 'game.time.main',\r\n  'OT': 'game.time.overtime',\r\n  'DT': 'game.dates',\r\n  'PC': 'game.location',\r\n  'EV': 'game.event',\r\n  'RO': 'game.round',\r\n  'ON': 'game.opening',\r\n  'GC': 'game.comment',\r\n\r\n  //Player info properties\r\n  'PB': 'name',\r\n  'PW': 'name',\r\n  'BT': 'team',\r\n  'WT': 'team',\r\n  'BR': 'rank',\r\n  'WR': 'rank',\r\n\r\n  //Node annotation\r\n  'N': 'name',\r\n  'C': 'comments',\r\n  'CR': 'circle',\r\n  'TR': 'triangle',\r\n  'SQ': 'square',\r\n  'MA': 'mark',\r\n  'SL': 'select',\r\n  'LB': 'label'\r\n})\r\n\r\n/**\r\n * SGF game definitions\r\n */\r\n.constant('sgfGames', {\r\n  1: 'go',\r\n  2: 'othello',\r\n  3: 'chess',\r\n  4: 'renju',\r\n  6: 'backgammon',\r\n  7: 'chinese chess',\r\n  8: 'shogi'\r\n})\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\r\n\r\n  /**\r\n   * Parser wrapper class\r\n   */\r\n  var KifuParser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    gib2jgf: function(gib, stringified) {\r\n      return Gib2Jgf.parse(gib, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    sgf2jgf: function(sgf, stringified) {\r\n      return Sgf2Jgf.parse(sgf, stringified);\r\n    },\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    jgf2sgf: function(jgf) {\r\n      return Jgf2Sgf.parse(jgf);\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return KifuParser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Directive', [\r\n  'ngGo.Board.Directive'\r\n])\r\n\r\n/**\r\n * Directive definition\r\n */\r\n.directive('player', ['Player', function(Player) {\r\n  return {\r\n    restrict: 'E',\r\n\r\n    /**\r\n     * Controller\r\n     */\r\n    controller: ['$scope', function($scope) {\r\n\r\n      //Set player in scope\r\n      if (!$scope.Player) {\r\n        $scope.Player = Player;\r\n      }\r\n    }],\r\n\r\n    /**\r\n     * Linking function\r\n     */\r\n    link: function(scope, element, attrs) {\r\n\r\n      //Link the element\r\n      Player.linkElement(element);\r\n\r\n      //Observe mode and tool attributes\r\n      attrs.$observe('mode', function(mode) {\r\n        Player.switchMode(mode);\r\n      });\r\n      attrs.$observe('tool', function(tool) {\r\n        Player.switchTool(tool);\r\n      });\r\n\r\n      //Observe other settings attributes\r\n      attrs.$observe('variationMarkup', function(attr) {\r\n        Player.setVariationMarkup(attr === 'true');\r\n      });\r\n      attrs.$observe('solutionPaths', function(attr) {\r\n        Player.toggleSolutionPaths(attr === 'true');\r\n      });\r\n      attrs.$observe('lastMoveMarker', function(attr) {\r\n        Player.setLastMoveMarker(attr);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Player :: This class brings the board to life and allows a user to interact with it. It\r\n * handles user input, controls objects going to the board, can load game records, and allows the\r\n * user to manipulate the board according to the current player mode.\r\n * Unless you want to display static positions, this is the class you'd use by default.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Service', [\r\n  'ngGo',\r\n  'ngGo.Player.Directive',\r\n  'ngGo.Player.Mode.Common.Service',\r\n  'ngGo.Board.Service',\r\n  'ngGo.Game.Service',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Default mode/tool\r\n    mode: PlayerModes.REPLAY,\r\n    tool: PlayerTools.MOVE,\r\n\r\n    //Keys/scrollwheel navigation\r\n    arrowKeysNavigation: true,\r\n    scrollWheelNavigation: true,\r\n\r\n    //Last move marker, leave empty for none\r\n    lastMoveMarker: MarkupTypes.LAST,\r\n\r\n    //Indicate variations with markup on the board, and show\r\n    //successor node variations or current node variations\r\n    variationMarkup: true,\r\n    variationChildren: true,\r\n    variationSiblings: false\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\r\n\r\n    /**\r\n     * Helper to append board grid coordinatess to the broadcast event object\r\n     */\r\n    function processMouseEvent(broadcastEvent, mouseEvent) {\r\n\r\n      //Can only do this with a board and mouse event\r\n      if (!this.board || !mouseEvent) {\r\n        broadcastEvent.x = -1;\r\n        broadcastEvent.y = -1;\r\n        return;\r\n      }\r\n\r\n      //Init\r\n      var x = 0;\r\n      var y = 0;\r\n\r\n      //Set x\r\n      if (typeof mouseEvent.offsetX !== 'undefined') {\r\n        x = mouseEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.offsetX;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\r\n      ) {\r\n        x = mouseEvent.originalEvent.layerX;\r\n      }\r\n\r\n      //Set y\r\n      if (typeof mouseEvent.offsetY !== 'undefined') {\r\n        y = mouseEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.offsetY;\r\n      }\r\n      else if (\r\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\r\n      ) {\r\n        y = mouseEvent.originalEvent.layerY;\r\n      }\r\n\r\n      //Apply pixel ratio factor\r\n      x *= (window.devicePixelRatio || 1);\r\n      y *= (window.devicePixelRatio || 1);\r\n\r\n      //Append coords\r\n      broadcastEvent.x = this.board.getGridX(x);\r\n      broadcastEvent.y = this.board.getGridY(y);\r\n\r\n      //Did we drag?\r\n      if (mouseEvent.drag) {\r\n        broadcastEvent.drag = mouseEvent.drag;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player class\r\n     */\r\n    var Player = {\r\n\r\n      //Player configuration\r\n      config: {},\r\n\r\n      //Board and game instances\r\n      board: null,\r\n      game: null,\r\n\r\n      //Available modes and tools\r\n      modes: {},\r\n      tools: [],\r\n\r\n      //Player mode and active tool\r\n      mode: '',\r\n      tool: '',\r\n\r\n      //Current path\r\n      path: null,\r\n\r\n      /**\r\n       * Initialization\r\n       */\r\n      init: function() {\r\n\r\n        //Unlink board instance, create new game\r\n        this.board = null;\r\n        this.game = new Game();\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Player mode and active tool\r\n        this.mode = '';\r\n        this.tool = '';\r\n\r\n        //Arrow keys / scroll wheel navigation\r\n        this.arrowKeysNavigation = false;\r\n        this.scrollWheelNavigation = false;\r\n\r\n        //Last move marker\r\n        this.lastMoveMarker = '';\r\n\r\n        //Variation markup\r\n        this.variationMarkup = false;\r\n        this.variationChildren = false;\r\n        this.variationSiblings = false;\r\n\r\n        //Restricted nodes\r\n        this.restrictNodeStart = null;\r\n        this.restrictNodeEnd = null;\r\n\r\n        //Parse config\r\n        this.parseConfig();\r\n      },\r\n\r\n      /**\r\n       * Link the player to a HTML element\r\n       */\r\n      linkElement: function(element) {\r\n\r\n        //Set element\r\n        this.element = element;\r\n\r\n        //Register document event\r\n        this.registerElementEvent('keydown', $document);\r\n\r\n        //Register element events\r\n        this.registerElementEvent('click');\r\n        this.registerElementEvent('mousedown');\r\n        this.registerElementEvent('mouseup');\r\n        this.registerElementEvent('mousemove');\r\n        this.registerElementEvent('mouseout');\r\n        this.registerElementEvent('mousewheel');\r\n        this.registerElementEvent('wheel');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Configuration\r\n       ***/\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.switchMode(this.config.mode);\r\n        this.switchTool(this.config.tool);\r\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\r\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\r\n        this.setLastMoveMarker(this.config.lastMoveMarker);\r\n        this.setVariationMarkup(\r\n          this.config.variationMarkup,\r\n          this.config.variationChildren,\r\n          this.config.variationSiblings\r\n        );\r\n\r\n        //Let the modes parse their config\r\n        for (var mode in this.modes) {\r\n          if (this.modes[mode].parseConfig) {\r\n            this.modes[mode].parseConfig.call(this, this.config);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set arrow keys navigation\r\n       */\r\n      setArrowKeysNavigation: function(arrowKeys) {\r\n        if (arrowKeys !== this.arrowKeysNavigation) {\r\n          this.arrowKeysNavigation = arrowKeys;\r\n          this.broadcast('settingChange', 'arrowKeysNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set scroll wheel navigation\r\n       */\r\n      setScrollWheelNavigation: function(scrollWheel) {\r\n        if (scrollWheel !== this.scrollWheelNavigation) {\r\n          this.scrollWheelNavigation = scrollWheel;\r\n          this.broadcast('settingChange', 'scrollWheelNavigation');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the last move marker\r\n       */\r\n      setLastMoveMarker: function(lastMoveMarker) {\r\n        if (lastMoveMarker !== this.lastMoveMarker) {\r\n          this.lastMoveMarker = lastMoveMarker;\r\n          this.broadcast('settingChange', 'lastMoveMarker');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set variation markup on the board\r\n       */\r\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\r\n\r\n        //One change event for these three settings\r\n        var change = false;\r\n\r\n        //Markup setting change?\r\n        if (variationMarkup !== this.variationMarkup) {\r\n          this.variationMarkup = variationMarkup;\r\n          change = true;\r\n        }\r\n\r\n        //Children setting change?\r\n        if (\r\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\r\n        ) {\r\n          this.variationChildren = variationChildren;\r\n          change = true;\r\n        }\r\n\r\n        //Siblings setting change?\r\n        if (\r\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\r\n        ) {\r\n          this.variationSiblings = variationSiblings;\r\n          change = true;\r\n        }\r\n\r\n        //Did anything change?\r\n        if (change) {\r\n          this.broadcast('settingChange', 'variationMarkup');\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Mode and tool handling\r\n       ***/\r\n\r\n      /**\r\n       * Register a player mode\r\n       */\r\n      registerMode: function(mode, PlayerMode) {\r\n\r\n        //Register the mode and let it parse the configuration\r\n        this.modes[mode] = PlayerMode;\r\n\r\n        //Parse config if we have a handler\r\n        if (this.modes[mode].parseConfig) {\r\n          this.modes[mode].parseConfig.call(this, this.config);\r\n        }\r\n\r\n        //Force switch the mode now, if it matches the initial mode\r\n        if (this.mode === mode) {\r\n          this.switchMode(this.mode, true);\r\n          this.switchTool(this.tool, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set available tools\r\n       */\r\n      setTools: function(tools) {\r\n        this.tools = tools || [PlayerTools.NONE];\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player mode\r\n       */\r\n      hasMode: function(mode) {\r\n        return this.modes[mode] ? true : false;\r\n      },\r\n\r\n      /**\r\n       * Check if we have a player tool\r\n       */\r\n      hasTool: function(tool) {\r\n        return (this.tools.indexOf(tool) !== -1);\r\n      },\r\n\r\n      /**\r\n       * Switch player mode\r\n       */\r\n      switchMode: function(mode, force) {\r\n\r\n        //No change?\r\n        if (!force && (!mode || this.mode === mode)) {\r\n          return false;\r\n        }\r\n\r\n        //Broadcast mode exit\r\n        if (this.mode) {\r\n          this.broadcast('modeExit', this.mode);\r\n        }\r\n\r\n        //Set mode, reset tools and active tool\r\n        this.mode = mode;\r\n        this.tools = [];\r\n        this.tool = PlayerTools.NONE;\r\n\r\n        //Broadcast mode entry\r\n        this.broadcast('modeEnter', this.mode);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Switch player tool\r\n       */\r\n      switchTool: function(tool, force) {\r\n\r\n        //No change?\r\n        if (!force && (!tool || this.tool === tool)) {\r\n          return false;\r\n        }\r\n\r\n        //Validate tool switch (only when there is a mode)\r\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\r\n          return false;\r\n        }\r\n\r\n        //Change tool\r\n        this.tool = tool;\r\n        this.broadcast('toolSwitch', this.tool);\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Save the full player state\r\n       */\r\n      saveState: function() {\r\n\r\n        //Save player state\r\n        this.playerState = {\r\n          mode: this.mode,\r\n          tool: this.tool,\r\n          restrictNodeStart: this.restrictNodeStart,\r\n          restrictNodeEnd: this.restrictNodeEnd\r\n        };\r\n\r\n        //Save game state\r\n        this.saveGameState();\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved player state\r\n       */\r\n      restoreState: function() {\r\n\r\n        //Must have player state\r\n        if (!this.playerState) {\r\n          return;\r\n        }\r\n\r\n        //Restore\r\n        this.switchMode(this.playerState.mode);\r\n        this.switchTool(this.playerState.tool);\r\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\r\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\r\n\r\n        //Restore game state\r\n        this.restoreGameState();\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game record handling\r\n       ***/\r\n\r\n      /**\r\n       * Load game record\r\n       */\r\n      load: function(data, allowPlayerConfig) {\r\n\r\n        //Try to load the game record data\r\n        try {\r\n          this.game.load(data);\r\n        }\r\n        catch (error) {\r\n          throw error;\r\n        }\r\n\r\n        //Reset path\r\n        this.path = null;\r\n\r\n        //Parse configuration from JGF if allowed\r\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\r\n          this.parseConfig(this.game.get('settings'));\r\n        }\r\n\r\n        //Dispatch game loaded event\r\n        this.broadcast('gameLoaded', this.game);\r\n\r\n        //Board present?\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n\r\n        //Loaded ok\r\n        return true;\r\n      },\r\n\r\n      /**\r\n       * Reload the existing game record\r\n       */\r\n      reload: function() {\r\n\r\n        //Must have game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reload game\r\n        this.game.reload();\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Save the current state\r\n       */\r\n      saveGameState: function() {\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.gameState = this.game.getState();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restore to the saved state\r\n       */\r\n      restoreGameState: function() {\r\n\r\n        //Must have game and saved state\r\n        if (!this.game || !this.gameState) {\r\n          return;\r\n        }\r\n\r\n        //Restore state\r\n        this.game.restoreState(this.gameState);\r\n\r\n        //Update board\r\n        if (this.board) {\r\n          this.board.removeAll();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Navigation\r\n       ***/\r\n\r\n      /**\r\n       * Go to the next position\r\n       */\r\n      next: function(i) {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.next(i);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position\r\n       */\r\n      previous: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previous();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the last position\r\n       */\r\n      last: function() {\r\n        if (this.game) {\r\n          this.game.last();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the first position\r\n       */\r\n      first: function() {\r\n        if (this.game) {\r\n          this.game.first();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to a specific move number, tree path or named node\r\n       */\r\n      goto: function(target) {\r\n        if (this.game && target) {\r\n          this.game.goto(target);\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the previous fork\r\n       */\r\n      previousFork: function() {\r\n        if (this.game) {\r\n          this.game.previousFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next fork\r\n       */\r\n      nextFork: function() {\r\n        if (this.game) {\r\n          this.game.nextFork();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go to the next position with a comment\r\n       */\r\n      nextComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\r\n          this.game.nextComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Go back to the previous position with a comment\r\n       */\r\n      previousComment: function() {\r\n        if (this.game && this.game.node !== this.restrictNodeStart) {\r\n          this.game.previousComment();\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restrict navigation to the current node\r\n       */\r\n      restrictNode: function(end) {\r\n\r\n        //Must have game and node\r\n        if (!this.game || !this.game.node) {\r\n          return;\r\n        }\r\n\r\n        //Restrict to current node\r\n        if (end) {\r\n          this.restrictNodeEnd = this.game.node;\r\n        }\r\n        else {\r\n          this.restrictNodeStart = this.game.node;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Process a new game position\r\n       */\r\n      processPosition: function() {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Get current node and game position\r\n        var node = this.game.getNode();\r\n        var path = this.game.getPath();\r\n        var position = this.game.getPosition();\r\n        var pathChanged = !path.compare(this.path);\r\n\r\n        //Update board\r\n        this.updateBoard(node, position, pathChanged);\r\n\r\n        //Path change?\r\n        if (pathChanged) {\r\n\r\n          //Copy new path and broadcast path change\r\n          this.path = path.clone();\r\n          this.broadcast('pathChange', node);\r\n\r\n          //Named node reached? Broadcast event\r\n          if (node.name) {\r\n            this.broadcast('reachedNode.' + node.name, node);\r\n          }\r\n        }\r\n\r\n        //Passed?\r\n        if (node.move && node.move.pass) {\r\n          this.broadcast('movePassed', node);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Show move numbers\r\n       */\r\n      showMoveNumbers: function(fromMove, toMove) {\r\n\r\n        //No game?\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Use sensible defaults if no from/to moves given\r\n        fromMove = fromMove || 1;\r\n        toMove = toMove || this.game.getMove();\r\n\r\n        //Get nodes for these moves\r\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\r\n        var move = fromMove;\r\n\r\n        //Loop nodes\r\n        angular.forEach(nodes, function(node) {\r\n          this.board.add('markup', node.move.x, node.move.y, {\r\n            type: MarkupTypes.LABEL,\r\n            text: move++\r\n          });\r\n        }, this);\r\n\r\n        //Redraw board markup\r\n        this.board.redraw('markup');\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Game handling\r\n       ***/\r\n\r\n      /**\r\n       * Start a new game\r\n       */\r\n      newGame: function() {\r\n        this.game = new Game();\r\n        this.processPosition();\r\n      },\r\n\r\n      /**\r\n       * Score the current game position\r\n       */\r\n      scoreGame: function() {\r\n\r\n        //Calculate score\r\n        GameScorer.calculate();\r\n\r\n        //Get score, points and captures\r\n        var score = GameScorer.getScore();\r\n        var points = GameScorer.getPoints();\r\n        var captures = GameScorer.getCaptures();\r\n\r\n        //Remove all markup, and set captures and points\r\n        this.board.layers.markup.removeAll();\r\n        this.board.layers.score.setAll(points, captures);\r\n\r\n        //Broadcast score\r\n        this.broadcast('scoreCalculated', score);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Board handling\r\n       ***/\r\n\r\n      /**\r\n       * Get the board\r\n       */\r\n      getBoard: function() {\r\n        return this.board;\r\n      },\r\n\r\n      /**\r\n       * Set the board\r\n       */\r\n      setBoard: function(Board) {\r\n\r\n        //Set the board\r\n        this.board = Board;\r\n\r\n        //Board ready\r\n        if (this.board) {\r\n          this.broadcast('boardReady', this.board);\r\n        }\r\n\r\n        //If a game has been loaded already, parse config and update the board\r\n        if (this.game && this.game.isLoaded()) {\r\n          this.board.removeAll();\r\n          this.board.parseConfig(this.game.get('board'));\r\n          this.processPosition();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Update the board\r\n       */\r\n      updateBoard: function(node, position, pathChanged) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Update board with new position\r\n        this.board.updatePosition(position, pathChanged);\r\n\r\n        //Mark last move\r\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\r\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\r\n        }\r\n\r\n        //Broadcast board update event\r\n        this.broadcast('boardUpdate', node);\r\n      },\r\n\r\n      /*****************************************************************************\r\n       * Event handling\r\n       ***/\r\n\r\n      /**\r\n       * Register an element event\r\n       */\r\n      registerElementEvent: function(event, element) {\r\n\r\n        //Which element to use\r\n        if (typeof element === 'undefined' || !element.on) {\r\n          element = this.element;\r\n        }\r\n\r\n        //Remove any existing event listener and apply new one\r\n        //TODO: Namespacing events doesn't work with Angular's jqLite\r\n        element.off(event/* + '.ngGo.player'*/);\r\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\r\n      },\r\n\r\n      /**\r\n       * Event listener\r\n       */\r\n      on: function(type, listener, mode, $scope) {\r\n\r\n        //Must have valid listener\r\n        if (typeof listener !== 'function') {\r\n          console.warn('Listener is not a function:', listener);\r\n          return;\r\n        }\r\n\r\n        //Scope given as 3rd parameter?\r\n        if (mode && mode.$parent) {\r\n          $scope = mode;\r\n          mode = '';\r\n        }\r\n\r\n        //Multiple events?\r\n        if (type.indexOf(' ') !== -1) {\r\n          var types = type.split(' ');\r\n          for (var t = 0; t < types.length; t++) {\r\n            this.on(types[t], listener, mode, $scope);\r\n          }\r\n          return;\r\n        }\r\n\r\n        //Get self and determine scope to use\r\n        var self = this;\r\n        var scope = $scope || $rootScope;\r\n\r\n        //Create listener and return de-registration function\r\n        return scope.$on('ngGo.player.' + type, function() {\r\n\r\n          //Filter on mode\r\n          if (mode) {\r\n            if (\r\n              (typeof mode === 'string' && mode !== self.mode) ||\r\n              mode.indexOf(self.mode) === -1\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          //Inside a text field?\r\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\r\n            return;\r\n          }\r\n\r\n          //Append grid coordinates for mouse events\r\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\r\n            processMouseEvent.call(self, arguments[0], arguments[1]);\r\n          }\r\n\r\n          //Dragging? Prevent click events from firing\r\n          if (self.preventClickEvent && type === 'click') {\r\n            delete self.preventClickEvent;\r\n            return;\r\n          }\r\n          else if (type === 'mousedrag') {\r\n            self.preventClickEvent = true;\r\n          }\r\n\r\n          //Call listener\r\n          listener.apply(self, arguments);\r\n        });\r\n      },\r\n\r\n      /**\r\n       * Event broadcaster\r\n       */\r\n      broadcast: function(type, args) {\r\n\r\n        //Must have type\r\n        if (!type) {\r\n          return;\r\n        }\r\n\r\n        //Make sure we are in a digest cycle\r\n        if (!$rootScope.$$phase) {\r\n          $rootScope.$apply(function() {\r\n            $rootScope.$broadcast('ngGo.player.' + type, args);\r\n          });\r\n        }\r\n        else {\r\n          $rootScope.$broadcast('ngGo.player.' + type, args);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Initialize\r\n    Player.init();\r\n\r\n    //Return object\r\n    return Player;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\r\n * gridlines, starpoints and coordinates via the Coordinates class.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Coordinates.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\r\n\r\n  /**\r\n   * Helper for drawing starpoints\r\n   */\r\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\r\n\r\n    //Don't draw if it falls outsize of the board grid\r\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\r\n      return;\r\n    }\r\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\r\n      return;\r\n    }\r\n\r\n    //Get absolute coordinates and star point radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n\r\n    //Draw star point\r\n    this.context.beginPath();\r\n    this.context.fillStyle = starColor;\r\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function GridLayer(board, context) {\r\n\r\n    //Set coordinates setting\r\n    this.coordinates = false;\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Show or hide the coordinates.\r\n   */\r\n  GridLayer.prototype.setCoordinates = function(show) {\r\n    this.coordinates = show;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Get all has nothing to return\r\n   */\r\n  GridLayer.prototype.getAll = function() {\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Set all has nothing to set\r\n   */\r\n  GridLayer.prototype.setAll = function(/*grid*/) {\r\n    return;\r\n  };\r\n\r\n  /**\r\n   * Remove all has nothing to remove\r\n   */\r\n  GridLayer.prototype.removeAll = function() {\r\n    return;\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw method\r\n   */\r\n  GridLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Determine top x and y margin\r\n    var tx = this.board.drawMarginHor;\r\n    var ty = this.board.drawMarginVer;\r\n\r\n    //Get theme properties\r\n    var cellSize = this.board.getCellSize();\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\r\n    var lineCap = this.board.theme.get('grid.lineCap');\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Helper vars\r\n    var i, x, y;\r\n\r\n    //Draw vertical lines\r\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\r\n      x = this.board.getAbsX(i);\r\n      this.context.moveTo(x, ty);\r\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\r\n    }\r\n\r\n    //Draw horizontal lines\r\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\r\n      y = this.board.getAbsY(i);\r\n      this.context.moveTo(tx, y);\r\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\r\n    }\r\n\r\n    //Draw grid lines\r\n    this.context.stroke();\r\n\r\n    //Star points defined?\r\n    for (i = 0; i < starPoints.length; i++) {\r\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n\r\n    //Draw coordinates\r\n    if (this.coordinates) {\r\n      Coordinates.draw.call(this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Clear rectangle\r\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  /**\r\n   * Redraw a square cell area on the grid\r\n   */\r\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\r\n\r\n    //Get absolute coordinates and stone radius\r\n    var x = this.board.getAbsX(gridX);\r\n    var y = this.board.getAbsY(gridY);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\r\n    var strokeStyle = this.board.theme.get('grid.lineColor');\r\n    var starRadius = this.board.theme.get('grid.star.radius', s);\r\n    var starColor = this.board.theme.get('grid.star.color');\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\r\n\r\n    //Determine draw coordinates\r\n    var x1 = (gridX === 0) ? x : x - r;\r\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\r\n    var y1 = (gridY === 0) ? y : y - r;\r\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.beginPath();\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Patch up grid lines\r\n    this.context.moveTo(x1, y);\r\n    this.context.lineTo(x2, y);\r\n    this.context.moveTo(x, y1);\r\n    this.context.lineTo(x, y2);\r\n    this.context.stroke();\r\n\r\n    //Check if we need to draw a star point here\r\n    for (var i in starPoints) {\r\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\r\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\r\n      }\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  };\r\n\r\n  //Return\r\n  return GridLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function HoverLayer(board, context) {\r\n\r\n    //Container for items to restore\r\n    this.restore = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add hover item\r\n   */\r\n  HoverLayer.prototype.add = function(x, y, hover) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.isOnGrid(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Remove any previous item at this position\r\n    this.remove(x, y);\r\n\r\n    //Create hover object\r\n    hover.object = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    //Stones\r\n    if (hover.type === 'stones') {\r\n      hover.objectClass = StoneFaded;\r\n      hover.object.color = hover.value;\r\n    }\r\n\r\n    //Markup\r\n    else if (hover.type === 'markup') {\r\n      hover.objectClass = Markup;\r\n      if (typeof hover.value === 'object') {\r\n        hover.object = angular.extend(hover.object, hover.value);\r\n      }\r\n      else {\r\n        hover.object.type = hover.value;\r\n      }\r\n    }\r\n\r\n    //Unknown\r\n    else {\r\n      console.warn('Unknown hover type', hover.type);\r\n      return;\r\n    }\r\n\r\n    //Check if we need to hide something on layers underneath\r\n    if (this.board.has(hover.type, x, y)) {\r\n      this.restore.push({\r\n        x: x,\r\n        y: y,\r\n        layer: hover.type,\r\n        value: this.board.get(hover.type, x, y)\r\n      });\r\n      this.board.remove(hover.type, x, y);\r\n    }\r\n\r\n    //Add to stack\r\n    this.grid.set(x, y, hover);\r\n\r\n    //Draw item\r\n    if (hover.objectClass && hover.objectClass.draw) {\r\n      hover.objectClass.draw.call(this, hover.object);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove the hover object\r\n   */\r\n  HoverLayer.prototype.remove = function(x, y) {\r\n\r\n    //Validate coordinates\r\n    if (!this.grid.has(x, y)) {\r\n      return;\r\n    }\r\n\r\n    //Get object and clear it\r\n    var hover = this.grid.get(x, y);\r\n    if (hover.objectClass && hover.objectClass.clear) {\r\n      hover.objectClass.clear.call(this, hover.object);\r\n    }\r\n\r\n    //Other objects to restore?\r\n    for (var i = 0; i < this.restore.length; i++) {\r\n      if (this.restore[i].x === x && this.restore[i].y === y) {\r\n        this.board.add(\r\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n        );\r\n        this.restore.splice(i, 1);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove all hover objects\r\n   */\r\n  HoverLayer.prototype.removeAll = function() {\r\n\r\n    //Anything to do?\r\n    if (this.grid.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    //Get all item as objects\r\n    var i;\r\n    var hover = this.grid.all('layer');\r\n\r\n    //Clear them\r\n    for (i = 0; i < hover.length; i++) {\r\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\r\n        hover[i].objectClass.clear.call(this, hover[i].object);\r\n      }\r\n    }\r\n\r\n    //Clear layer and empty grid\r\n    this.clear();\r\n    this.grid.empty();\r\n\r\n    //Restore objects on other layers\r\n    for (i = 0; i < this.restore.length; i++) {\r\n      this.board.add(\r\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\r\n      );\r\n    }\r\n\r\n    //Clear restore array\r\n    this.restore = [];\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  HoverLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Loop objects and clear them\r\n    var hover = this.grid.all('hover');\r\n    for (var i = 0; i < hover.length; i++) {\r\n      if (hover.objectClass && hover.objectClass.draw) {\r\n        hover.objectClass.draw.call(this, hover.object);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return HoverLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Markup.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function MarkupLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all markup at once\r\n   */\r\n  MarkupLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'type');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Markup.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Markup.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /**\r\n   * Remove all (clear layer and empty grid)\r\n   */\r\n  MarkupLayer.prototype.removeAll = function() {\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Clear them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.clear.call(this, markup[i]);\r\n    }\r\n\r\n    //Empty the grid now\r\n    this.grid.empty();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  MarkupLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all markup as objects\r\n    var markup = this.grid.all('type');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < markup.length; i++) {\r\n      Markup.draw.call(this, markup[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  MarkupLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  MarkupLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return MarkupLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneMini.Service',\r\n  'ngGo.Board.Object.StoneFaded.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ScoreLayer(board, context) {\r\n\r\n    //Points and captures\r\n    this.points = [];\r\n    this.captures = [];\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set points and captures\r\n   */\r\n  ScoreLayer.prototype.setAll = function(points, captures) {\r\n\r\n    //Remove all existing stuff first\r\n    this.removeAll();\r\n\r\n    //Set new stuff\r\n    this.points = points.all('color');\r\n    this.captures = captures.all('color');\r\n\r\n    //Draw\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Remove all scoring\r\n   */\r\n  ScoreLayer.prototype.removeAll = function() {\r\n\r\n    //If there are captures, draw them back onto the stones layer\r\n    for (var i = 0; i < this.captures.length; i++) {\r\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\r\n    }\r\n\r\n    //Clear the layer\r\n    this.clear();\r\n\r\n    //Remove all stuff\r\n    this.points = [];\r\n    this.captures = [];\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ScoreLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Init\r\n    var i;\r\n\r\n    //Draw captures first (removing stones from the stones layer)\r\n    for (i = 0; i < this.captures.length; i++) {\r\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\r\n      StoneFaded.draw.call(this, this.captures[i]);\r\n    }\r\n\r\n    //Draw points on top of it\r\n    for (i = 0; i < this.points.length; i++) {\r\n      StoneMini.draw.call(this, this.points[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ScoreLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.StoneShadow.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function ShadowLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\r\n\r\n  /**\r\n   * Add a stone\r\n   */\r\n  ShadowLayer.prototype.add = function(stone) {\r\n\r\n    //Don't add if no shadow\r\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\r\n      return;\r\n    }\r\n\r\n    //Already have a stone here?\r\n    if (this.grid.has(stone.x, stone.y)) {\r\n      return;\r\n    }\r\n\r\n    //Add to grid\r\n    this.grid.set(stone.x, stone.y, stone.color);\r\n\r\n    //Draw it if there is a context\r\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\r\n      StoneShadow.draw.call(this, stone);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove a stone\r\n   */\r\n  ShadowLayer.prototype.remove = function(stone) {\r\n\r\n    //Remove from grid\r\n    this.grid.unset(stone.x, stone.y);\r\n\r\n    //Redraw whole layer\r\n    this.redraw();\r\n  };\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  ShadowLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get shadowsize from theme\r\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\r\n\r\n    //Apply shadow transformation\r\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      StoneShadow.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return ShadowLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Layer.Service',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  function StonesLayer(board, context) {\r\n\r\n    //Call parent constructor\r\n    BoardLayer.call(this, board, context);\r\n\r\n    //Set empty value for grid\r\n    this.grid.whenEmpty(StoneColor.EMPTY);\r\n  }\r\n\r\n  /**\r\n   * Prototype extension\r\n   */\r\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\r\n\r\n  /*****************************************************************************\r\n   * Object handling\r\n   ***/\r\n\r\n  /**\r\n   * Set all stones at once\r\n   */\r\n  StonesLayer.prototype.setAll = function(grid) {\r\n\r\n    //Get changes compared to current grid\r\n    var i;\r\n    var changes = this.grid.compare(grid, 'color');\r\n\r\n    //Clear removed stuff\r\n    for (i = 0; i < changes.remove.length; i++) {\r\n      Stone.clear.call(this, changes.remove[i]);\r\n    }\r\n\r\n    //Draw added stuff\r\n    for (i = 0; i < changes.add.length; i++) {\r\n      Stone.draw.call(this, changes.add[i]);\r\n    }\r\n\r\n    //Remember new grid\r\n    this.grid = grid.clone();\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Drawing\r\n   ***/\r\n\r\n  /**\r\n   * Draw layer\r\n   */\r\n  StonesLayer.prototype.draw = function() {\r\n\r\n    //Can only draw when we have dimensions and context\r\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //Get all stones as objects\r\n    var stones = this.grid.all('color');\r\n\r\n    //Draw them\r\n    for (var i = 0; i < stones.length; i++) {\r\n      Stone.draw.call(this, stones[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Redraw layer\r\n   */\r\n  StonesLayer.prototype.redraw = function() {\r\n\r\n    //Clear shadows layer\r\n    this.board.removeAll('shadow');\r\n\r\n    //Redraw ourselves\r\n    this.clear();\r\n    this.draw();\r\n  };\r\n\r\n  /**\r\n   * Draw cell\r\n   */\r\n  StonesLayer.prototype.drawCell = function(x, y) {\r\n\r\n    //Can only draw when we have dimensions\r\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n      return;\r\n    }\r\n\r\n    //On grid?\r\n    if (this.grid.has(x, y)) {\r\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear cell\r\n   */\r\n  StonesLayer.prototype.clearCell = function(x, y) {\r\n    if (this.grid.has(x, y)) {\r\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StonesLayer;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Coordinates :: This class is used for drawing board coordinates\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Coordinates.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Coordinates', function() {\r\n\r\n  //Kanji\r\n  var kanji = [\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', '',\r\n    '', '', '', '', '', '', '', '', '', ''\r\n  ];\r\n\r\n  //Character codes\r\n  var aChar = 'A'.charCodeAt(0);\r\n  var aCharLc = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Coordinate generators\r\n   */\r\n  var coordinates = {\r\n\r\n    //Kanji coordinates\r\n    kanji: function(i) {\r\n      return kanji[i] || '';\r\n    },\r\n\r\n    //Numbers from 1\r\n    numbers: function(i) {\r\n      return i + 1;\r\n    },\r\n\r\n    //Capital letters from A\r\n    letters: function(i) {\r\n\r\n      //Initialize\r\n      var ch = '';\r\n\r\n      //Beyond Z? Prepend with A\r\n      if (i >= 25) {\r\n        ch = 'A';\r\n        i -= 25;\r\n      }\r\n\r\n      //The letter I is ommitted\r\n      if (i >= 8) {\r\n        i++;\r\n      }\r\n\r\n      //Return\r\n      return ch + String.fromCharCode(aChar + i);\r\n    },\r\n\r\n    //JGF coordinates (e.g. 0, 1, ...)\r\n    jgf: function(i) {\r\n      return i;\r\n    },\r\n\r\n    //SGF coordinates (e.g. a, b, ...)\r\n    sgf: function(i) {\r\n      var ch;\r\n      if (i < 26) {\r\n        ch = aCharLc + i;\r\n      }\r\n      else {\r\n        ch = aChar + i;\r\n      }\r\n      return String.fromCharCode(ch);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Coordinates object\r\n   */\r\n  var Coordinates = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function() {\r\n\r\n      //Can only draw when we have context and dimensions\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Get cell size\r\n      var cellSize = this.board.getCellSize();\r\n\r\n      //Get boundary coordinates\r\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\r\n      var xr = this.board.drawWidth - xl;\r\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\r\n      var yb = this.board.drawHeight - yt;\r\n\r\n      //Get theme properties\r\n      var fillStyle = this.board.theme.get('coordinates.color');\r\n      var vertical = {\r\n        font: this.board.theme.get('coordinates.vertical.font'),\r\n        size: this.board.theme.get('coordinates.vertical.size'),\r\n        style: this.board.theme.get('coordinates.vertical.style'),\r\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\r\n      };\r\n      var horizontal = {\r\n        font: this.board.theme.get('coordinates.horizontal.font'),\r\n        size: this.board.theme.get('coordinates.horizontal.size'),\r\n        style: this.board.theme.get('coordinates.horizontal.style'),\r\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\r\n      };\r\n\r\n      //Configure context\r\n      this.context.fillStyle = fillStyle;\r\n      this.context.textBaseline = 'middle';\r\n      this.context.textAlign = 'center';\r\n\r\n      //Helper vars\r\n      var i, j, x, y, ch;\r\n\r\n      //Draw vertical coordinates\r\n      for (i = 0; i < this.board.height; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (vertical.inverse) {\r\n          j = this.board.height - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof vertical.style === 'function') {\r\n          ch = vertical.style.call(this, j);\r\n        }\r\n        else if (coordinates[vertical.style]) {\r\n          ch = coordinates[vertical.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        y = this.board.getAbsY(i);\r\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\r\n        this.context.fillText(ch, xl, y);\r\n        this.context.fillText(ch, xr, y);\r\n      }\r\n\r\n      //Draw horizontal coordinates\r\n      for (i = 0; i < this.board.width; i++) {\r\n\r\n        //Inverse?\r\n        j = i;\r\n        if (horizontal.inverse) {\r\n          j = this.board.width - i - 1;\r\n        }\r\n\r\n        //Get character\r\n        if (typeof horizontal.style === 'function') {\r\n          ch = horizontal.style.call(this, j);\r\n        }\r\n        else if (coordinates[horizontal.style]) {\r\n          ch = coordinates[horizontal.style].call(this, j);\r\n        }\r\n        else {\r\n          ch = j;\r\n        }\r\n\r\n        //Draw\r\n        x = this.board.getAbsX(i);\r\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\r\n        this.context.fillText(ch, x, yt);\r\n        this.context.fillText(ch, x, yb);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Coordinates;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Markup :: This class is used for drawing markup\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Markup.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\r\n\r\n  /**\r\n   * Math constants\r\n   */\r\n  var cosPi4 = Math.cos(Math.PI / 4);\r\n  var cosPi6 = Math.cos(Math.PI / 6);\r\n\r\n  /**\r\n   * Triangle draw handler\r\n   */\r\n  function drawTriangle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y - r);\r\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\r\n    this.context.closePath();\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Square draw handler\r\n   */\r\n  function drawSquare(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw circle handler\r\n   */\r\n  function drawCircle(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw mark handler\r\n   */\r\n  function drawMark(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Determine cos\r\n    var rcos = Math.round(r * cosPi4);\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - rcos, y - rcos);\r\n    this.context.lineTo(x + rcos, y + rcos);\r\n    this.context.moveTo(x + rcos, y - rcos);\r\n    this.context.lineTo(x - rcos, y + rcos);\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw select handler\r\n   */\r\n  function drawSelect(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.lineWidth = lineWidth;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Last move draw handler\r\n   */\r\n  function drawLast(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.moveTo(x, y);\r\n    this.context.lineTo(x + r, y);\r\n    this.context.lineTo(x, y + r);\r\n    this.context.closePath();\r\n    this.context.fill();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw happy smiley handler\r\n   */\r\n  function drawHappySmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 8);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw sad smiley handler\r\n   */\r\n  function drawSadSmiley(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = Math.round(\r\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\r\n    );\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\r\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\r\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.strokeStyle = strokeStyle;\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.lineCap = lineCap;\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\r\n    this.context.stroke();\r\n    this.context.beginPath();\r\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\r\n    this.context.bezierCurveTo(\r\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\r\n    );\r\n    this.context.stroke();\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Draw label\r\n   */\r\n  function drawLabel(markup) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(markup.x);\r\n    var y = this.board.getAbsY(markup.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (markup.scale) {\r\n      r = Math.round(r * markup.scale);\r\n    }\r\n\r\n    //Get stone color\r\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\r\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //First, clear grid square below for clarity\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.clearCell(markup.x, markup.y);\r\n    }\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.textBaseline = 'middle';\r\n    this.context.textAlign = 'center';\r\n\r\n    //Convert to text\r\n    if (typeof markup.text === 'number') {\r\n      markup.text = markup.text.toString();\r\n    }\r\n\r\n    //Determine font size\r\n    if (markup.text.length === 1) {\r\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\r\n    }\r\n    else if (markup.text.length === 2) {\r\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\r\n    }\r\n    else {\r\n      this.context.font = r + 'px ' + font;\r\n    }\r\n\r\n    //Draw element\r\n    this.context.beginPath();\r\n    this.context.fillText(markup.text, x, y, 2 * r);\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Clear label\r\n   */\r\n  function clearLabel(markup) {\r\n\r\n    //No stone on location? Redraw the grid square, if we cleared it\r\n    if (!this.board.has('stones', markup.x, markup.y)) {\r\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup class\r\n   */\r\n  var Markup = {\r\n\r\n    /**\r\n     * Draw\r\n     */\r\n    draw: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Drawing depends on type\r\n      switch (markup.type) {\r\n\r\n        //Triangle\r\n        case MarkupTypes.TRIANGLE:\r\n          drawTriangle.call(this, markup);\r\n          break;\r\n\r\n        //Square\r\n        case MarkupTypes.SQUARE:\r\n          drawSquare.call(this, markup);\r\n          break;\r\n\r\n        //Circle\r\n        case MarkupTypes.CIRCLE:\r\n          drawCircle.call(this, markup);\r\n          break;\r\n\r\n        //Mark\r\n        case MarkupTypes.MARK:\r\n          drawMark.call(this, markup);\r\n          break;\r\n\r\n        //Select\r\n        case MarkupTypes.SELECT:\r\n          drawSelect.call(this, markup);\r\n          break;\r\n\r\n        //happy\r\n        case MarkupTypes.HAPPY:\r\n          drawHappySmiley.call(this, markup);\r\n          break;\r\n\r\n        //Sad\r\n        case MarkupTypes.SAD:\r\n          drawSadSmiley.call(this, markup);\r\n          break;\r\n\r\n        //Last move marker\r\n        case MarkupTypes.LAST:\r\n          drawLast.call(this, markup);\r\n          break;\r\n\r\n        //Label\r\n        case MarkupTypes.LABEL:\r\n          markup.text = markup.text || '';\r\n          drawLabel.call(this, markup);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear\r\n     */\r\n    clear: function(markup) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, markup);\r\n\r\n      //Special handling for label\r\n      if (markup.type === MarkupTypes.LABEL) {\r\n        clearLabel.call(this, markup);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Markup;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Stone :: This class is used for drawing stones on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.Stone.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service',\r\n  'ngGo.Board.ShellPattern.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\r\n\r\n  /**\r\n   * Shell random seed\r\n   */\r\n  var shellSeed;\r\n\r\n  /**\r\n   * Mono colored stones\r\n   */\r\n  function drawMono(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Don't draw shadow\r\n    stone.shadow = false;\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme properties\r\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\r\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Configure context\r\n    this.context.fillStyle = fillStyle;\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Configure context\r\n    this.context.lineWidth = lineWidth;\r\n    this.context.strokeStyle = strokeStyle;\r\n\r\n    //Draw outline\r\n    this.context.stroke();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Glass stones\r\n   */\r\n  function drawGlass(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Begin path\r\n    this.context.beginPath();\r\n\r\n    //Determine stone texture\r\n    if (color === StoneColor.W) {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#fff');\r\n      this.context.fillStyle.addColorStop(1, '#aaa');\r\n    }\r\n    else {\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\r\n      );\r\n      this.context.fillStyle.addColorStop(0, '#666');\r\n      this.context.fillStyle.addColorStop(1, '#111');\r\n    }\r\n\r\n    //Complete drawing\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fill();\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Slate and shell stones\r\n   */\r\n  function drawSlateShell(stone) {\r\n\r\n    //Get coordinates and stone radius\r\n    var x = this.board.getAbsX(stone.x);\r\n    var y = this.board.getAbsY(stone.y);\r\n    var s = this.board.getCellSize();\r\n    var r = this.board.theme.get('stone.radius', s);\r\n\r\n    //Apply scaling factor?\r\n    if (stone.scale) {\r\n      r = Math.round(r * stone.scale);\r\n    }\r\n\r\n    //Get random seed\r\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\r\n\r\n    //Apply color multiplier\r\n    var color = stone.color * this.board.colorMultiplier;\r\n\r\n    //Get theme variables\r\n    var shellTypes = this.board.theme.get('stone.shell.types');\r\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\r\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\r\n    var canvasTranslate = this.board.theme.canvasTranslate();\r\n\r\n    //Translate canvas\r\n    this.context.translate(canvasTranslate, canvasTranslate);\r\n\r\n    //Apply transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = stone.alpha;\r\n    }\r\n\r\n    //Draw stone\r\n    this.context.beginPath();\r\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n    this.context.fillStyle = fillStyle;\r\n    this.context.fill();\r\n\r\n    //Shell stones\r\n    if (color === StoneColor.W) {\r\n\r\n      //Get random shell type\r\n      var type =\r\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\r\n\r\n      //Determine random angle\r\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\r\n      var angle = (2 / z) * (shellSeed % z);\r\n\r\n      //Draw shell pattern\r\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Slate stones\r\n    else {\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n\r\n      //Add radial gradient\r\n      this.context.beginPath();\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\r\n      );\r\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    }\r\n\r\n    //Undo transparency?\r\n    if (stone.alpha && stone.alpha < 1) {\r\n      this.context.globalAlpha = 1;\r\n    }\r\n\r\n    //Undo translation\r\n    this.context.translate(-canvasTranslate, -canvasTranslate);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var Stone = {\r\n\r\n    /**\r\n     * Draw a stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Determine style of stone\r\n      var style = this.board.theme.get('stone.style');\r\n\r\n      //Draw using the appropriate handler\r\n      switch (style) {\r\n\r\n        //Slate and shell\r\n        case 'shell':\r\n          drawSlateShell.call(this, stone);\r\n          break;\r\n\r\n        //Glass stones\r\n        case 'glass':\r\n          drawGlass.call(this, stone);\r\n          break;\r\n\r\n        //Mono stones\r\n        case 'mono':\r\n          drawMono.call(this, stone);\r\n          break;\r\n\r\n        //Custom type\r\n        default:\r\n          var handler = $injector.get(style);\r\n          if (handler) {\r\n            handler.call(this, stone);\r\n          }\r\n      }\r\n\r\n      //Add shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.add(stone);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Clear a stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Can only draw when we have dimensions and context\r\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\r\n        return;\r\n      }\r\n\r\n      //Call parent method\r\n      BoardObject.clear.call(this, stone);\r\n\r\n      //Remove shadow\r\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\r\n        this.board.layers.shadow.remove(stone);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return Stone;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneFaded', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneFaded = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.faded.scale');\r\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneFaded;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\r\n * (for scoring).\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneMini.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Stone.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneMini', ['Stone', function(Stone) {\r\n\r\n  /**\r\n   * Class\r\n   */\r\n  var StoneMini = {\r\n\r\n    /**\r\n     * Draw stone\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //Set scale and alpha\r\n      stone.scale = this.board.theme.get('stone.mini.scale');\r\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Now call the regular stone draw handler\r\n      Stone.draw.call(this, stone);\r\n    },\r\n\r\n    /**\r\n     * Clear stone\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Don't show shadow\r\n      stone.shadow = false;\r\n\r\n      //Call parent method\r\n      Stone.clear.call(this, stone);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneMini;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * StoneShadow :: This class is used for drawing stone shadows on the board.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\r\n  'ngGo',\r\n  'ngGo.Board.Object.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('StoneShadow', function() {\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  var StoneShadow = {\r\n\r\n    /**\r\n     * Draw a stone shadow\r\n     */\r\n    draw: function(stone) {\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\r\n\r\n      //Apply scaling factor?\r\n      if (stone.scale) {\r\n        r = Math.round(r * stone.scale);\r\n      }\r\n\r\n      //Get theme properties\r\n      var blur = this.board.theme.get('shadow.blur', s);\r\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\r\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\r\n      var shadowColor = this.board.theme.get('shadow.color');\r\n\r\n      //Configure context\r\n      this.context.fillStyle = this.context.createRadialGradient(\r\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\r\n      );\r\n      this.context.fillStyle.addColorStop(0, shadowColor);\r\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\r\n\r\n      //Draw shadow\r\n      this.context.beginPath();\r\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\r\n      this.context.fill();\r\n    },\r\n\r\n    /**\r\n     * Clear a stone shadow\r\n     */\r\n    clear: function(stone) {\r\n\r\n      //Note: this method is currently not in use due to the overlapping shadows\r\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\r\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\r\n      //appropriate either, so for now we will leave it at this.\r\n\r\n      //No context?\r\n      if (!this.context) {\r\n        return;\r\n      }\r\n\r\n      //Don't draw shadows if there is stone alpha or if explicitly stated\r\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\r\n        return;\r\n      }\r\n\r\n      //Get coordinates and stone radius\r\n      var x = this.board.getAbsX(stone.x);\r\n      var y = this.board.getAbsY(stone.y);\r\n      var s = this.board.getCellSize();\r\n      var r = this.board.theme.get('stone.radius', s);\r\n\r\n      //Clear a generous rectangle\r\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return StoneShadow;\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\r\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions\r\n   */\r\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\r\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\r\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\r\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\r\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\r\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\r\n\r\n  /**\r\n   * Player parser function\r\n   */\r\n  function parsePlayer(jgf, match) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\r\n\r\n    //Create player object\r\n    var player = {\r\n      color: color,\r\n      name: match[2],\r\n      rank: match[3].toLowerCase()\r\n    };\r\n\r\n    //Check if player of this color already exists, if so, overwrite\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p] = player;\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, push\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, match) {\r\n    jgf.game.komi = parseFloat(match[1] / 10);\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, match) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Push date\r\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\r\n  }\r\n\r\n  /**\r\n   * Result parser function\r\n   */\r\n  function parseResult(jgf, match) {\r\n\r\n    //Winner color\r\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\r\n    result += '+';\r\n\r\n    //Win condition\r\n    if (match[2].match(/res/i)) {\r\n      result += 'R';\r\n    }\r\n    else if (match[2].match(/time/i)) {\r\n      result += 'T';\r\n    }\r\n    else {\r\n      result += match[2];\r\n    }\r\n\r\n    //Set in JGF\r\n    jgf.game.result = result;\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, match) {\r\n\r\n    //Determine player color\r\n    var color = match[2];\r\n    if (color === 1) {\r\n      color = 'B';\r\n    }\r\n    else if (color === 2) {\r\n      color = 'W';\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (false) {\r\n\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[color] = [match[3] * 1, match[4] * 1];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse GIB string into a JGF object or string\r\n     */\r\n    parse: function(gib, stringified) {\r\n\r\n      //Get new JGF object\r\n      var jgf = KifuBlank.jgf();\r\n\r\n      //Initialize\r\n      var match;\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find player information\r\n      while ((match = regPlayer.exec(gib))) {\r\n        parsePlayer(jgf, match);\r\n      }\r\n\r\n      //Find komi\r\n      if ((match = regKomi.exec(gib))) {\r\n        parseKomi(jgf, match);\r\n      }\r\n\r\n      //Find game date\r\n      if ((match = regDate.exec(gib))) {\r\n        parseDate(jgf, match);\r\n      }\r\n\r\n      //Find game result\r\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\r\n        parseResult(jgf, match);\r\n      }\r\n\r\n      //Find moves\r\n      while ((match = regMove.exec(gib))) {\r\n\r\n        //Create new node\r\n        node = {};\r\n\r\n        //Parse move\r\n        parseMove(jgf, node, match);\r\n\r\n        //Push node to container\r\n        container.push(node);\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Flip SGF alias map and create JGF alias map\r\n   */\r\n  var jgfAliases = {};\r\n  for (var sgfProp in sgfAliases) {\r\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\r\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert to SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Helper to escape SGF info\r\n   */\r\n  function escapeSgf(text) {\r\n    if (typeof text === 'string') {\r\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\r\n    }\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Helper to write an SGF group\r\n   */\r\n  function writeGroup(prop, values, output, escape) {\r\n    if (values.length) {\r\n      output.sgf += prop;\r\n      for (var i = 0; i < values.length; i++) {\r\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser\r\n   */\r\n  function parseMove(move, output) {\r\n\r\n    //Determine and validate color\r\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\r\n    if (color === '') {\r\n      return;\r\n    }\r\n\r\n    //Determine move\r\n    var coords = (move[color] === 'pass') ? '' : move[color];\r\n\r\n    //Append to SGF\r\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\r\n  }\r\n\r\n  /**\r\n   * Setup parser\r\n   */\r\n  function parseSetup(setup, output) {\r\n\r\n    //Loop colors\r\n    for (var color in setup) {\r\n      if (setup.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < setup[color].length; i++) {\r\n          setup[color][i] = convertCoordinates(setup[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('A' + color, setup[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Score parser\r\n   */\r\n  function parseScore(score, output) {\r\n\r\n    //Loop colors\r\n    for (var color in score) {\r\n      if (score.hasOwnProperty(color)) {\r\n\r\n        //Convert coordinates\r\n        for (var i = 0; i < score[color].length; i++) {\r\n          score[color][i] = convertCoordinates(score[color][i]);\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup('T' + color, score[color], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser\r\n   */\r\n  function parseMarkup(markup, output) {\r\n\r\n    //Loop markup types\r\n    for (var type in markup) {\r\n      if (markup.hasOwnProperty(type)) {\r\n        var i;\r\n\r\n        //Label type has the label text appended to the coords\r\n        if (type === 'label') {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\r\n          }\r\n        }\r\n        else {\r\n          for (i = 0; i < markup[type].length; i++) {\r\n            markup[type][i] = convertCoordinates(markup[type][i]);\r\n          }\r\n        }\r\n\r\n        //Convert type\r\n        if (typeof jgfAliases[type] !== 'undefined') {\r\n          type = jgfAliases[type];\r\n        }\r\n\r\n        //Write as group\r\n        writeGroup(type, markup[type], output);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser\r\n   */\r\n  function parseTurn(turn, output) {\r\n    output.sgf += 'PL[' + turn + ']';\r\n  }\r\n\r\n  /**\r\n   * Comments parser\r\n   */\r\n  function parseComments(comments, output) {\r\n\r\n    //Determine key\r\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\r\n\r\n    //Flatten comment objects\r\n    var flatComments = [];\r\n    for (var c = 0; c < comments.length; c++) {\r\n      if (typeof comments[c] === 'string') {\r\n        flatComments.push(comments[c]);\r\n      }\r\n      else if (comments[c].comment) {\r\n        flatComments.push(comments[c].comment);\r\n      }\r\n    }\r\n\r\n    //Write as group\r\n    writeGroup(key, flatComments, output, true);\r\n  }\r\n\r\n  /**\r\n   * Node name parser\r\n   */\r\n  function parseNodeName(nodeName, output) {\r\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\r\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\r\n  }\r\n\r\n  /**\r\n   * Game parser\r\n   */\r\n  function parseGame(game) {\r\n\r\n    //Loop SGF game definitions\r\n    for (var i in sgfGames) {\r\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    //Not found\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Application parser\r\n   */\r\n  function parseApplication(application) {\r\n    var parts = application.split(' v');\r\n    if (parts.length > 1) {\r\n      return parts[0] + ':' + parts[1];\r\n    }\r\n    return application;\r\n  }\r\n\r\n  /**\r\n   * Player instructions parser\r\n   */\r\n  function parsePlayer(player, rootProperties) {\r\n\r\n    //Variation handling\r\n    var st = 0;\r\n    if (!player.variationMarkup) {\r\n      st += 2;\r\n    }\r\n    if (player.variationSiblings) {\r\n      st += 1;\r\n    }\r\n\r\n    //Set in root properties\r\n    rootProperties.ST = st;\r\n  }\r\n\r\n  /**\r\n   * Board parser\r\n   */\r\n  function parseBoard(board, rootProperties) {\r\n\r\n    //Both width and height should be given\r\n    if (board.width && board.height) {\r\n\r\n      //Same dimensions?\r\n      if (board.width === board.height) {\r\n        rootProperties.SZ = board.width;\r\n      }\r\n\r\n      //Different dimensions are not supported by SGF, but OGS uses the\r\n      //format w:h, so we will stick with that for anyone who supports it.\r\n      else {\r\n        rootProperties.SZ = board.width + ':' + board.height;\r\n      }\r\n    }\r\n\r\n    //Otherwise, check if only width or height were given at least\r\n    else if (board.width) {\r\n      rootProperties.SZ = board.width;\r\n    }\r\n    else if (board.height) {\r\n      rootProperties.SZ = board.height;\r\n    }\r\n\r\n    //Can't determine size\r\n    else {\r\n      rootProperties.SZ = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Players parser\r\n   */\r\n  function parsePlayers(players, rootProperties) {\r\n\r\n    //Loop players\r\n    for (var p = 0; p < players.length; p++) {\r\n\r\n      //Validate color\r\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\r\n        continue;\r\n      }\r\n\r\n      //Get SGF color\r\n      var color = (players[p].color === 'black') ? 'B' : 'W';\r\n\r\n      //Name given?\r\n      if (players[p].name) {\r\n        rootProperties['P' + color] = players[p].name;\r\n      }\r\n\r\n      //Rank given?\r\n      if (players[p].rank) {\r\n        rootProperties[color + 'R'] = players[p].rank;\r\n      }\r\n\r\n      //Team given?\r\n      if (players[p].team) {\r\n        rootProperties[color + 'T'] = players[p].team;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Node properties\r\n    'move': parseMove,\r\n    'setup': parseSetup,\r\n    'score': parseScore,\r\n    'markup': parseMarkup,\r\n    'turn': parseTurn,\r\n    'comments': parseComments,\r\n    'name': parseNodeName,\r\n\r\n    //Info properties\r\n    'record.application': parseApplication,\r\n    'player': parsePlayer,\r\n    'board': parseBoard,\r\n    'game.type': parseGame,\r\n    'game.players': parsePlayers\r\n  };\r\n\r\n  /*****************************************************************************\r\n   * Parser functions\r\n   ***/\r\n\r\n  /**\r\n   * Helper to write a JGF tree to SGF\r\n   */\r\n  function writeTree(tree, output) {\r\n\r\n    //Loop nodes in the tree\r\n    for (var i = 0; i < tree.length; i++) {\r\n      var node = tree[i];\r\n\r\n      //Array? That means a variation\r\n      if (angular.isArray(node)) {\r\n        for (var j = 0; j < node.length; j++) {\r\n          output.sgf += '(\\n;';\r\n          writeTree(node[j], output);\r\n          output.sgf += '\\n)';\r\n        }\r\n\r\n        //Continue\r\n        continue;\r\n      }\r\n\r\n      //Loop node properties\r\n      for (var key in node) {\r\n        if (node.hasOwnProperty(key)) {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n            parsingMap[key](node[key], output);\r\n            continue;\r\n          }\r\n\r\n          //Other object, can't handle it\r\n          if (typeof node[key] === 'object') {\r\n            continue;\r\n          }\r\n\r\n          //Anything else, append it\r\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //More to come?\r\n      if ((i + 1) < tree.length) {\r\n        output.sgf += '\\n;';\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to extract all SGF root properties from a JGF object\r\n   */\r\n  function extractRootProperties(jgf, rootProperties, key) {\r\n\r\n    //Initialize key\r\n    if (typeof key === 'undefined') {\r\n      key = '';\r\n    }\r\n\r\n    //Loop properties of jgf node\r\n    for (var subKey in jgf) {\r\n      if (jgf.hasOwnProperty(subKey)) {\r\n\r\n        //Skip SGF signature (as we keep our own)\r\n        if (subKey === 'sgf') {\r\n          continue;\r\n        }\r\n\r\n        //Build jgf key\r\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\r\n\r\n        //If the item is an object, handle separately\r\n        if (typeof jgf[subKey] === 'object') {\r\n\r\n          //Handler for this object present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\r\n          }\r\n\r\n          //Otherwise, just flatten and call this function recursively\r\n          else {\r\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Check if it's a known key, if so, append the value to the root\r\n        var value;\r\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\r\n\r\n          //Handler present in parsing map?\r\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\r\n            value = parsingMap[jgfKey](jgf[subKey]);\r\n          }\r\n          else {\r\n            value = escapeSgf(jgf[subKey]);\r\n          }\r\n\r\n          //Set in root properties\r\n          rootProperties[jgfAliases[jgfKey]] = value;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse JGF object or string into an SGF string\r\n     */\r\n    parse: function(jgf) {\r\n\r\n      //String given?\r\n      if (typeof jgf === 'string') {\r\n        jgf = angular.fromJson(jgf);\r\n      }\r\n\r\n      //Must have moves tree\r\n      if (!jgf.tree) {\r\n        console.error('No moves tree in JGF object');\r\n        return;\r\n      }\r\n\r\n      //Initialize output (as object, so it remains a reference) and root properties container\r\n      var output = {sgf: '(\\n;'};\r\n      var root = angular.copy(jgf);\r\n      var rootProperties = KifuBlank.sgf();\r\n\r\n      //The first node of the JGF tree is the root node, and it can contain comments,\r\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\r\n      //and attach it to the root\r\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\r\n        root = angular.extend(root, jgf.tree[0]);\r\n        delete root.root;\r\n        delete jgf.tree[0];\r\n      }\r\n\r\n      //Set root properties\r\n      delete root.tree;\r\n      extractRootProperties(root, rootProperties);\r\n\r\n      //Write root properties\r\n      for (var key in rootProperties) {\r\n        if (rootProperties[key]) {\r\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\r\n        }\r\n      }\r\n\r\n      //Write game tree\r\n      writeTree(jgf.tree, output);\r\n\r\n      //Close SGF and return\r\n      output.sgf += ')';\r\n      return output.sgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\r\n  'ngGo',\r\n  'ngGo.Kifu.Blank.Service'\r\n])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\r\n\r\n  /**\r\n   * Regular expressions for SGF data\r\n   */\r\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\r\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\r\n  var regProperty = /[A-Z]+/;\r\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\r\n\r\n  /**\r\n   * Character index of \"a\"\r\n   */\r\n  var aChar = 'a'.charCodeAt(0);\r\n\r\n  /**\r\n   * Helper to convert SGF coordinates\r\n   */\r\n  function convertCoordinates(coords) {\r\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * Conversion helpers\r\n   ***/\r\n\r\n  /**\r\n   * Application parser function (doesn't overwrite existing signature)\r\n   */\r\n  function parseApp(jgf, node, key, value) {\r\n    if (!jgf.record.application) {\r\n      var app = value[0].split(':');\r\n      if (app.length > 1) {\r\n        jgf.record.application = app[0] + ' v' + app[1];\r\n      }\r\n      else {\r\n        jgf.record.application = app[0];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SGF format parser\r\n   */\r\n  function parseSgfFormat() {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Game type parser function\r\n   */\r\n  function parseGame(jgf, node, key, value) {\r\n    var game = value[0];\r\n    if (typeof sgfGames[game] !== 'undefined') {\r\n      jgf.game.type = sgfGames[game];\r\n    }\r\n    else {\r\n      jgf.game.type = value[0];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move parser function\r\n   */\r\n  function parseMove(jgf, node, key, value) {\r\n\r\n    //Create move container\r\n    node.move = {};\r\n\r\n    //Pass\r\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\r\n      node.move[key] = 'pass';\r\n    }\r\n\r\n    //Regular move\r\n    else {\r\n      node.move[key] = convertCoordinates(value[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Comment parser function\r\n   */\r\n  function parseComment(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Node name parser function\r\n   */\r\n  function parseNodeName(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value[0];\r\n  }\r\n\r\n  /**\r\n   * Board setup parser function\r\n   */\r\n  function parseSetup(jgf, node, key, value) {\r\n\r\n    //Initialize setup container on node\r\n    if (typeof node.setup === 'undefined') {\r\n      node.setup = {};\r\n    }\r\n\r\n    //Remove \"A\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Initialize setup container of this type\r\n    if (typeof node.setup[key] === 'undefined') {\r\n      node.setup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.setup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scoring parser function\r\n   */\r\n  function parseScore(jgf, node, key, value) {\r\n\r\n    //Initialize score container on node\r\n    if (typeof node.score === 'undefined') {\r\n      node.score = {\r\n        B: [],\r\n        W: []\r\n      };\r\n    }\r\n\r\n    //Remove \"T\" from setup key\r\n    key = key.charAt(1);\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.score[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn parser function\r\n   */\r\n  function parseTurn(jgf, node, key, value) {\r\n    node.turn = value[0];\r\n  }\r\n\r\n  /**\r\n   * Label parser function\r\n   */\r\n  function parseLabel(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n\r\n      //Split off coordinates and add label contents\r\n      var coords = convertCoordinates(value[i].substr(0, 2));\r\n      coords.push(value[i].substr(3));\r\n\r\n      //Add to node\r\n      node.markup[key].push(coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Markup parser function\r\n   */\r\n  function parseMarkup(jgf, node, key, value) {\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Initialize markup container on node\r\n    if (typeof node.markup === 'undefined') {\r\n      node.markup = {};\r\n    }\r\n\r\n    //Initialize markup container of this type\r\n    if (typeof node.markup[key] === 'undefined') {\r\n      node.markup[key] = [];\r\n    }\r\n\r\n    //Add values\r\n    for (var i = 0; i < value.length; i++) {\r\n      node.markup[key].push(convertCoordinates(value[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Size parser function\r\n   */\r\n  function parseSize(jgf, node, key, value) {\r\n\r\n    //Initialize board container\r\n    if (typeof jgf.board === 'undefined') {\r\n      jgf.board = {};\r\n    }\r\n\r\n    //Add size property (can be width:height or just a single size)\r\n    var size = value[0].split(':');\r\n    if (size.length > 1) {\r\n      jgf.board.width = parseInt(size[0]);\r\n      jgf.board.height = parseInt(size[1]);\r\n    }\r\n    else {\r\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Date parser function\r\n   */\r\n  function parseDate(jgf, node, key, value) {\r\n\r\n    //Initialize dates container\r\n    if (typeof jgf.game.dates === 'undefined') {\r\n      jgf.game.dates = [];\r\n    }\r\n\r\n    //Explode dates\r\n    var dates = value[0].split(',');\r\n    for (var d = 0; d < dates.length; d++) {\r\n      jgf.game.dates.push(dates[d]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Komi parser function\r\n   */\r\n  function parseKomi(jgf, node, key, value) {\r\n    jgf.game.komi = parseFloat(value[0]);\r\n  }\r\n\r\n  /**\r\n   * Variations handling parser function\r\n   */\r\n  function parseVariations(jgf, node, key, value) {\r\n\r\n    //Initialize display property\r\n    if (typeof jgf.player === 'undefined') {\r\n      jgf.player = {};\r\n    }\r\n\r\n    //Initialize variation display settings\r\n    jgf.player.variationMarkup = false;\r\n    jgf.player.variationChildren = false;\r\n    jgf.player.variationSiblings = false;\r\n\r\n    //Parse as integer\r\n    var st = parseInt(value[0]);\r\n\r\n    //Determine what we want (see SGF specs for details)\r\n    switch (st) {\r\n      case 0:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 1:\r\n        jgf.player.variationMarkup = true;\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n      case 2:\r\n        jgf.player.variationChildren = true;\r\n        break;\r\n      case 3:\r\n        jgf.player.variationSiblings = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Player info parser function\r\n   */\r\n  function parsePlayer(jgf, node, key, value) {\r\n\r\n    //Initialize players container\r\n    if (typeof jgf.game.players === 'undefined') {\r\n      jgf.game.players = [];\r\n    }\r\n\r\n    //Determine player color\r\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\r\n\r\n    //Get key alias\r\n    if (typeof sgfAliases[key] !== 'undefined') {\r\n      key = sgfAliases[key];\r\n    }\r\n\r\n    //Check if player of this color already exists\r\n    for (var p = 0; p < jgf.game.players.length; p++) {\r\n      if (jgf.game.players[p].color === color) {\r\n        jgf.game.players[p][key] = value[0];\r\n        return;\r\n      }\r\n    }\r\n\r\n    //Player of this color not found, initialize\r\n    var player = {color: color};\r\n    player[key] = value[0];\r\n    jgf.game.players.push(player);\r\n  }\r\n\r\n  /**\r\n   * Parsing function to property mapper\r\n   */\r\n  var parsingMap = {\r\n\r\n    //Application, game type, board size, komi, date\r\n    'AP': parseApp,\r\n    'FF': parseSgfFormat,\r\n    'GM': parseGame,\r\n    'SZ': parseSize,\r\n    'KM': parseKomi,\r\n    'DT': parseDate,\r\n\r\n    //Variations handling\r\n    'ST': parseVariations,\r\n\r\n    //Player info handling\r\n    'PB': parsePlayer,\r\n    'PW': parsePlayer,\r\n    'BT': parsePlayer,\r\n    'WT': parsePlayer,\r\n    'BR': parsePlayer,\r\n    'WR': parsePlayer,\r\n\r\n    //Moves\r\n    'B': parseMove,\r\n    'W': parseMove,\r\n\r\n    //Node annotation\r\n    'C': parseComment,\r\n    'N': parseNodeName,\r\n\r\n    //Board setup\r\n    'AB': parseSetup,\r\n    'AW': parseSetup,\r\n    'AE': parseSetup,\r\n    'PL': parseTurn,\r\n    'TW': parseScore,\r\n    'TB': parseScore,\r\n\r\n    //Markup\r\n    'CR': parseMarkup,\r\n    'SQ': parseMarkup,\r\n    'TR': parseMarkup,\r\n    'MA': parseMarkup,\r\n    'SL': parseMarkup,\r\n    'LB': parseLabel\r\n  };\r\n\r\n  /**\r\n   * These properties need a node object\r\n   */\r\n  var needsNode = [\r\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\r\n  ];\r\n\r\n  /*****************************************************************************\r\n   * Parser helpers\r\n   ***/\r\n\r\n  /**\r\n   * Set info in the JGF tree at a certain position\r\n   */\r\n  function setInfo(jgf, position, value) {\r\n\r\n    //Position given must be an array\r\n    if (typeof position !== 'object') {\r\n      return;\r\n    }\r\n\r\n    //Initialize node to attach value to\r\n    var node = jgf;\r\n    var key;\r\n\r\n    //Loop the position\r\n    for (var p = 0; p < position.length; p++) {\r\n\r\n      //Get key\r\n      key = position[p];\r\n\r\n      //Last key reached? Done\r\n      if ((p + 1) === position.length) {\r\n        break;\r\n      }\r\n\r\n      //Create container if not set\r\n      if (typeof node[key] !== 'object') {\r\n        node[key] = {};\r\n      }\r\n\r\n      //Move up in tree\r\n      node = node[key];\r\n    }\r\n\r\n    //Set value\r\n    node[key] = value;\r\n  }\r\n\r\n  /**\r\n   * Parser class\r\n   */\r\n  var Parser = {\r\n\r\n    /**\r\n     * Parse SGF string into a JGF object or string\r\n     */\r\n    parse: function(sgf, stringified) {\r\n\r\n      //Get new JGF object (with SGF node as a base)\r\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\r\n\r\n      //Initialize\r\n      var stack = [];\r\n      var container = jgf.tree;\r\n\r\n      //Create first node for game, which is usually an empty board position, but can\r\n      //contain comments or board setup instructions, which will be added to the node\r\n      //later if needed.\r\n      var node = {root: true};\r\n      container.push(node);\r\n\r\n      //Find sequence of elements\r\n      var sequence = sgf.match(regSequence);\r\n\r\n      //Loop sequence items\r\n      for (var i = 0; i < sequence.length; i++) {\r\n\r\n        //Push stack if new variation found\r\n        if (sequence[i] === '(') {\r\n\r\n          //First encounter, this defines the main tree branch, so skip\r\n          if (i === 0 || i === '0') {\r\n            continue;\r\n          }\r\n\r\n          //Push the current container to the stack\r\n          stack.push(container);\r\n\r\n          //Create variation container if it doesn't exist yet\r\n          if (!angular.isArray(container[container.length - 1])) {\r\n            container.push([]);\r\n          }\r\n\r\n          //Use variation container\r\n          container = container[container.length - 1];\r\n\r\n          //Now create moves container\r\n          container.push([]);\r\n          container = container[container.length - 1];\r\n          continue;\r\n        }\r\n\r\n        //Grab last container from stack if end of variation reached\r\n        else if (sequence[i] === ')') {\r\n          if (stack.length) {\r\n            container = stack.pop();\r\n          }\r\n          continue;\r\n        }\r\n\r\n        //Make array of properties within this sequence\r\n        var properties = sequence[i].match(regNode) || [];\r\n\r\n        //Loop them\r\n        for (var j = 0; j < properties.length; j++) {\r\n\r\n          //Get property's key and separate values\r\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\r\n          var values = properties[j].match(regValues);\r\n\r\n          //Remove additional braces [ and ]\r\n          for (var k = 0; k < values.length; k++) {\r\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\r\n          }\r\n\r\n          //SGF parser present for this key? Call it, and we're done\r\n          if (typeof parsingMap[key] !== 'undefined') {\r\n\r\n            //Does this type of property need a node?\r\n            if (needsNode.indexOf(key) !== -1) {\r\n\r\n              //If no node object present, create a new node\r\n              //For moves, always a new node is created\r\n              if (!node || key === 'B' || key === 'W') {\r\n                node = {};\r\n                container.push(node);\r\n              }\r\n            }\r\n\r\n            //Apply parsing function on node\r\n            parsingMap[key](jgf, node, key, values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF parser present, we continue with regular property handling\r\n\r\n          //If there is only one value, simplify array\r\n          if (values.length === 1) {\r\n            values = values[0];\r\n          }\r\n\r\n          //SGF alias known? Then this is an info element and we handle it accordingly\r\n          if (typeof sgfAliases[key] !== 'undefined') {\r\n\r\n            //The position in the JGF object is represented by dot separated strings\r\n            //in the sgfAliases array. Split the position and use the setInfo helper\r\n            //to set the info on the JGF object\r\n            setInfo(jgf, sgfAliases[key].split('.'), values);\r\n            continue;\r\n          }\r\n\r\n          //No SGF alias present either, just append the data\r\n\r\n          //Save in node\r\n          if (node) {\r\n            node[key] = values;\r\n          }\r\n\r\n          //Save in root\r\n          else {\r\n            jgf[key] = values;\r\n          }\r\n        }\r\n\r\n        //Reset node, unless this was the root node\r\n        if (node && !node.root) {\r\n          node = null;\r\n        }\r\n      }\r\n\r\n      //Return stringified\r\n      if (stringified) {\r\n        return angular.toJson(jgf);\r\n      }\r\n\r\n      //Return jgf\r\n      return jgf;\r\n    }\r\n  };\r\n\r\n  //Return object\r\n  return Parser;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeCommon :: This class governs common event handling of the player shared by\r\n * various player modes. It's basically an abstract player mode and it can't be actively set.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Common.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Run block\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\r\n\r\n  /**\r\n   * Register common event handlers\r\n   */\r\n  Player.on('keydown', PlayerModeCommon.keyDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT\r\n  ]);\r\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\r\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\r\n  ]);\r\n}])\r\n\r\n/**\r\n * Factory definition\r\n */\r\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\r\n\r\n  /**\r\n   * Helper to build drag object\r\n   */\r\n  function dragObject(event) {\r\n\r\n    //Initialize drag object\r\n    var drag = {\r\n      start: {\r\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\r\n      },\r\n      stop: {\r\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\r\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\r\n      }\r\n    };\r\n\r\n    //Fix boundaries\r\n    if (drag.start.x < 0) {\r\n      drag.start.x = 0;\r\n    }\r\n    if (drag.start.y < 0) {\r\n      drag.start.y = 0;\r\n    }\r\n    if (drag.stop.x > this.board.width - 1) {\r\n      drag.stop.x = this.board.width - 1;\r\n    }\r\n    if (drag.stop.y > this.board.height - 1) {\r\n      drag.stop.y = this.board.height - 1;\r\n    }\r\n\r\n    //Return\r\n    return drag;\r\n  }\r\n\r\n  /**\r\n   * Normalize the mousewheel event helper\r\n   */\r\n  function normalizeMousewheelEvent(event) {\r\n\r\n    //Initialize vars\r\n    var deltaX = 0;\r\n    var deltaY = 0;\r\n\r\n    //Old school scrollwheel delta\r\n    if ('detail' in event) {\r\n      deltaY = event.detail * -1;\r\n    }\r\n    if ('wheelDelta' in event) {\r\n      deltaY = event.wheelDelta;\r\n    }\r\n    if ('wheelDeltaY' in event) {\r\n      deltaY = event.wheelDeltaY;\r\n    }\r\n    if ('wheelDeltaX' in event) {\r\n      deltaX = event.wheelDeltaX * -1;\r\n    }\r\n\r\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\r\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n      deltaX = deltaY * -1;\r\n      deltaY = 0;\r\n    }\r\n\r\n    //New type wheel delta (WheelEvent)\r\n    if ('deltaY' in event) {\r\n      deltaY = event.deltaY * -1;\r\n    }\r\n    if ('deltaX' in event) {\r\n      deltaX = event.deltaX;\r\n    }\r\n\r\n    //Set in event (have to use different property name because of strict mode)\r\n    event.mouseWheelX = deltaX;\r\n    event.mouseWheelY = deltaY;\r\n\r\n    //Return\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Player extension\r\n   */\r\n  angular.extend(Player, {\r\n\r\n    /**\r\n     * Mouse coordinate helper vars\r\n     */\r\n    mouse: {\r\n\r\n      //Drag start\r\n      dragStart: null,\r\n\r\n      //Last grid coordinates\r\n      lastX: -1,\r\n      lastY: -1\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Player mode definition\r\n   */\r\n  var PlayerMode = {\r\n\r\n    /**\r\n     * Handler for keydown events\r\n     */\r\n    keyDown: function(event, keyboardEvent) {\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Switch key code\r\n      switch (keyboardEvent.keyCode) {\r\n\r\n        //ESC\r\n        case KeyCodes.ESC:\r\n\r\n          //Cancel drag event, and prevent click event as well\r\n          this.mouse.dragStart = null;\r\n          this.preventClickEvent = true;\r\n          break;\r\n\r\n        //Right arrow\r\n        case KeyCodes.RIGHT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Advance to the next move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\r\n              this.next();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Left arrow\r\n        case KeyCodes.LEFT:\r\n\r\n          //Arrow navigation enabled?\r\n          if (this.arrowKeysNavigation) {\r\n            keyboardEvent.preventDefault();\r\n\r\n            //Go to the previous move\r\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\r\n              this.previous();\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Up arrow\r\n        case KeyCodes.UP:\r\n          break;\r\n\r\n        //Down arrow\r\n        case KeyCodes.DOWN:\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Handler for mousewheel events\r\n     */\r\n    mouseWheel: function(event, mouseEvent) {\r\n\r\n      //Disabled or not using move tool?\r\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\r\n        return true;\r\n      }\r\n\r\n      //No game?\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return true;\r\n      }\r\n\r\n      //Normalize mousewheel event\r\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\r\n\r\n      //Find delta\r\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\r\n\r\n      //Next move\r\n      if (delta < 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.next();\r\n      }\r\n\r\n      //Previous move\r\n      else if (delta > 0) {\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n        this.previous();\r\n      }\r\n\r\n      //Don't scroll the window\r\n      if (delta !== 0) {\r\n        mouseEvent.preventDefault();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse out handler\r\n     */\r\n    mouseOut: function() {\r\n      if (this.board) {\r\n        this.board.removeAll('hover');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Mouse move handler\r\n     */\r\n    mouseMove: function(event, mouseEvent) {\r\n\r\n      //Attach drag object to events\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n      }\r\n\r\n      //Nothing else to do?\r\n      if (!this.board || !this.board.layers.hover) {\r\n        return;\r\n      }\r\n\r\n      //Last coordinates are the same?\r\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\r\n        return;\r\n      }\r\n\r\n      //Remember last coordinates\r\n      this.mouse.lastX = event.x;\r\n      this.mouse.lastY = event.y;\r\n\r\n      //Broadcast hover event\r\n      this.broadcast('hover', mouseEvent);\r\n    },\r\n\r\n    /**\r\n     * Mouse down handler\r\n     */\r\n    mouseDown: function(event) {\r\n      this.mouse.dragStart = {\r\n        x: event.x,\r\n        y: event.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Mouse up handler\r\n     */\r\n    mouseUp: function(event, mouseEvent) {\r\n      if (\r\n        this.mouse.dragStart &&\r\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\r\n      ) {\r\n        mouseEvent.drag = dragObject.call(this, event);\r\n        this.broadcast('mousedrag', mouseEvent);\r\n      }\r\n      this.mouse.dragStart = null;\r\n    }\r\n  };\r\n\r\n  //Return\r\n  return PlayerMode;\r\n}]);\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\r\n * a game record and its board positions.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Edit.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Setup tools\r\n */\r\n.constant('SetupTools', {\r\n  BLACK: 'black',\r\n  WHITE: 'white',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Markup tools\r\n */\r\n.constant('MarkupTools', {\r\n  TRIANGLE: 'triangle',\r\n  CIRCLE: 'circle',\r\n  SQUARE: 'square',\r\n  MARK: 'mark',\r\n  SELECT: 'select',\r\n  SAD: 'sad',\r\n  HAPPY: 'happy',\r\n  TEXT: 'text',\r\n  NUMBER: 'number',\r\n  CLEAR: 'clear'\r\n})\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\r\n\r\n  //Register event handlers\r\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\r\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\r\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\r\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\r\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\r\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\r\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeEdit', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\r\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\r\n  ) {\r\n\r\n    //Character codes\r\n    var aChar = 'A'.charCodeAt(0);\r\n    var aCharLc = 'a'.charCodeAt(0);\r\n\r\n    /**\r\n     * Update hover mark at specific coordinates\r\n     */\r\n    function updateHoverMark(x, y, isDrag) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Setup tool\r\n        case PlayerTools.SETUP:\r\n\r\n          //Clear tool\r\n          if (this.setupTool === SetupTools.CLEAR) {\r\n\r\n            //Stone present? Can remove it\r\n            if (this.game.hasStone(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Stone color tool\r\n          else {\r\n\r\n            //Add or overwrite stone if no stone present of the given color\r\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'stones',\r\n                value: this.setupToolColor()\r\n              });\r\n            }\r\n\r\n            //Stone present of same color? Can remove it if we're not dragging\r\n            else if (!isDrag) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n          break;\r\n\r\n        //Markup tool\r\n        case PlayerTools.MARKUP:\r\n\r\n          //Clear tool, or already markup in place?\r\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\r\n            if (this.game.hasMarkup(x, y)) {\r\n              this.board.add('hover', x, y, {\r\n                type: 'markup',\r\n                value: MarkupTypes.MARK\r\n              });\r\n            }\r\n          }\r\n\r\n          //Text or number\r\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: {\r\n                type: MarkupTypes.LABEL,\r\n                text: this.markupLabel\r\n              }\r\n            });\r\n          }\r\n\r\n          //Other markup\r\n          else {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: this.markupTool\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set markup\r\n     */\r\n    function setMarkup(x, y) {\r\n\r\n      //Already markup in place? Remove it first\r\n      if (this.game.hasMarkup(x, y)) {\r\n\r\n        //Check what markup there is\r\n        var markup = this.game.getMarkup(x, y);\r\n\r\n        //Label? Also remove from our labels list\r\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\r\n          var i = this.markupLabels.indexOf(markup.text);\r\n          if (i !== -1) {\r\n            this.markupLabels.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        //Remove from game\r\n        this.game.removeMarkup(x, y);\r\n        return;\r\n      }\r\n\r\n      //Clear tool used? Done\r\n      if (this.markupTool === MarkupTools.CLEAR) {\r\n        return;\r\n      }\r\n\r\n      //Text\r\n      else if (this.markupTool === MarkupTools.TEXT) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next text label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Number\r\n      else if (this.markupTool === MarkupTools.NUMBER) {\r\n        this.game.addMarkup(x, y, {\r\n          type: MarkupTypes.LABEL,\r\n          text: this.markupLabel\r\n        });\r\n\r\n        //Determine next number label\r\n        this.markupLabels.push(this.markupLabel);\r\n        this.determineMarkupLabel();\r\n      }\r\n\r\n      //Other markup\r\n      else {\r\n        this.game.addMarkup(x, y, this.markupTool);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to set a stone\r\n     */\r\n    function setStone(x, y, isDrag) {\r\n\r\n      //Get the stone color\r\n      var color = this.setupToolColor();\r\n\r\n      //Trying to remove a stone\r\n      if (color === StoneColor.EMPTY) {\r\n        this.game.removeStone(x, y);\r\n      }\r\n\r\n      //Adding a stone\r\n      else {\r\n\r\n        //A stone there already of the same color? Just remove if not dragging\r\n        if (!isDrag && this.game.hasStone(x, y, color)) {\r\n          this.game.removeStone(x, y);\r\n          return;\r\n        }\r\n\r\n        //Any stone present?\r\n        else if (this.game.hasStone(x, y)) {\r\n          this.game.removeStone(x, y);\r\n        }\r\n\r\n        //Add stone now\r\n        this.game.addStone(x, y, color);\r\n      }\r\n\r\n      //Redraw markup\r\n      this.board.layers.markup.redrawCell(x, y);\r\n    }\r\n\r\n    /**\r\n     * Find all markup labels in current position\r\n     */\r\n    function findAllMarkupLabels() {\r\n\r\n      //Clear\r\n      this.markupLabels = [];\r\n\r\n      //Must have game\r\n      if (!this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get all markup from position\r\n      var markup = this.game.position.markup.all('type');\r\n      for (var i = 0; i < markup.length; i++) {\r\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\r\n          this.markupLabels.push(markup[i].text);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Active setup tool and markup tool\r\n      setupTool: SetupTools.BLACK,\r\n      markupTool: MarkupTools.TRIANGLE,\r\n\r\n      //Current markup labels on the board and current markup label\r\n      markupLabels: [],\r\n      markupLabel: '',\r\n\r\n      /**\r\n       * Set the setup tool\r\n       */\r\n      switchSetupTool: function(tool) {\r\n        this.setupTool = tool;\r\n      },\r\n\r\n      /**\r\n       * Set the markup tool\r\n       */\r\n      switchMarkupTool: function(tool) {\r\n        this.markupTool = tool;\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          this.determineMarkupLabel();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Conversion of setup tool to stone color\r\n       */\r\n      setupToolColor: function() {\r\n        switch (this.setupTool) {\r\n          case SetupTools.BLACK:\r\n            return StoneColor.B;\r\n          case SetupTools.WHITE:\r\n            return StoneColor.W;\r\n          default:\r\n            return StoneColor.EMPTY;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set the new text markup label\r\n       */\r\n      setMarkupLabel: function(label) {\r\n        if (label) {\r\n          this.markupLabel = label;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Determine the new text markup label\r\n       */\r\n      determineMarkupLabel: function() {\r\n\r\n        //Clear\r\n        this.markupLabel = '';\r\n\r\n        //Check what tool we're using\r\n        switch (this.markupTool) {\r\n\r\n          //Text tool?\r\n          case MarkupTools.TEXT:\r\n            var i = 0;\r\n\r\n            //Loop while the label is present\r\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n\r\n              //A-Z\r\n              if (i < 26) {\r\n                this.markupLabel = String.fromCharCode(aChar + i);\r\n              }\r\n\r\n              //a-z\r\n              else if (i < 52) {\r\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\r\n              }\r\n\r\n              //AA, AB, AC, etc.\r\n              else {\r\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\r\n                  String.fromCharCode(aChar + (i % 26));\r\n              }\r\n\r\n              //Keep going\r\n              i++;\r\n            }\r\n            break;\r\n\r\n          //Number tool?\r\n          case MarkupTools.NUMBER:\r\n            this.markupLabel = 0;\r\n\r\n            //Loop while the label is present\r\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\r\n              this.markupLabel++;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeEdit = {\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Must have board\r\n        if (!this.board) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items\r\n        this.board.removeAll('hover');\r\n\r\n        //Single coordinate?\r\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //No dragging for labels\r\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n          updateHoverMark.call(this);\r\n          return;\r\n        }\r\n\r\n        //Loop area\r\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n            updateHoverMark.call(this, x, y, true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Keydown handler\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //TODO: tool switching via keyboard input\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Click handler\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        this.board.removeAll('hover');\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Try to play the move\r\n            if (!this.game.play(event.x, event.y)) {\r\n              return;\r\n            }\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Set stone and update board\r\n            setStone.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Set markup and update board\r\n            setMarkup.call(this, event.x, event.y);\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Mouse drag handler\r\n       */\r\n      mouseDrag: function(event) {\r\n\r\n        //Initialize vars\r\n        var x, y;\r\n\r\n        //Remove all hover items now to restore actual stones and markup to the board,\r\n        //otherwise it will conflict when updating the board\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Setup tool\r\n          case PlayerTools.SETUP:\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setStone.call(this, x, y, true);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n\r\n          //Markup tool\r\n          case PlayerTools.MARKUP:\r\n\r\n            //Don't do this for labels\r\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\r\n              break;\r\n            }\r\n\r\n            //Loop dragging grid\r\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\r\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\r\n                setMarkup.call(this, x, y);\r\n              }\r\n            }\r\n\r\n            //Process position\r\n            this.processPosition();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeEdit.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change\r\n       */\r\n      pathChange: function() {\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SETUP,\r\n          PlayerTools.MARKUP,\r\n          PlayerTools.SCORE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Find all markup labels in the current game position\r\n        findAllMarkupLabels.call(this);\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeEdit;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\r\n * through an existing game record without the ability to deviate from the tree or its variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Replay.Service', [\r\n  'ngGo',\r\n  'ngGo.Game.Scorer.Service'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\r\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\r\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\r\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\r\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\r\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\r\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\r\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\r\n\r\n  //Register the mode\r\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeReplay', function() {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Auto play delay\r\n    autoPlayDelay: 1000\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n\r\n        //Score tool\r\n        case PlayerTools.SCORE:\r\n\r\n          //Hovering over a stone means it can be marked dead or alive\r\n          if (this.game.hasStone(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'markup',\r\n              value: MarkupTypes.MARK\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show move variations on the board\r\n     */\r\n    function showMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n\r\n        //Auto variation markup should never overwrite existing markup\r\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\r\n          continue;\r\n        }\r\n\r\n        //Add to board\r\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n          type: this.board.theme.get('markup.variation.type'),\r\n          text: this.board.theme.get('markup.variation.text', i),\r\n          color: this.board.theme.get('markup.variation.color')\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide move variations from the board\r\n     */\r\n    function hideMoveVariations(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) move variations on the board\r\n     */\r\n    function drawMoveVariations(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get the current node\r\n      var node = this.game.getNode();\r\n      var variations;\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      //Child variations?\r\n      if (this.variationChildren && node.hasMoveVariations()) {\r\n        variations = node.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n\r\n      //Sibling variations?\r\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\r\n        variations = node.parent.getMoveVariations();\r\n        if (show) {\r\n          showMoveVariations.call(this, variations);\r\n        }\r\n        else {\r\n          hideMoveVariations.call(this, variations);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Auto play vars\r\n      autoPlaying: false,\r\n      autoPlayDelay: 1000,\r\n      autoPlayPromise: null,\r\n\r\n      /**\r\n       * Set auto play delay\r\n       */\r\n      setAutoPlayDelay: function(delay) {\r\n        if (this.autoPlayDelay !== delay) {\r\n          this.autoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'autoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Start auto play with a given delay\r\n       */\r\n      start: function(delay) {\r\n\r\n        //Not in replay mode or already auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Already auto playing, no game or no move children?\r\n        if (!this.game || !this.game.node.hasChildren()) {\r\n          return;\r\n        }\r\n\r\n        //Get self\r\n        var self = this;\r\n\r\n        //Determine delay\r\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\r\n\r\n        //Switch tool\r\n        this.switchTool(PlayerTools.NONE);\r\n\r\n        //Create interval\r\n        this.autoPlaying = true;\r\n        this.autoPlayPromise = $interval(function() {\r\n\r\n          //Advance to the next node\r\n          self.next(0, true);\r\n\r\n          //Ran out of children?\r\n          if (!self.game.node.hasChildren()) {\r\n            self.stop();\r\n          }\r\n        }, delay);\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStarted', this.game.node);\r\n      },\r\n\r\n      /**\r\n       * Stop auto play\r\n       */\r\n      stop: function() {\r\n\r\n        //Not in replay mode or not auto playing?\r\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\r\n          return;\r\n        }\r\n\r\n        //Cancel interval\r\n        if (this.autoPlayPromise) {\r\n          $interval.cancel(this.autoPlayPromise);\r\n        }\r\n\r\n        //Clear flags\r\n        this.autoPlayPromise = null;\r\n        this.autoPlaying = false;\r\n\r\n        //Broadcast event\r\n        this.broadcast('autoPlayStopped', this.game.node);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeReplay = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'variationMarkup') {\r\n          drawMoveVariations.call(this, this.variationMarkup);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //What happens, depends on the active tool\r\n        switch (this.tool) {\r\n\r\n          //Move tool\r\n          case PlayerTools.MOVE:\r\n\r\n            //Check if we clicked a move variation, advance to the next position if so\r\n            if (this.game.isMoveVariation(event.x, event.y)) {\r\n              this.next(this.game.getMoveVariation(event.x, event.y));\r\n            }\r\n            break;\r\n\r\n          //Score tool, mark stones dead or alive\r\n          case PlayerTools.SCORE:\r\n\r\n            //Mark the clicked item and score the current game position\r\n            GameScorer.mark(event.x, event.y);\r\n            this.scoreGame();\r\n            break;\r\n        }\r\n\r\n        //Handle hover\r\n        PlayerModeReplay.hover.call(this, event);\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE,\r\n          PlayerTools.SCORE,\r\n          PlayerTools.NONE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Show move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Stop auto playing\r\n        if (this.autoPlaying) {\r\n          this.stop();\r\n        }\r\n\r\n        //Hide move variations\r\n        if (this.variationMarkup) {\r\n          drawMoveVariations.call(this, false);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for tool switches\r\n       */\r\n      toolSwitch: function() {\r\n\r\n        //Switched to scoring?\r\n        if (this.tool === PlayerTools.SCORE) {\r\n\r\n          //Remember the current board state\r\n          this.statePreScoring = this.board.getState();\r\n\r\n          //Load game into scorer and score the game\r\n          GameScorer.load(this.game);\r\n          this.scoreGame();\r\n        }\r\n\r\n        //Back to another state?\r\n        else {\r\n          if (this.statePreScoring) {\r\n            this.board.restoreState(this.statePreScoring);\r\n            delete this.statePreScoring;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeReplay;\r\n  }];\r\n});\r\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\r\n/**\r\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\r\n * go problems and finding the right move or variations.\r\n */\r\n\r\n/**\r\n * Module definition and dependencies\r\n */\r\nangular.module('ngGo.Player.Mode.Solve.Service', [\r\n  'ngGo'\r\n])\r\n\r\n/**\r\n * Extend player functionality and register the mode\r\n */\r\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\r\n\r\n  //Register event handlers\r\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\r\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\r\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\r\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\r\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\r\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\r\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\r\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\r\n\r\n  //Register mode\r\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\r\n}])\r\n\r\n/**\r\n * Provider definition\r\n */\r\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\r\n\r\n  /**\r\n   * Default configuration\r\n   */\r\n  var defaultConfig = {\r\n\r\n    //Player color\r\n    playerColor: StoneColor.B,\r\n\r\n    //Show solution paths\r\n    solutionPaths: false,\r\n\r\n    //Auto play settings\r\n    solveAutoPlay: true,\r\n    solveAutoPlayDelay: 500\r\n  };\r\n\r\n  /**\r\n   * Set global default configuration for players\r\n   */\r\n  this.setConfig = function(config) {\r\n    defaultConfig = angular.extend(defaultConfig, config);\r\n  };\r\n\r\n  /**\r\n   * Service getter\r\n   */\r\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\r\n\r\n    /**\r\n     * Check if we can make a move\r\n     */\r\n    function canMakeMove() {\r\n\r\n      //We can make a move when...\r\n\r\n      //...there is no auto play going on\r\n      if (!this.solveAutoPlay) {\r\n        return true;\r\n      }\r\n\r\n      //...we solved the puzzle already\r\n      if (this.problemSolved) {\r\n        return true;\r\n      }\r\n\r\n      //...we are off path\r\n      if (this.problemOffPath) {\r\n        return true;\r\n      }\r\n\r\n      //...it's our turn\r\n      if (this.game.getTurn() === this.playerColor) {\r\n        return true;\r\n      }\r\n\r\n      //Otherwise, we can't make a move\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Helper to update the hover mark\r\n     */\r\n    function updateHoverMark(x, y) {\r\n\r\n      //If no coordinates specified, use last mouse coordinates\r\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\r\n        x = this.mouse.lastX;\r\n        y = this.mouse.lastY;\r\n      }\r\n\r\n      //Falling outside of grid?\r\n      if (!this.board || !this.board.isOnBoard(x, y)) {\r\n        return;\r\n      }\r\n\r\n      //What happens, depends on the active tool\r\n      switch (this.tool) {\r\n\r\n        //Move tool\r\n        case PlayerTools.MOVE:\r\n\r\n          //Hovering over empty spot where we can make a move?\r\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\r\n            this.board.add('hover', x, y, {\r\n              type: 'stones',\r\n              value: this.game.getTurn()\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to show solution paths\r\n     */\r\n    function showSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        if (variations[i].solution === true) {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.valid.type'),\r\n            text: this.board.theme.get('markup.solution.valid.text', i),\r\n            scale: this.board.theme.get('markup.solution.valid.scale'),\r\n            color: this.board.theme.get('markup.solution.valid.color')\r\n          });\r\n        }\r\n        else {\r\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\r\n            type: this.board.theme.get('markup.solution.invalid.type'),\r\n            text: this.board.theme.get('markup.solution.invalid.text', i),\r\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\r\n            color: this.board.theme.get('markup.solution.invalid.color')\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to hide solution paths\r\n     */\r\n    function hideSolutionPaths(variations) {\r\n      for (var i = 0; i < variations.length; i++) {\r\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Draw (or clear) solution paths\r\n     */\r\n    function drawSolutionPaths(show) {\r\n\r\n      //Check if we can do something\r\n      if (!this.board || !this.game || !this.game.isLoaded()) {\r\n        return;\r\n      }\r\n\r\n      //Get node and variations\r\n      var node = this.game.getNode();\r\n      var variations = node.getMoveVariations();\r\n\r\n      //When showing, make sure it's not during the auto solver's move\r\n      if (show && !this.problemSolved && this.solveAutoPlay) {\r\n        if (this.game.getTurn() !== this.playerColor) {\r\n          hideSolutionPaths.call(this, variations);\r\n          return;\r\n        }\r\n      }\r\n\r\n      //Call helper\r\n      if (show) {\r\n        showSolutionPaths.call(this, variations);\r\n      }\r\n      else {\r\n        hideSolutionPaths.call(this, variations);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Player extension\r\n     */\r\n    angular.extend(Player, {\r\n\r\n      //Solved and off-path flags\r\n      problemSolved: false,\r\n      problemOffPath: false,\r\n\r\n      //Problem start path\r\n      problemStartPath: null,\r\n\r\n      //The player color\r\n      playerColor: 0,\r\n\r\n      //Solution paths\r\n      solutionPaths: false,\r\n\r\n      //Auto play vars\r\n      solveAutoPlay: true,\r\n      solveAutoPlayDelay: 500,\r\n\r\n      //Navigation blocked flag\r\n      solveNavigationBlocked: false,\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlay: function(autoPlay) {\r\n        if (this.solveAutoPlay !== autoPlay) {\r\n          this.solveAutoPlay = autoPlay;\r\n          this.broadcast('settingChange', 'solveAutoPlay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set solve auto play delay\r\n       */\r\n      setSolveAutoPlayDelay: function(delay) {\r\n        if (this.solveAutoPlayDelay !== delay) {\r\n          this.solveAutoPlayDelay = delay;\r\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Set player color\r\n       */\r\n      setPlayerColor: function(color) {\r\n        if (this.playerColor !== color) {\r\n          this.playerColor = color;\r\n          this.broadcast('settingChange', 'playerColor');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Get player color\r\n       */\r\n      getPlayerColor: function(asOnBoard) {\r\n        if (asOnBoard && this.board) {\r\n          return this.board.colorMultiplier * this.playerColor;\r\n        }\r\n        return this.playerColor;\r\n      },\r\n\r\n      /**\r\n       * Toggle solution paths\r\n       */\r\n      toggleSolutionPaths: function(solutionPaths) {\r\n\r\n        //Toggle if not given\r\n        if (typeof solutionPaths === 'undefined') {\r\n          solutionPaths = !this.solutionPaths;\r\n        }\r\n\r\n        //Change?\r\n        if (solutionPaths !== this.solutionPaths) {\r\n          this.solutionPaths = solutionPaths;\r\n          this.broadcast('settingChange', 'solutionPaths');\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Auto play next move\r\n       */\r\n      autoPlayNext: function(immediately) {\r\n\r\n        //Must have game and children\r\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\r\n          return;\r\n        }\r\n\r\n        //Init vars\r\n        var children = [];\r\n        var self = this;\r\n        var i;\r\n\r\n        //When picking a child node, we always prefer to pick a valid solution\r\n        for (i = 0; i < this.game.node.children.length; i++) {\r\n          if (this.game.node.children[i].solution) {\r\n            children.push(this.game.node.children[i]);\r\n          }\r\n        }\r\n\r\n        //No solution nodes? Just use all nodes then.\r\n        if (children.length === 0) {\r\n          children = this.game.node.children;\r\n        }\r\n\r\n        //Pick a random child node\r\n        i = Math.floor(Math.random() * children.length);\r\n\r\n        //No delay?\r\n        if (immediately || !this.solveAutoPlayDelay) {\r\n          this.next(children[i]);\r\n          return;\r\n        }\r\n\r\n        //Block navigation and run the timeout\r\n        this.solveNavigationBlocked = true;\r\n        $timeout(function() {\r\n\r\n          //Move to next move and unblock navigation\r\n          self.next(children[i]);\r\n          self.solveNavigationBlocked = false;\r\n\r\n        }, this.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Start solving from the current game node\r\n       */\r\n      solve: function() {\r\n\r\n        //Must have a game\r\n        if (!this.game || !this.game.isLoaded()) {\r\n          return false;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Remember problem start path\r\n        this.problemStartPath = this.game.getPath(true);\r\n\r\n        //Restrict start of navigation to the current node\r\n        this.restrictNode();\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Restart the problem\r\n       */\r\n      restartProblem: function() {\r\n\r\n        //Must be in solve mode, must have game\r\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\r\n          return;\r\n        }\r\n\r\n        //Reset flags\r\n        this.problemSolved = false;\r\n        this.problemOffPath = false;\r\n\r\n        //Go back to the start path\r\n        if (this.problemStartPath) {\r\n          this.goto(this.problemStartPath);\r\n        }\r\n\r\n        //Auto play next move if it's not our turn\r\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\r\n          this.autoPlayNext();\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Player mode definition\r\n     */\r\n    var PlayerModeSolve = {\r\n\r\n      /**\r\n       * Parse config instructions\r\n       */\r\n      parseConfig: function(config) {\r\n\r\n        //Extend from default config\r\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\r\n\r\n        //Process settings\r\n        this.toggleSolutionPaths(this.config.solutionPaths);\r\n        this.setPlayerColor(this.config.playerColor);\r\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\r\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\r\n      },\r\n\r\n      /**\r\n       * Setting changes handler\r\n       */\r\n      settingChange: function(event, setting) {\r\n\r\n        //Solution paths setting changes?\r\n        if (setting === 'solutionPaths') {\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n        }\r\n\r\n        //Player color changed?\r\n        if (setting === 'playerColor') {\r\n\r\n          //Draw (or hide) solution paths\r\n          drawSolutionPaths.call(this, this.solutionPaths);\r\n\r\n          //Make an auto play move if it's not our turn\r\n          if (\r\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\r\n          ) {\r\n            this.autoPlayNext(true);\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Hover handler\r\n       */\r\n      hover: function(event) {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this, event.x, event.y);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Board update event handler\r\n       */\r\n      boardUpdate: function() {\r\n\r\n        //Show move variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for keydown events\r\n       */\r\n      keyDown: function(event, keyboardEvent) {\r\n\r\n        //Switch key code\r\n        switch (keyboardEvent.keyCode) {\r\n\r\n          //Right arrow\r\n          case KeyCodes.RIGHT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\r\n\r\n                //Go forward one move if solved\r\n                if (this.problemSolved) {\r\n                  this.next();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n\r\n          //Left arrow\r\n          case KeyCodes.LEFT:\r\n\r\n            //Arrow keys navigation enabled?\r\n            if (this.arrowKeysNavigation) {\r\n              keyboardEvent.preventDefault();\r\n\r\n              //Navigation not blocked and not reached the start?\r\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\r\n\r\n                //Go back one move\r\n                this.previous();\r\n\r\n                //Go back one more if this is not the player's turn and if\r\n                //the problem hasn't been solved yet\r\n                if (\r\n                  !this.problemSolved && this.solveAutoPlay &&\r\n                  this.game.getTurn() === -this.playerColor\r\n                ) {\r\n                  this.previous();\r\n                }\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mouse click events\r\n       */\r\n      click: function(event) {\r\n\r\n        //Falling outside of grid?\r\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\r\n          return;\r\n        }\r\n\r\n        //A valid variation\r\n        if (this.game.isMoveVariation(event.x, event.y)) {\r\n\r\n          //Get the node\r\n          var i = this.game.getMoveVariation(event.x, event.y);\r\n\r\n          //Advance to the next position and get the next node\r\n          this.next(i);\r\n          var node = this.game.getNode();\r\n\r\n          //No children left? Check if we solved it or not\r\n          if (node.children.length === 0) {\r\n            if (node.solution === true) {\r\n              this.problemSolved = true;\r\n              this.broadcast('solutionFound', node);\r\n            }\r\n            else {\r\n              this.broadcast('solutionWrong', node);\r\n            }\r\n          }\r\n\r\n          //Auto-play next move?\r\n          else if (!this.problemSolved && this.solveAutoPlay) {\r\n            this.autoPlayNext();\r\n          }\r\n        }\r\n\r\n        //Unknown variation, try to play\r\n        else if (this.game.play(event.x, event.y)) {\r\n          this.problemOffPath = true;\r\n          this.processPosition();\r\n          this.broadcast('solutionOffPath', this.game.getNode());\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Path change event\r\n       */\r\n      pathChange: function() {\r\n\r\n        //Update hover mark\r\n        if (this.board) {\r\n          this.board.removeAll('hover');\r\n          updateHoverMark.call(this);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode entry\r\n       */\r\n      modeEnter: function() {\r\n\r\n        //Set available tools for this mode\r\n        this.setTools([\r\n          PlayerTools.MOVE\r\n        ]);\r\n\r\n        //Set default tool\r\n        this.tool = this.tools[0];\r\n\r\n        //Draw solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, true);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Handler for mode exit\r\n       */\r\n      modeExit: function() {\r\n\r\n        //Hide any solution variations\r\n        if (this.solutionPaths) {\r\n          drawSolutionPaths.call(this, false);\r\n        }\r\n      }\r\n    };\r\n\r\n    //Return\r\n    return PlayerModeSolve;\r\n  }];\r\n}]);\r\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}